// JavaScript source code

   ! function o(a, s, c) {
        function l(t, e) {
            if (!s[t]) {
                if (!a[t]) {
                    var n = "function" == typeof require && require;
                    if (!e && n) return n(t, !0);
                    if (u) return u(t, !0);
                    var r = new Error("Cannot find module '" + t + "'");
                    throw r.code = "MODULE_NOT_FOUND", r
                }
                var i = s[t] = {
                    exports: {}
                };
                a[t][0].call(i.exports, function (e) {
                    return l(a[t][1][e] || e)
                }, i, i.exports, o, a, s, c)
            }
            return s[t].exports
        }
        for (var u = "function" == typeof require && require, e = 0; e < c.length; e++) l(c[e]);
        return l
    }({
       // initThree module
        1: [function (e, t, n) {
            "use strict";
            Object.defineProperty(n, "__esModule", {
                value: !0
            });
            var r = function () {
                function r(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }
                return function (e, t, n) {
                    return t && r(e.prototype, t), n && r(e, n), e
                }
            }(),
                i = function (e) {
                    {
                        if (e && e.__esModule) return e;
                        var t = {};
                        if (null != e)
                            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                        return t.default = e, t
                    }
                }(e("../libs/three.module.js")),
                o = s(e("../utils/initdevicecontrols.js")),
                a = s(e("./initvidplane"));
            e("../libs/three.module");

            function s(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var initThree = function () {
                function n() {
                    ! function (e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, n),


                        // setting up the threejs environment
                        //defining the canvas for threejs to be create on
                    this.canvas = $("#three_container")[0];
                    var e = 50, // i believe this is 50% of the windowWidth
                        t = 2 * Math.tan(i.Math.degToRad(e / 2)) / Math.max(document.documentElement.clientWidth, document.documentElement.clientHeight);
                        e = 2 * i.Math.radToDeg(Math.atan(t * this.canvas.offsetHeight / 2)), // the final FOV value

                            // first define the camera, scene and add camera and create the renderer
                        this.camera = new i.PerspectiveCamera(e, this.canvas.offsetWidth / this.canvas.offsetHeight, .1, 1e4),
                        this.camera.rotation.x = i.Math.degToRad(45),
                        this.scene = new i.Scene,
                        this.scene.add(this.camera),
                        this.renderer = new i.WebGLRenderer({
                            canvas: this.canvas,
                            antialias: !1,
                            alpha: !0,
                            premultipliedAlpha: !0
                        }), // change settings of renderer
                        this.renderer.setClearColor(0, 0),
                        this.renderer.setPixelRatio(window.devicePixelRatio),
                        this.renderer.setSize(this.canvas.offsetWidth, this.canvas.offsetHeight, !1),

                           // define the controls and connect it
                        this.controls = new o.default(this.camera, this.renderer),
                        this.controls.connect(),


                            // initialising videoplane, refer to initvidplane module for more
                        this.initvidplane = new a.default(this.camera, this.scene)
                }
                return r(n, [{
                    key: "getVideo",
                    value: function () {
                        console.log(this.k);
                        return this.initvidplane
                    }
                }, {
                    key: "update",
                    value: function () {
                        var e = this;
                        this.renderer.animate(function () {
                            e.controls.update(),
                            e.renderer.render(e.scene, e.camera)
                        })
                    }
                }]), n
            }();
            n.default = initThree
        }, {
            "../libs/three.module": 6,
            "../libs/three.module.js": 6,
            "../utils/initdevicecontrols.js": 7,
            "./initvidplane": 3
        }],

        ///////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////
        // pageControl module
        2: [function (e, t, n) {
            "use strict";
            var r = function () {
                function r(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }
                return function (e, t, n) {
                    return t && r(e.prototype, t), n && r(e, n), e
                }
            }(),
                i = a(e("./initAR")),
                o = a(e("./initThree.js"));
            ! function (e) {
                {
                    if (e && e.__esModule) return;
                    var t = {};
                    if (null != e)
                        for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                    t.default = e
                }
            }(e("../libs/three.module.js"));

            function a(e) { // function that allow referencing to another module
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            new (function () {
                function t() {
                    ! function (e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t);
                    var e = navigator.userAgent.toLowerCase();
                    this.isAndroid = /android/i.test(e),
                    this.isIphone = /(iPhone|iPad|iPod|iOS)/i.test(e),
                    this.isWeChat = /MicroMessenger/i.test(e), 
                    this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                    this.iosversion = e.match(/os\s+(\d+)/i) || !1,
                    this.winHeight = window.innerHeight,

                        // html references
                        // pages+ buttons
                    this.initAR = new i.default,
                    this.preload = new createjs.LoadQueue(!1),
                        this.preloadOption = new createjs.LoadQueue(!1),
                    this.bodyElement = $("#body"),

                        this.chosenOption = 0,

                        this.pSelect = $(".pSelect"),
                        this.pLoadVid = $(".pLoadVid"),
                        this.pLoading = $(".pLoading"),
                    this.pStartAR = $(".pStartAR"),
                    this.pScanning = $(".pScanning"),
                    this.posterBox = $(".posterBox"),
                    this.bStartAR = $("#bStartAR"),
                    this.video = $("#video")[0],
                    this.bReady = $(".bReady"),
                    this.pIntro = $(".pIntro"),
                    this.bMore = $(".bMore"),
                    this.pDisplay = $(".pDisplay"),
                    this.bBack = $(".bBack"),
                    this.bgAudioMp3 = $("#bg-audio-mp3"),
                    this.deviceId,
                    this.supportVideo = !0,

                    this.app = new o.default, // initThree.js threejs renderer and controls
                        // calling on the threejs renderer to animate

                    this.app.update(),
                    this.threeContainer = $("#threecontainer"), 
                    this.urlSearch = window.location.search, 
                    this.myvideo = $("#myvideo"),
                    this.onVideoPlaying = this.vidPlaying.bind(this),
                    this.myvideo[0].addEventListener("playing", this.onVideoPlaying, !1), 
                    this.oid = this.getQueryString("oid") || "1",
                    this.urlMap = {
                        1: "http://news.sina.com.cn/c/2012-05-28/010024488046.shtml",
                        2: "http://news.sina.com.cn/c/2012-05-28/010024488046.shtml"
                    }, this.handleSafariCheck(),
                    //this.getWindowSize(),
                    this.loadController(),
                    this.checkCamera(), 
                    this.eventController(),
                    this.isAndroid && (this.resizeCallback = this.onResize.bind(this), 
                    window.addEventListener("resize", this.resizeCallback, !1))
                }
                return r(t, [{
                    key: "vidPlaying",
                    value: function () {
                        this.myvideo[0].pause()
                    }
                }, {
                    key: "onResize",
                    value: function () {
                        console.log("window height = " + window.innerHeight),
                            this.video.style.height = window.innerHeight + "px"
                    }
                }, {
                    key: "clickHandler",
                    value: function (arg) {
                        let ken = this;
                        // clickHandler function must be defined before
                        // being called in for loop below
                            return function() {
                                ken.chosenOption = arg; //更新全局变量
                                console.log("chapter " + arg + " chosen " + ken.chosenOption);
                                ken.pSelect.hide();
                                ken.optionLoader();
                            };
                    }
                }, {
                    key: "selectController",
                    value: function () {
                        let ken = this;
                        <!--Initialize Chapters as Buttons-->
                        for (var a = 0; a < 10; a++) {
                            var b = $(".slide" + a);
                            b.on("click", ken.clickHandler(a));
                        }
                    }
                }, {
                        key: "optionLoader",
                        value: function () {
                            console.log("optionLoader called" + this.chosenOption);
                            var ken = this,
                                contentBox = $(".contentBox"),
                                demoVid = "resources/" + this.chosenOption + ".mp4";

                            contentBox.show();
                            this.openCamera();
                            this.pLoadVid.show();
                            this.assignContent();

                            this.preloadOption.on("complete", function () {
                                console.log("optionLoader completed");
                                ken.pLoadVid.hide();
                                ken.pScanning.show();
                                ken.beginAR();
                            });

                                this.preloadOption.loadManifest([
                                    {src: demoVid },
                                    {src: " "}
                                ]);
                        }
            }, {
                    key: "loadController",
                    value: function () {
                        var ken = this,
                            pSelect = $(".pSelect"),
                            pLoading = $("#pLoading"),
                            progressBar = $("#progress"),
                            contentBox = $(".contentBox"),
                            demoIntro = "img/1.jpg";
                            // demoVid = "resources/1.mp4";

                        // without select function, uncomment below
                        // this.chosenOption = 1;
                        // // inserting html and src of video, intro content, intro button according to chosen chapter
                        // this.assignContent(),

                        this.preload.installPlugin(createjs.Sound),

                        this.preload.on("complete", function () {
                            setTimeout(function () {
                                pLoading.hide(); // hide preload bar on preloading complete

                                // without select function, uncomment below
                                // contentBox.show();

                                // with select function, uncomment below
                                pSelect.show(); // show main container that contains all the content
                                ken.selectController();
                            }, 200)
                        }, this);
                        
                        this.preload.on("progress", function () { // update progress of preloading
                            var e = Math.floor(100 * this.preload.progress);
                            $("div", progressBar).css("width", e + "%")
                        }, this);

                        this.preload.loadManifest([ // list of items in the manifest that needs to be preloaded
                            { src: "img/scan.gif" },
                            { src: "img/btn_ar.png" },
                            { src: "img/btn_ready.png" },
                            { src: "img/btn_more.png" },
                            { src: "img/renyu-poster.png" },
                            { src: "img/btn_back.png" },
                            { src: "img/text.png"},
                            { src: "img/openanim-landscape2.jpg" },
                            { src: "resources/ch1.png" },
                            { src: "resources/ch2.png" },
                            { src: "resources/ch3.png" },
                            { src: "resources/ch4.png" },
                            { src: "resources/ch5.png" },
                            { src: "resources/ch6.png" },
                            { src: "resources/ch7.png" },
                            { src: "resources/ch8.png" },
                            { src: "resources/ch9.png" },
                            { src: "resources/selectChapter.png" },
                            { src: "resources/renyu-bg-mp3.mp3"},
                            { src: demoIntro }  // video of chosen chapter
                            // { src: demoVid } // intro of chosen chapter
                        ])
                    }
                }, {
                    key: "checkCamera",
                    value: function () {
                        var t = this,
                            n = this;
                        this.initAR.listCamera().then(function (e) { // call listcamera function from EasyAR module 4
                            n.isAndroid ? n.deviceId = e[e.length - 1].deviceId : n.isIphone && (n.deviceId = e[0].deviceId) // choose camera accordingly when iPhone and Android
                        }).catch(function (e) {
                            t.fail()
                        })
                    }
                }, {
                    key: "handleSafariCheck",
                    value: function () {
                        this.isSafari && this.isIphone ? this.resizeSafariBrowser() : console.log("this is not safari browser");
                    }
                }, {
                    key: "resizeSafariBrowser",
                    value: function () {
                        document.getElementById("scanTip").style.top = "2%",
                            document.getElementById("scanTop").style.height = "8%",
                            document.getElementById("scanBody").style.top = "8%",
                            document.getElementById("bReady").style.top = "66%",
                            document.getElementById("posterPic").style.top = "8%",
                            document.getElementById("bMore").style.top = "66%",
                            document.getElementById("bg-audio-mp3").removeAttribute("src"),
                            document.ontouchmove = function (event) {
                                event.preventDefault();
                            }
                    }
                }, {
                    key: "getWindowSize",
                    value: function () {
                        var t = $(window).height(),
                            n = $(window).width(),
                            o = $(window).outerHeight();
                        alert("windowHeight: " + t + " windowWidth: " + n + " windowOuterHeight " + o);
                    }
                }, {
                   key: "beginAR",
                   value: function () {
                       var n = this;
                       if (n.pStartAR.hide(), n.supportVideo) { // support video is default !0 true, unless set by "fail" function to be !1 false
                           n.myvideo[0].play(),
                               // n.openCamera(),
                               n.pScanning.show();
                       }
                       else { // if camera feed not supported, bypass scanning page and display demo video directly
                           n.pDisplay.show(),
                               $("#video").hide();
                           var e = .16 * window.innerHeight,
                               t = .6 * window.innerHeight;
                           n.app.getVideo().show(e, t), // returns the video material
                               n.startARDisplay() // show demo video display
                       }
                   }
                }, {
                    key: "eventController", // event that start displaying the camera feed
                    value: function () {
                        var n = this;
                        console.log(this.chosenOption);

                        this.bStartAR.on("click", function () {
                            if (n.pStartAR.hide(), n.supportVideo) { // support video is default !0 true, unless set by "fail" function to be !1 false
                                n.myvideo[0].play(),
                                    n.openCamera(),
                                    n.pScanning.show();
                            }
                            else { // if camera feed not supported, bypass scanning page and display demo video directly
                                n.pDisplay.show(),
                                    $("#video").hide();
                                var e = .16 * window.innerHeight,
                                    t = .6 * window.innerHeight;
                                n.app.getVideo().show(e, t), // returns the video material
                                    n.startARDisplay() // show demo video display
                            }
                        }), this.bReady.on("click", function () { // when button on scanning page is clicked
                            var e = $(".scanBody").offset().top,
                                t = $(".scanBody").height();

                            n.startARDisplay() // show demo video display

                            window.setTimeout(function () { // wait for two seconds
                                n.posterBox.hide(),
                                n.myvideo[0].play(),
                                n.app.getVideo().show(e, t) // return the video material into the height of the scanning border and offset from the top
                            }, 1000)

                            window.setTimeout(function () { // wait for two seconds
                                n.bMore.show()
                            }, 5000)

                        }), this.bMore.on("click", function () {
                            n.pDisplay.hide(),
                            n.pIntro.show(),
                            n.app.getVideo().hide(),
                            $("html").addClass("introPage"),
                            n.myvideo[0].pause(),
                            n.myvideo[0].currentTime = 0,
                            n.bgAudioMp3[0].play()

                        }), this.bBack.on("click", function () {
                            if (n.supportVideo) {
                                n.pDisplay.hide(),
                                n.pIntro.hide(),
                                $("html").removeClass("introPage"),
                                n.pScanning.show();
                            }
                            else {
                                n.pIntro.hide();
                                var e = .16 * window.innerHeight,
                                    t = .6 * window.innerHeight;
                                n.app.getVideo().show(e, t), n.startARDisplay()
                            }
                        })
                    }
                }, {
                    key: "assignContent",
                    value: function () {
                        $("#myvideo").html('<source src="resources/' + this.chosenOption + '.mp4"/>'),
                        $(".pIntro .content").html('<img src="img/1.jpg"/>')
                    }
                }, {
                    key: "fail",
                    value: function () {
                        2 <= this.iosversion.length && (this.iosversion = 11 <= this.iosversion[1]),
                        this.isIphone && this.isWeChat && this.iosversion ? $(".ioswxPanel").show() : this.supportVideo = !1
                    }
                }, {
                    key: "startARDisplay", // to display video and hide scanning gif
                    value: function () {
                        //this.bMore.show(),
                        this.bMore.hide(),
                        this.pScanning.hide(),
                        this.posterBox.show(),
                        this.pDisplay.show(),
                        $("html").removeClass("introPage"),
                        this.myvideo[0].removeEventListener("playing", this.onVideoPlaying),
                        this.pDisplay.css("background", "none"),
                        console.log("started lf app!")
                    }
                }, {
                    key: "openCamera",
                    value: function () {
                        console.log(this.deviceId),
                        this.initAR.openCamera(this.video, this.deviceId).then(function (e) {
                            video.setAttribute("height", window.innerHeight.toString() + "px")
                        }).catch(function (e) {
                            alert("打开视频设备失败")
                        })
                    }
                }, {
                    key: "getQueryString",
                    value: function (e) {
                        var t = new RegExp("(^|&)" + e + "=([^&]*)(&|$)", "i"),
                            n = window.location.search.substr(1).match(t);
                        return null != n ? unescape(n[2]) : null
                    }
                }]), t
            }())
        }, {
            "../libs/three.module.js": 6,
            "./initThree.js": 1,
            "./initAR": 4
        }],
       //  initvidplane module
        3: [function (e, t, n) {
            "use strict";
            Object.defineProperty(n, "__esModule", {
                value: !0
            });

            var r, i = function () {
                function r(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }
                return function (e, t, n) {
                    return t && r(e.prototype, t), n && r(e, n), e
                }
            }(),
                o = e("../libs/jquery-3.3.1.js"),
                a = (r = o) && r.__esModule ? r : {
                    default: r
                },
                s = function (e) {
                    {
                        if (e && e.__esModule) return e;
                        var t = {};
                        if (null != e)
                            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                        return t.default = e, t
                    }
                }(e("../libs/three.module.js"));

            var initvidplane = function () {
                function n(e, t) {
                    ! function (e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, n),
                    this.width = 512,
                    this.height = 201,
                    this.scale = 368 / this.width,

                    this.camera = e,
                    this.scene = t,

                    this.video = (0, a.default)("#myvideo")[0], // demo display video
                    this.texture = new s.VideoTexture(this.video, s.UVMapping, s.ClampToEdgeWrapping, s.ClampToEdgeWrapping, s.LinearFilter, s.LinearFilter, s.RGBFormat, s.UnsignedByteType),

                    this.material = new s.MeshBasicMaterial({
                        map: this.texture,
                        overdraw: .5
                    }),
                    this.plane = new s.PlaneGeometry(this.width, this.height, 4, 4),
                    this.mesh = new s.Mesh(this.plane, this.material),
                    this.mesh.scale.x = this.scale
                }
                return i(n, [{
                    key: "show",
                    value: function (e, t) {
                        var n = this.height * (.5 * window.innerHeight - (e + .5 * t)) / t,
                            r = -this.height * window.innerHeight / (2 * t * Math.tan(s.Math.degToRad(.5 * this.camera.fov)));
                        this.mesh.position.set(0, n, r),
                        this.camera.updateMatrixWorld(!0),
                        this.camera.localToWorld(this.mesh.position),
                        this.camera.getWorldQuaternion(this.mesh.quaternion),
                        this.scene.add(this.mesh)
                    }
                }, {
                    key: "hide",
                    value: function () {
                        this.scene.remove(this.mesh)
                    }
                }]), n
            }();
            n.default = initvidplane
        }, {
            "../libs/jquery-3.3.1.js": 5,
            "../libs/three.module.js": 6
        }],
       // initAR module
        4: [function (e, t, n) {
            "use strict";
            Object.defineProperty(n, "__esModule", {
                value: !0
            });
            n.default = function initAR(e, r) {
                e = e || 1e3, r = r || "";
                var i = {
                    width: 320,
                    height: 240
                },
                    o = null,
                    a = null,
                    s = null,
                    c = null,
                    l = !1;
                this.unSupport = void 0,
                    this.devices = [];
                var t = document.createElement("div");
                t.setAttribute("id", "debug"),
                    t.setAttribute("width", (window.innerWidth / 2).toString()),
                    t.setAttribute("height", window.innerHeight.toString()),
                    document.body.appendChild(t),

                    this.listCamera = function () {
                    var r = this;
                    return new Promise(function (t, n) {
                        navigator.mediaDevices.enumerateDevices().then(function (e) {
                            console.log(e),
                                e.find(function (e) {
                                if ("videoinput" === e.kind) {
                                    console.log(e);
                                    var t = {};
                                    t.name = e.label || "camera",
                                        t.deviceId = e.deviceId,
                                        r.devices.push(t)
                                }
                            }), 0 === r.devices.length ? n("没有摄像头") : (a = document.createElement("canvas"),
                                s = a.getContext("2d"),
                                t(r.devices))
                        }).catch(function (e) {
                            n(e)
                        })
                    })
                }, this.openCamera = function (e, t, n) {
                    o = e,
                    n && (i = n);
                    var r = {
                        audio: !1,
                        video: {
                            deviceId: {
                                exact: t
                            }
                        }
                    };
                    return a.setAttribute("width", i.width + "px"),
                        a.setAttribute("height", i.height + "px"),
                        o.srcObject && o.srcObject.getTracks().forEach(function (e) {
                        e.stop()
                    }), new Promise(function (t, n) {
                        navigator.mediaDevices.getUserMedia(r).then(function (e) {
                            o.srcObject = e,
                            o.style.display = "block",
                            o.play(), t(!0)
                        }).catch(function (e) {
                            n(e)
                        })
                    })
                }, this.captureVideo = function () {
                    return s.drawImage(o, 0, 0, i.width, i.height), a.toDataURL("image/jpeg", .5).split("base64,")[1]
                }, this.startRecognize = function (t) {
                    var n = this;
                    c = window.setInterval(function () {
                        if (!l) {
                            l = !0;
                            var e = {
                                image: n.captureVideo()
                            };
                            n.httpPost(r, e).then(function (e) {
                                n.stopRecognize(), t(e)
                            }).catch(function (e) {
                                l = !1, n.trace(e)
                            })
                        }
                    }, e)
                }, this.stopRecognize = function () {
                    c && (window.clearInterval(c), l = !1)
                }, this.httpPost = function (e, i) {
                    return new Promise(function (t, n) {
                        var r = new XMLHttpRequest;
                        r.onload = function () {
                            try {
                                var e = JSON.parse(r.responseText);
                                200 === r.status && 0 === e.statusCode ? t(e.result) : n(e)
                            } catch (e) {
                                n(e)
                            }
                        }, r.onerror = function (e) {
                            n(e)
                        }, r.open("POST", e), r.setRequestHeader("Content-Type", "application/json;Charset=UTF-8"), r.send(JSON.stringify(i))
                    })
                }, this.trace = function (e) {
                    t.innerHTML += "string" == typeof e ? e : JSON.stringify(e), t.innerHTML += "<br />"
                }
            }
        }, {}],
       // jQuery-3.3.1 module
        5: [function (e, t, n) {
            "use strict";
            var r, i, Xt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            };
            r = "undefined" != typeof window ? window : void 0, i = function (E, e) {
                var t = [],
                    T = E.document,
                    r = Object.getPrototypeOf,
                    s = t.slice,
                    m = t.concat,
                    c = t.push,
                    i = t.indexOf,
                    n = {},
                    o = n.toString,
                    g = n.hasOwnProperty,
                    a = g.toString,
                    l = a.call(Object),
                    v = {},
                    y = function (e) {
                        return "function" == typeof e && "number" != typeof e.nodeType
                    },
                    _ = function (e) {
                        return null != e && e === e.window
                    },
                    u = {
                        type: !0,
                        src: !0,
                        noModule: !0
                    };

                function x(e, t, n) {
                    var r, i = (t = t || T).createElement("script");
                    if (i.text = e, n)
                        for (r in u) n[r] && (i[r] = n[r]);
                    t.head.appendChild(i).parentNode.removeChild(i)
                }

                function b(e) {
                    return null == e ? e + "" : "object" === (void 0 === e ? "undefined" : Xt(e)) || "function" == typeof e ? n[o.call(e)] || "object" : void 0 === e ? "undefined" : Xt(e)
                }
                var S = function e(t, n) {
                    return new e.fn.init(t, n)
                },
                    h = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

                function d(e) {
                    var t = !!e && "length" in e && e.length,
                        n = b(e);
                    return !y(e) && !_(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
                }
                S.fn = S.prototype = {
                    jquery: "3.3.1",
                    constructor: S,
                    length: 0,
                    toArray: function () {
                        return s.call(this)
                    },
                    get: function (e) {
                        return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]
                    },
                    pushStack: function (e) {
                        var t = S.merge(this.constructor(), e);
                        return t.prevObject = this, t
                    },
                    each: function (e) {
                        return S.each(this, e)
                    },
                    map: function (n) {
                        return this.pushStack(S.map(this, function (e, t) {
                            return n.call(e, t, e)
                        }))
                    },
                    slice: function () {
                        return this.pushStack(s.apply(this, arguments))
                    },
                    first: function () {
                        return this.eq(0)
                    },
                    last: function () {
                        return this.eq(-1)
                    },
                    eq: function (e) {
                        var t = this.length,
                            n = +e + (e < 0 ? t : 0);
                        return this.pushStack(0 <= n && n < t ? [this[n]] : [])
                    },
                    end: function () {
                        return this.prevObject || this.constructor()
                    },
                    push: c,
                    sort: t.sort,
                    splice: t.splice
                }, S.extend = S.fn.extend = function () {
                    var e, t, n, r, i, o, a = arguments[0] || {},
                        s = 1,
                        c = arguments.length,
                        l = !1;
                    for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" === (void 0 === a ? "undefined" : Xt(a)) || y(a) || (a = {}), s === c && (a = this, s--); s < c; s++)
                        if (null != (e = arguments[s]))
                            for (t in e) n = a[t], a !== (r = e[t]) && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && S.isPlainObject(n) ? n : {}, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r));
                    return a
                }, S.extend({
                    expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""),
                    isReady: !0,
                    error: function (e) {
                        throw new Error(e)
                    },
                    noop: function () { },
                    isPlainObject: function (e) {
                        var t, n;
                        return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = g.call(t, "constructor") && t.constructor) && a.call(n) === l)
                    },
                    isEmptyObject: function (e) {
                        var t;
                        for (t in e) return !1;
                        return !0
                    },
                    globalEval: function (e) {
                        x(e)
                    },
                    each: function (e, t) {
                        var n, r = 0;
                        if (d(e))
                            for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++);
                        else
                            for (r in e)
                                if (!1 === t.call(e[r], r, e[r])) break;
                        return e
                    },
                    trim: function (e) {
                        return null == e ? "" : (e + "").replace(h, "")
                    },
                    makeArray: function (e, t) {
                        var n = t || [];
                        return null != e && (d(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : c.call(n, e)), n
                    },
                    inArray: function (e, t, n) {
                        return null == t ? -1 : i.call(t, e, n)
                    },
                    merge: function (e, t) {
                        for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
                        return e.length = i, e
                    },
                    grep: function (e, t, n) {
                        for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);
                        return r
                    },
                    map: function (e, t, n) {
                        var r, i, o = 0,
                            a = [];
                        if (d(e))
                            for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && a.push(i);
                        else
                            for (o in e) null != (i = t(e[o], o, n)) && a.push(i);
                        return m.apply([], a)
                    },
                    guid: 1,
                    support: v
                }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
                    n["[object " + t + "]"] = t.toLowerCase()
                });
                var p = function (n) {
                    var e, p, x, o, i, f, h, m, b, c, l, w, E, a, T, g, s, u, v, S = "sizzle" + 1 * new Date,
                        y = n.document,
                        M = 0,
                        r = 0,
                        d = ae(),
                        _ = ae(),
                        A = ae(),
                        C = function (e, t) {
                            return e === t && (l = !0), 0
                        },
                        L = {}.hasOwnProperty,
                        t = [],
                        R = t.pop,
                        P = t.push,
                        O = t.push,
                        I = t.slice,
                        D = function (e, t) {
                            for (var n = 0, r = e.length; n < r; n++)
                                if (e[n] === t) return n;
                            return -1
                        },
                        j = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                        N = "[\\x20\\t\\r\\n\\f]",
                        k = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
                        U = "\\[" + N + "*(" + k + ")(?:" + N + "*([*^$|!~]?=)" + N + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + k + "))|)" + N + "*\\]",
                        H = ":(" + k + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + U + ")*)|.*)\\)|)",
                        B = new RegExp(N + "+", "g"),
                        F = new RegExp("^" + N + "+|((?:^|[^\\\\])(?:\\\\.)*)" + N + "+$", "g"),
                        z = new RegExp("^" + N + "*," + N + "*"),
                        G = new RegExp("^" + N + "*([>+~]|" + N + ")" + N + "*"),
                        V = new RegExp("=" + N + "*([^\\]'\"]*?)" + N + "*\\]", "g"),
                        q = new RegExp(H),
                        W = new RegExp("^" + k + "$"),
                        X = {
                            ID: new RegExp("^#(" + k + ")"),
                            CLASS: new RegExp("^\\.(" + k + ")"),
                            TAG: new RegExp("^(" + k + "|[*])"),
                            ATTR: new RegExp("^" + U),
                            PSEUDO: new RegExp("^" + H),
                            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + N + "*(even|odd|(([+-]|)(\\d*)n|)" + N + "*(?:([+-]|)" + N + "*(\\d+)|))" + N + "*\\)|)", "i"),
                            bool: new RegExp("^(?:" + j + ")$", "i"),
                            needsContext: new RegExp("^" + N + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + N + "*((?:-\\d)?\\d*)" + N + "*\\)|)(?=[^-]|$)", "i")
                        },
                        Y = /^(?:input|select|textarea|button)$/i,
                        J = /^h\d$/i,
                        Z = /^[^{]+\{\s*\[native \w/,
                        $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                        Q = /[+~]/,
                        K = new RegExp("\\\\([\\da-f]{1,6}" + N + "?|(" + N + ")|.)", "ig"),
                        ee = function (e, t, n) {
                            var r = "0x" + t - 65536;
                            return r != r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
                        },
                        te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                        ne = function (e, t) {
                            return t ? "\0" === e ? "�" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
                        },
                        re = function () {
                            w()
                        },
                        ie = ye(function (e) {
                            return !0 === e.disabled && ("form" in e || "label" in e)
                        }, {
                                dir: "parentNode",
                                next: "legend"
                            });
                    try {
                        O.apply(t = I.call(y.childNodes), y.childNodes), t[y.childNodes.length].nodeType
                    } catch (e) {
                        O = {
                            apply: t.length ? function (e, t) {
                                P.apply(e, I.call(t))
                            } : function (e, t) {
                                for (var n = e.length, r = 0; e[n++] = t[r++];);
                                e.length = n - 1
                            }
                        }
                    }

                    function oe(e, t, n, r) {
                        var i, o, a, s, c, l, u, h = t && t.ownerDocument,
                            d = t ? t.nodeType : 9;
                        if (n = n || [], "string" != typeof e || !e || 1 !== d && 9 !== d && 11 !== d) return n;
                        if (!r && ((t ? t.ownerDocument || t : y) !== E && w(t), t = t || E, T)) {
                            if (11 !== d && (c = $.exec(e)))
                                if (i = c[1]) {
                                    if (9 === d) {
                                        if (!(a = t.getElementById(i))) return n;
                                        if (a.id === i) return n.push(a), n
                                    } else if (h && (a = h.getElementById(i)) && v(t, a) && a.id === i) return n.push(a), n
                                } else {
                                    if (c[2]) return O.apply(n, t.getElementsByTagName(e)), n;
                                    if ((i = c[3]) && p.getElementsByClassName && t.getElementsByClassName) return O.apply(n, t.getElementsByClassName(i)), n
                                }
                            if (p.qsa && !A[e + " "] && (!g || !g.test(e))) {
                                if (1 !== d) h = t, u = e;
                                else if ("object" !== t.nodeName.toLowerCase()) {
                                    for ((s = t.getAttribute("id")) ? s = s.replace(te, ne) : t.setAttribute("id", s = S), o = (l = f(e)).length; o--;) l[o] = "#" + s + " " + ve(l[o]);
                                    u = l.join(","), h = Q.test(e) && me(t.parentNode) || t
                                }
                                if (u) try {
                                    return O.apply(n, h.querySelectorAll(u)), n
                                } catch (e) { } finally {
                                        s === S && t.removeAttribute("id")
                                    }
                            }
                        }
                        return m(e.replace(F, "$1"), t, n, r)
                    }

                    function ae() {
                        var r = [];
                        return function e(t, n) {
                            return r.push(t + " ") > x.cacheLength && delete e[r.shift()], e[t + " "] = n
                        }
                    }

                    function se(e) {
                        return e[S] = !0, e
                    }

                    function ce(e) {
                        var t = E.createElement("fieldset");
                        try {
                            return !!e(t)
                        } catch (e) {
                            return !1
                        } finally {
                            t.parentNode && t.parentNode.removeChild(t), t = null
                        }
                    }

                    function le(e, t) {
                        for (var n = e.split("|"), r = n.length; r--;) x.attrHandle[n[r]] = t
                    }

                    function ue(e, t) {
                        var n = t && e,
                            r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
                        if (r) return r;
                        if (n)
                            for (; n = n.nextSibling;)
                                if (n === t) return -1;
                        return e ? 1 : -1
                    }

                    function he(t) {
                        return function (e) {
                            return "input" === e.nodeName.toLowerCase() && e.type === t
                        }
                    }

                    function de(n) {
                        return function (e) {
                            var t = e.nodeName.toLowerCase();
                            return ("input" === t || "button" === t) && e.type === n
                        }
                    }

                    function pe(t) {
                        return function (e) {
                            return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ie(e) === t : e.disabled === t : "label" in e && e.disabled === t
                        }
                    }

                    function fe(a) {
                        return se(function (o) {
                            return o = +o, se(function (e, t) {
                                for (var n, r = a([], e.length, o), i = r.length; i--;) e[n = r[i]] && (e[n] = !(t[n] = e[n]))
                            })
                        })
                    }

                    function me(e) {
                        return e && void 0 !== e.getElementsByTagName && e
                    }
                    for (e in p = oe.support = {}, i = oe.isXML = function (e) {
                        var t = e && (e.ownerDocument || e).documentElement;
                        return !!t && "HTML" !== t.nodeName
                    }, w = oe.setDocument = function (e) {
                        var t, n, r = e ? e.ownerDocument || e : y;
                        return r !== E && 9 === r.nodeType && r.documentElement && (a = (E = r).documentElement, T = !i(E), y !== E && (n = E.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", re, !1) : n.attachEvent && n.attachEvent("onunload", re)), p.attributes = ce(function (e) {
                            return e.className = "i", !e.getAttribute("className")
                        }), p.getElementsByTagName = ce(function (e) {
                            return e.appendChild(E.createComment("")), !e.getElementsByTagName("*").length
                        }), p.getElementsByClassName = Z.test(E.getElementsByClassName), p.getById = ce(function (e) {
                            return a.appendChild(e).id = S, !E.getElementsByName || !E.getElementsByName(S).length
                        }), p.getById ? (x.filter.ID = function (e) {
                            var t = e.replace(K, ee);
                            return function (e) {
                                return e.getAttribute("id") === t
                            }
                        }, x.find.ID = function (e, t) {
                            if (void 0 !== t.getElementById && T) {
                                var n = t.getElementById(e);
                                return n ? [n] : []
                            }
                        }) : (x.filter.ID = function (e) {
                            var n = e.replace(K, ee);
                            return function (e) {
                                var t = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                                return t && t.value === n
                            }
                        }, x.find.ID = function (e, t) {
                            if (void 0 !== t.getElementById && T) {
                                var n, r, i, o = t.getElementById(e);
                                if (o) {
                                    if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                                    for (i = t.getElementsByName(e), r = 0; o = i[r++];)
                                        if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                                }
                                return []
                            }
                        }), x.find.TAG = p.getElementsByTagName ? function (e, t) {
                            return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : p.qsa ? t.querySelectorAll(e) : void 0
                        } : function (e, t) {
                            var n, r = [],
                                i = 0,
                                o = t.getElementsByTagName(e);
                            if ("*" === e) {
                                for (; n = o[i++];) 1 === n.nodeType && r.push(n);
                                return r
                            }
                            return o
                        }, x.find.CLASS = p.getElementsByClassName && function (e, t) {
                            if (void 0 !== t.getElementsByClassName && T) return t.getElementsByClassName(e)
                        }, s = [], g = [], (p.qsa = Z.test(E.querySelectorAll)) && (ce(function (e) {
                            a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + N + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || g.push("\\[" + N + "*(?:value|" + j + ")"), e.querySelectorAll("[id~=" + S + "-]").length || g.push("~="), e.querySelectorAll(":checked").length || g.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || g.push(".#.+[+~]")
                        }), ce(function (e) {
                            e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                            var t = E.createElement("input");
                            t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && g.push("name" + N + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:")
                        })), (p.matchesSelector = Z.test(u = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) {
                            p.disconnectedMatch = u.call(e, "*"), u.call(e, "[s!='']:x"), s.push("!=", H)
                        }), g = g.length && new RegExp(g.join("|")), s = s.length && new RegExp(s.join("|")), t = Z.test(a.compareDocumentPosition), v = t || Z.test(a.contains) ? function (e, t) {
                            var n = 9 === e.nodeType ? e.documentElement : e,
                                r = t && t.parentNode;
                            return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
                        } : function (e, t) {
                            if (t)
                                for (; t = t.parentNode;)
                                    if (t === e) return !0;
                            return !1
                        }, C = t ? function (e, t) {
                            if (e === t) return l = !0, 0;
                            var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                            return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !p.sortDetached && t.compareDocumentPosition(e) === n ? e === E || e.ownerDocument === y && v(y, e) ? -1 : t === E || t.ownerDocument === y && v(y, t) ? 1 : c ? D(c, e) - D(c, t) : 0 : 4 & n ? -1 : 1)
                        } : function (e, t) {
                            if (e === t) return l = !0, 0;
                            var n, r = 0,
                                i = e.parentNode,
                                o = t.parentNode,
                                a = [e],
                                s = [t];
                            if (!i || !o) return e === E ? -1 : t === E ? 1 : i ? -1 : o ? 1 : c ? D(c, e) - D(c, t) : 0;
                            if (i === o) return ue(e, t);
                            for (n = e; n = n.parentNode;) a.unshift(n);
                            for (n = t; n = n.parentNode;) s.unshift(n);
                            for (; a[r] === s[r];) r++;
                            return r ? ue(a[r], s[r]) : a[r] === y ? -1 : s[r] === y ? 1 : 0
                        }), E
                    }, oe.matches = function (e, t) {
                        return oe(e, null, null, t)
                    }, oe.matchesSelector = function (e, t) {
                        if ((e.ownerDocument || e) !== E && w(e), t = t.replace(V, "='$1']"), p.matchesSelector && T && !A[t + " "] && (!s || !s.test(t)) && (!g || !g.test(t))) try {
                            var n = u.call(e, t);
                            if (n || p.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n
                        } catch (e) { }
                        return 0 < oe(t, E, null, [e]).length
                    }, oe.contains = function (e, t) {
                        return (e.ownerDocument || e) !== E && w(e), v(e, t)
                    }, oe.attr = function (e, t) {
                        (e.ownerDocument || e) !== E && w(e);
                        var n = x.attrHandle[t.toLowerCase()],
                            r = n && L.call(x.attrHandle, t.toLowerCase()) ? n(e, t, !T) : void 0;
                        return void 0 !== r ? r : p.attributes || !T ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
                    }, oe.escape = function (e) {
                        return (e + "").replace(te, ne)
                    }, oe.error = function (e) {
                        throw new Error("Syntax error, unrecognized expression: " + e)
                    }, oe.uniqueSort = function (e) {
                        var t, n = [],
                            r = 0,
                            i = 0;
                        if (l = !p.detectDuplicates, c = !p.sortStable && e.slice(0), e.sort(C), l) {
                            for (; t = e[i++];) t === e[i] && (r = n.push(i));
                            for (; r--;) e.splice(n[r], 1)
                        }
                        return c = null, e
                    }, o = oe.getText = function (e) {
                        var t, n = "",
                            r = 0,
                            i = e.nodeType;
                        if (i) {
                            if (1 === i || 9 === i || 11 === i) {
                                if ("string" == typeof e.textContent) return e.textContent;
                                for (e = e.firstChild; e; e = e.nextSibling) n += o(e)
                            } else if (3 === i || 4 === i) return e.nodeValue
                        } else
                            for (; t = e[r++];) n += o(t);
                        return n
                    }, (x = oe.selectors = {
                        cacheLength: 50,
                        createPseudo: se,
                        match: X,
                        attrHandle: {},
                        find: {},
                        relative: {
                            ">": {
                                dir: "parentNode",
                                first: !0
                            },
                            " ": {
                                dir: "parentNode"
                            },
                            "+": {
                                dir: "previousSibling",
                                first: !0
                            },
                            "~": {
                                dir: "previousSibling"
                            }
                        },
                        preFilter: {
                            ATTR: function (e) {
                                return e[1] = e[1].replace(K, ee), e[3] = (e[3] || e[4] || e[5] || "").replace(K, ee), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                            },
                            CHILD: function (e) {
                                return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || oe.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && oe.error(e[0]), e
                            },
                            PSEUDO: function (e) {
                                var t, n = !e[6] && e[2];
                                return X.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && q.test(n) && (t = f(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                            }
                        },
                        filter: {
                            TAG: function (e) {
                                var t = e.replace(K, ee).toLowerCase();
                                return "*" === e ? function () {
                                    return !0
                                } : function (e) {
                                    return e.nodeName && e.nodeName.toLowerCase() === t
                                }
                            },
                            CLASS: function (e) {
                                var t = d[e + " "];
                                return t || (t = new RegExp("(^|" + N + ")" + e + "(" + N + "|$)")) && d(e, function (e) {
                                    return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                                })
                            },
                            ATTR: function (n, r, i) {
                                return function (e) {
                                    var t = oe.attr(e, n);
                                    return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"))
                                }
                            },
                            CHILD: function (f, e, t, m, g) {
                                var v = "nth" !== f.slice(0, 3),
                                    y = "last" !== f.slice(-4),
                                    _ = "of-type" === e;
                                return 1 === m && 0 === g ? function (e) {
                                    return !!e.parentNode
                                } : function (e, t, n) {
                                    var r, i, o, a, s, c, l = v !== y ? "nextSibling" : "previousSibling",
                                        u = e.parentNode,
                                        h = _ && e.nodeName.toLowerCase(),
                                        d = !n && !_,
                                        p = !1;
                                    if (u) {
                                        if (v) {
                                            for (; l;) {
                                                for (a = e; a = a[l];)
                                                    if (_ ? a.nodeName.toLowerCase() === h : 1 === a.nodeType) return !1;
                                                c = l = "only" === f && !c && "nextSibling"
                                            }
                                            return !0
                                        }
                                        if (c = [y ? u.firstChild : u.lastChild], y && d) {
                                            for (p = (s = (r = (i = (o = (a = u)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[f] || [])[0] === M && r[1]) && r[2], a = s && u.childNodes[s]; a = ++s && a && a[l] || (p = s = 0) || c.pop();)
                                                if (1 === a.nodeType && ++p && a === e) {
                                                    i[f] = [M, s, p];
                                                    break
                                                }
                                        } else if (d && (p = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[f] || [])[0] === M && r[1]), !1 === p)
                                            for (;
                                                (a = ++s && a && a[l] || (p = s = 0) || c.pop()) && ((_ ? a.nodeName.toLowerCase() !== h : 1 !== a.nodeType) || !++p || (d && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[f] = [M, p]), a !== e)););
                                        return (p -= g) === m || p % m == 0 && 0 <= p / m
                                    }
                                }
                            },
                            PSEUDO: function (e, o) {
                                var t, a = x.pseudos[e] || x.setFilters[e.toLowerCase()] || oe.error("unsupported pseudo: " + e);
                                return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], x.setFilters.hasOwnProperty(e.toLowerCase()) ? se(function (e, t) {
                                    for (var n, r = a(e, o), i = r.length; i--;) e[n = D(e, r[i])] = !(t[n] = r[i])
                                }) : function (e) {
                                    return a(e, 0, t)
                                }) : a
                            }
                        },
                        pseudos: {
                            not: se(function (e) {
                                var r = [],
                                    i = [],
                                    s = h(e.replace(F, "$1"));
                                return s[S] ? se(function (e, t, n, r) {
                                    for (var i, o = s(e, null, r, []), a = e.length; a--;)(i = o[a]) && (e[a] = !(t[a] = i))
                                }) : function (e, t, n) {
                                    return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop()
                                }
                            }),
                            has: se(function (t) {
                                return function (e) {
                                    return 0 < oe(t, e).length
                                }
                            }),
                            contains: se(function (t) {
                                return t = t.replace(K, ee),
                                    function (e) {
                                        return -1 < (e.textContent || e.innerText || o(e)).indexOf(t)
                                    }
                            }),
                            lang: se(function (n) {
                                return W.test(n || "") || oe.error("unsupported lang: " + n), n = n.replace(K, ee).toLowerCase(),
                                    function (e) {
                                        var t;
                                        do {
                                            if (t = T ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-")
                                        } while ((e = e.parentNode) && 1 === e.nodeType);
                                        return !1
                                    }
                            }),
                            target: function (e) {
                                var t = n.location && n.location.hash;
                                return t && t.slice(1) === e.id
                            },
                            root: function (e) {
                                return e === a
                            },
                            focus: function (e) {
                                return e === E.activeElement && (!E.hasFocus || E.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                            },
                            enabled: pe(!1),
                            disabled: pe(!0),
                            checked: function (e) {
                                var t = e.nodeName.toLowerCase();
                                return "input" === t && !!e.checked || "option" === t && !!e.selected
                            },
                            selected: function (e) {
                                return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                            },
                            empty: function (e) {
                                for (e = e.firstChild; e; e = e.nextSibling)
                                    if (e.nodeType < 6) return !1;
                                return !0
                            },
                            parent: function (e) {
                                return !x.pseudos.empty(e)
                            },
                            header: function (e) {
                                return J.test(e.nodeName)
                            },
                            input: function (e) {
                                return Y.test(e.nodeName)
                            },
                            button: function (e) {
                                var t = e.nodeName.toLowerCase();
                                return "input" === t && "button" === e.type || "button" === t
                            },
                            text: function (e) {
                                var t;
                                return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                            },
                            first: fe(function () {
                                return [0]
                            }),
                            last: fe(function (e, t) {
                                return [t - 1]
                            }),
                            eq: fe(function (e, t, n) {
                                return [n < 0 ? n + t : n]
                            }),
                            even: fe(function (e, t) {
                                for (var n = 0; n < t; n += 2) e.push(n);
                                return e
                            }),
                            odd: fe(function (e, t) {
                                for (var n = 1; n < t; n += 2) e.push(n);
                                return e
                            }),
                            lt: fe(function (e, t, n) {
                                for (var r = n < 0 ? n + t : n; 0 <= --r;) e.push(r);
                                return e
                            }),
                            gt: fe(function (e, t, n) {
                                for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);
                                return e
                            })
                        }
                    }).pseudos.nth = x.pseudos.eq, {
                            radio: !0,
                            checkbox: !0,
                            file: !0,
                            password: !0,
                            image: !0
                        }) x.pseudos[e] = he(e);
                    for (e in {
                        submit: !0,
                        reset: !0
                    }) x.pseudos[e] = de(e);

                    function ge() { }

                    function ve(e) {
                        for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
                        return r
                    }

                    function ye(s, e, t) {
                        var c = e.dir,
                            l = e.next,
                            u = l || c,
                            h = t && "parentNode" === u,
                            d = r++;
                        return e.first ? function (e, t, n) {
                            for (; e = e[c];)
                                if (1 === e.nodeType || h) return s(e, t, n);
                            return !1
                        } : function (e, t, n) {
                            var r, i, o, a = [M, d];
                            if (n) {
                                for (; e = e[c];)
                                    if ((1 === e.nodeType || h) && s(e, t, n)) return !0
                            } else
                                for (; e = e[c];)
                                    if (1 === e.nodeType || h)
                                        if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[c] || e;
                                        else {
                                            if ((r = i[u]) && r[0] === M && r[1] === d) return a[2] = r[2];
                                            if ((i[u] = a)[2] = s(e, t, n)) return !0
                                        } return !1
                        }
                    }

                    function _e(i) {
                        return 1 < i.length ? function (e, t, n) {
                            for (var r = i.length; r--;)
                                if (!i[r](e, t, n)) return !1;
                            return !0
                        } : i[0]
                    }

                    function xe(e, t, n, r, i) {
                        for (var o, a = [], s = 0, c = e.length, l = null != t; s < c; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
                        return a
                    }

                    function be(p, f, m, g, v, e) {
                        return g && !g[S] && (g = be(g)), v && !v[S] && (v = be(v, e)), se(function (e, t, n, r) {
                            var i, o, a, s = [],
                                c = [],
                                l = t.length,
                                u = e || function (e, t, n) {
                                    for (var r = 0, i = t.length; r < i; r++) oe(e, t[r], n);
                                    return n
                                }(f || "*", n.nodeType ? [n] : n, []),
                                h = !p || !e && f ? u : xe(u, s, p, n, r),
                                d = m ? v || (e ? p : l || g) ? [] : t : h;
                            if (m && m(h, d, n, r), g)
                                for (i = xe(d, c), g(i, [], n, r), o = i.length; o--;)(a = i[o]) && (d[c[o]] = !(h[c[o]] = a));
                            if (e) {
                                if (v || p) {
                                    if (v) {
                                        for (i = [], o = d.length; o--;)(a = d[o]) && i.push(h[o] = a);
                                        v(null, d = [], i, r)
                                    }
                                    for (o = d.length; o--;)(a = d[o]) && -1 < (i = v ? D(e, a) : s[o]) && (e[i] = !(t[i] = a))
                                }
                            } else d = xe(d === t ? d.splice(l, d.length) : d), v ? v(null, t, d, r) : O.apply(t, d)
                        })
                    }

                    function we(e) {
                        for (var i, t, n, r = e.length, o = x.relative[e[0].type], a = o || x.relative[" "], s = o ? 1 : 0, c = ye(function (e) {
                            return e === i
                        }, a, !0), l = ye(function (e) {
                            return -1 < D(i, e)
                        }, a, !0), u = [function (e, t, n) {
                            var r = !o && (n || t !== b) || ((i = t).nodeType ? c(e, t, n) : l(e, t, n));
                            return i = null, r
                        }]; s < r; s++)
                            if (t = x.relative[e[s].type]) u = [ye(_e(u), t)];
                            else {
                                if ((t = x.filter[e[s].type].apply(null, e[s].matches))[S]) {
                                    for (n = ++s; n < r && !x.relative[e[n].type]; n++);
                                    return be(1 < s && _e(u), 1 < s && ve(e.slice(0, s - 1).concat({
                                        value: " " === e[s - 2].type ? "*" : ""
                                    })).replace(F, "$1"), t, s < n && we(e.slice(s, n)), n < r && we(e = e.slice(n)), n < r && ve(e))
                                }
                                u.push(t)
                            }
                        return _e(u)
                    }
                    return ge.prototype = x.filters = x.pseudos, x.setFilters = new ge, f = oe.tokenize = function (e, t) {
                        var n, r, i, o, a, s, c, l = _[e + " "];
                        if (l) return t ? 0 : l.slice(0);
                        for (a = e, s = [], c = x.preFilter; a;) {
                            for (o in n && !(r = z.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = G.exec(a)) && (n = r.shift(), i.push({
                                value: n,
                                type: r[0].replace(F, " ")
                            }), a = a.slice(n.length)), x.filter) !(r = X[o].exec(a)) || c[o] && !(r = c[o](r)) || (n = r.shift(), i.push({
                                value: n,
                                type: o,
                                matches: r
                            }), a = a.slice(n.length));
                            if (!n) break
                        }
                        return t ? a.length : a ? oe.error(e) : _(e, s).slice(0)
                    }, h = oe.compile = function (e, t) {
                        var n, g, v, y, _, r, i = [],
                            o = [],
                            a = A[e + " "];
                        if (!a) {
                            for (t || (t = f(e)), n = t.length; n--;)(a = we(t[n]))[S] ? i.push(a) : o.push(a);
                            (a = A(e, (g = o, y = 0 < (v = i).length, _ = 0 < g.length, r = function (e, t, n, r, i) {
                                var o, a, s, c = 0,
                                    l = "0",
                                    u = e && [],
                                    h = [],
                                    d = b,
                                    p = e || _ && x.find.TAG("*", i),
                                    f = M += null == d ? 1 : Math.random() || .1,
                                    m = p.length;
                                for (i && (b = t === E || t || i); l !== m && null != (o = p[l]); l++) {
                                    if (_ && o) {
                                        for (a = 0, t || o.ownerDocument === E || (w(o), n = !T); s = g[a++];)
                                            if (s(o, t || E, n)) {
                                                r.push(o);
                                                break
                                            }
                                        i && (M = f)
                                    }
                                    y && ((o = !s && o) && c-- , e && u.push(o))
                                }
                                if (c += l, y && l !== c) {
                                    for (a = 0; s = v[a++];) s(u, h, t, n);
                                    if (e) {
                                        if (0 < c)
                                            for (; l--;) u[l] || h[l] || (h[l] = R.call(r));
                                        h = xe(h)
                                    }
                                    O.apply(r, h), i && !e && 0 < h.length && 1 < c + v.length && oe.uniqueSort(r)
                                }
                                return i && (M = f, b = d), u
                            }, y ? se(r) : r))).selector = e
                        }
                        return a
                    }, m = oe.select = function (e, t, n, r) {
                        var i, o, a, s, c, l = "function" == typeof e && e,
                            u = !r && f(e = l.selector || e);
                        if (n = n || [], 1 === u.length) {
                            if (2 < (o = u[0] = u[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && T && x.relative[o[1].type]) {
                                if (!(t = (x.find.ID(a.matches[0].replace(K, ee), t) || [])[0])) return n;
                                l && (t = t.parentNode), e = e.slice(o.shift().value.length)
                            }
                            for (i = X.needsContext.test(e) ? 0 : o.length; i-- && (a = o[i], !x.relative[s = a.type]);)
                                if ((c = x.find[s]) && (r = c(a.matches[0].replace(K, ee), Q.test(o[0].type) && me(t.parentNode) || t))) {
                                    if (o.splice(i, 1), !(e = r.length && ve(o))) return O.apply(n, r), n;
                                    break
                                }
                        }
                        return (l || h(e, u))(r, t, !T, n, !t || Q.test(e) && me(t.parentNode) || t), n
                    }, p.sortStable = S.split("").sort(C).join("") === S, p.detectDuplicates = !!l, w(), p.sortDetached = ce(function (e) {
                        return 1 & e.compareDocumentPosition(E.createElement("fieldset"))
                    }), ce(function (e) {
                        return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
                    }) || le("type|href|height|width", function (e, t, n) {
                        if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
                    }), p.attributes && ce(function (e) {
                        return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
                    }) || le("value", function (e, t, n) {
                        if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
                    }), ce(function (e) {
                        return null == e.getAttribute("disabled")
                    }) || le(j, function (e, t, n) {
                        var r;
                        if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
                    }), oe
                }(E);
                S.find = p, S.expr = p.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = p.uniqueSort, S.text = p.getText, S.isXMLDoc = p.isXML, S.contains = p.contains, S.escapeSelector = p.escape;
                var f = function (e, t, n) {
                    for (var r = [], i = void 0 !== n;
                        (e = e[t]) && 9 !== e.nodeType;)
                        if (1 === e.nodeType) {
                            if (i && S(e).is(n)) break;
                            r.push(e)
                        }
                    return r
                },
                    w = function (e, t) {
                        for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
                        return n
                    },
                    M = S.expr.match.needsContext;

                function A(e, t) {
                    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
                }
                var C = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

                function L(e, n, r) {
                    return y(n) ? S.grep(e, function (e, t) {
                        return !!n.call(e, t, e) !== r
                    }) : n.nodeType ? S.grep(e, function (e) {
                        return e === n !== r
                    }) : "string" != typeof n ? S.grep(e, function (e) {
                        return -1 < i.call(n, e) !== r
                    }) : S.filter(n, e, r)
                }
                S.filter = function (e, t, n) {
                    var r = t[0];
                    return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) {
                        return 1 === e.nodeType
                    }))
                }, S.fn.extend({
                    find: function (e) {
                        var t, n, r = this.length,
                            i = this;
                        if ("string" != typeof e) return this.pushStack(S(e).filter(function () {
                            for (t = 0; t < r; t++)
                                if (S.contains(i[t], this)) return !0
                        }));
                        for (n = this.pushStack([]), t = 0; t < r; t++) S.find(e, i[t], n);
                        return 1 < r ? S.uniqueSort(n) : n
                    },
                    filter: function (e) {
                        return this.pushStack(L(this, e || [], !1))
                    },
                    not: function (e) {
                        return this.pushStack(L(this, e || [], !0))
                    },
                    is: function (e) {
                        return !!L(this, "string" == typeof e && M.test(e) ? S(e) : e || [], !1).length
                    }
                });
                var R, P = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
                (S.fn.init = function (e, t, n) {
                    var r, i;
                    if (!e) return this;
                    if (n = n || R, "string" == typeof e) {
                        if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : P.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
                        if (r[1]) {
                            if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : T, !0)), C.test(r[1]) && S.isPlainObject(t))
                                for (r in t) y(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                            return this
                        }
                        return (i = T.getElementById(r[2])) && (this[0] = i, this.length = 1), this
                    }
                    return e.nodeType ? (this[0] = e, this.length = 1, this) : y(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this)
                }).prototype = S.fn, R = S(T);
                var O = /^(?:parents|prev(?:Until|All))/,
                    I = {
                        children: !0,
                        contents: !0,
                        next: !0,
                        prev: !0
                    };

                function D(e, t) {
                    for (;
                        (e = e[t]) && 1 !== e.nodeType;);
                    return e
                }
                S.fn.extend({
                    has: function (e) {
                        var t = S(e, this),
                            n = t.length;
                        return this.filter(function () {
                            for (var e = 0; e < n; e++)
                                if (S.contains(this, t[e])) return !0
                        })
                    },
                    closest: function (e, t) {
                        var n, r = 0,
                            i = this.length,
                            o = [],
                            a = "string" != typeof e && S(e);
                        if (!M.test(e))
                            for (; r < i; r++)
                                for (n = this[r]; n && n !== t; n = n.parentNode)
                                    if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) {
                                        o.push(n);
                                        break
                                    }
                        return this.pushStack(1 < o.length ? S.uniqueSort(o) : o)
                    },
                    index: function (e) {
                        return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                    },
                    add: function (e, t) {
                        return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t))))
                    },
                    addBack: function (e) {
                        return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
                    }
                }), S.each({
                    parent: function (e) {
                        var t = e.parentNode;
                        return t && 11 !== t.nodeType ? t : null
                    },
                    parents: function (e) {
                        return f(e, "parentNode")
                    },
                    parentsUntil: function (e, t, n) {
                        return f(e, "parentNode", n)
                    },
                    next: function (e) {
                        return D(e, "nextSibling")
                    },
                    prev: function (e) {
                        return D(e, "previousSibling")
                    },
                    nextAll: function (e) {
                        return f(e, "nextSibling")
                    },
                    prevAll: function (e) {
                        return f(e, "previousSibling")
                    },
                    nextUntil: function (e, t, n) {
                        return f(e, "nextSibling", n)
                    },
                    prevUntil: function (e, t, n) {
                        return f(e, "previousSibling", n)
                    },
                    siblings: function (e) {
                        return w((e.parentNode || {}).firstChild, e)
                    },
                    children: function (e) {
                        return w(e.firstChild)
                    },
                    contents: function (e) {
                        return A(e, "iframe") ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes))
                    }
                }, function (r, i) {
                    S.fn[r] = function (e, t) {
                        var n = S.map(this, i, e);
                        return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (I[r] || S.uniqueSort(n), O.test(r) && n.reverse()), this.pushStack(n)
                    }
                });
                var j = /[^\x20\t\r\n\f]+/g;

                function N(e) {
                    return e
                }

                function k(e) {
                    throw e
                }

                function U(e, t, n, r) {
                    var i;
                    try {
                        e && y(i = e.promise) ? i.call(e).done(t).fail(n) : e && y(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r))
                    } catch (e) {
                        n.apply(void 0, [e])
                    }
                }
                S.Callbacks = function (r) {
                    var e, n;
                    r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(j) || [], function (e, t) {
                        n[t] = !0
                    }), n) : S.extend({}, r);
                    var i, t, o, a, s = [],
                        c = [],
                        l = -1,
                        u = function () {
                            for (a = a || r.once, o = i = !0; c.length; l = -1)
                                for (t = c.shift(); ++l < s.length;) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1);
                            r.memory || (t = !1), i = !1, a && (s = t ? [] : "")
                        },
                        h = {
                            add: function () {
                                return s && (t && !i && (l = s.length - 1, c.push(t)), function n(e) {
                                    S.each(e, function (e, t) {
                                        y(t) ? r.unique && h.has(t) || s.push(t) : t && t.length && "string" !== b(t) && n(t)
                                    })
                                }(arguments), t && !i && u()), this
                            },
                            remove: function () {
                                return S.each(arguments, function (e, t) {
                                    for (var n; - 1 < (n = S.inArray(t, s, n));) s.splice(n, 1), n <= l && l--
                                }), this
                            },
                            has: function (e) {
                                return e ? -1 < S.inArray(e, s) : 0 < s.length
                            },
                            empty: function () {
                                return s && (s = []), this
                            },
                            disable: function () {
                                return a = c = [], s = t = "", this
                            },
                            disabled: function () {
                                return !s
                            },
                            lock: function () {
                                return a = c = [], t || i || (s = t = ""), this
                            },
                            locked: function () {
                                return !!a
                            },
                            fireWith: function (e, t) {
                                return a || (t = [e, (t = t || []).slice ? t.slice() : t], c.push(t), i || u()), this
                            },
                            fire: function () {
                                return h.fireWith(this, arguments), this
                            },
                            fired: function () {
                                return !!o
                            }
                        };
                    return h
                }, S.extend({
                    Deferred: function (e) {
                        var o = [
                            ["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2],
                            ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"],
                            ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]
                        ],
                            i = "pending",
                            a = {
                                state: function () {
                                    return i
                                },
                                always: function () {
                                    return s.done(arguments).fail(arguments), this
                                },
                                catch: function (e) {
                                    return a.then(null, e)
                                },
                                pipe: function () {
                                    var i = arguments;
                                    return S.Deferred(function (r) {
                                        S.each(o, function (e, t) {
                                            var n = y(i[t[4]]) && i[t[4]];
                                            s[t[1]](function () {
                                                var e = n && n.apply(this, arguments);
                                                e && y(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments)
                                            })
                                        }), i = null
                                    }).promise()
                                },
                                then: function (t, n, r) {
                                    var c = 0;

                                    function l(i, o, a, s) {
                                        return function () {
                                            var n = this,
                                                r = arguments,
                                                e = function () {
                                                    var e, t;
                                                    if (!(i < c)) {
                                                        if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
                                                        t = e && ("object" === (void 0 === e ? "undefined" : Xt(e)) || "function" == typeof e) && e.then, y(t) ? s ? t.call(e, l(c, o, N, s), l(c, o, k, s)) : (c++ , t.call(e, l(c, o, N, s), l(c, o, k, s), l(c, o, N, o.notifyWith))) : (a !== N && (n = void 0, r = [e]), (s || o.resolveWith)(n, r))
                                                    }
                                                },
                                                t = s ? e : function () {
                                                    try {
                                                        e()
                                                    } catch (e) {
                                                        S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), c <= i + 1 && (a !== k && (n = void 0, r = [e]), o.rejectWith(n, r))
                                                    }
                                                };
                                            i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), E.setTimeout(t))
                                        }
                                    }
                                    return S.Deferred(function (e) {
                                        o[0][3].add(l(0, e, y(r) ? r : N, e.notifyWith)), o[1][3].add(l(0, e, y(t) ? t : N)), o[2][3].add(l(0, e, y(n) ? n : k))
                                    }).promise()
                                },
                                promise: function (e) {
                                    return null != e ? S.extend(e, a) : a
                                }
                            },
                            s = {};
                        return S.each(o, function (e, t) {
                            var n = t[2],
                                r = t[5];
                            a[t[1]] = n.add, r && n.add(function () {
                                i = r
                            }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () {
                                return s[t[0] + "With"](this === s ? void 0 : this, arguments), this
                            }, s[t[0] + "With"] = n.fireWith
                        }), a.promise(s), e && e.call(s, s), s
                    },
                    when: function (e) {
                        var n = arguments.length,
                            t = n,
                            r = Array(t),
                            i = s.call(arguments),
                            o = S.Deferred(),
                            a = function (t) {
                                return function (e) {
                                    r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i)
                                }
                            };
                        if (n <= 1 && (U(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || y(i[t] && i[t].then))) return o.then();
                        for (; t--;) U(i[t], a(t), o.reject);
                        return o.promise()
                    }
                });
                var H = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
                S.Deferred.exceptionHook = function (e, t) {
                    E.console && E.console.warn && e && H.test(e.name) && E.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
                }, S.readyException = function (e) {
                    E.setTimeout(function () {
                        throw e
                    })
                };
                var B = S.Deferred();

                function F() {
                    T.removeEventListener("DOMContentLoaded", F), E.removeEventListener("load", F), S.ready()
                }
                S.fn.ready = function (e) {
                    return B.then(e).catch(function (e) {
                        S.readyException(e)
                    }), this
                }, S.extend({
                    isReady: !1,
                    readyWait: 1,
                    ready: function (e) {
                        (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || B.resolveWith(T, [S])
                    }
                }), S.ready.then = B.then, "complete" === T.readyState || "loading" !== T.readyState && !T.documentElement.doScroll ? E.setTimeout(S.ready) : (T.addEventListener("DOMContentLoaded", F), E.addEventListener("load", F));
                var z = function e(t, n, r, i, o, a, s) {
                    var c = 0,
                        l = t.length,
                        u = null == r;
                    if ("object" === b(r))
                        for (c in o = !0, r) e(t, n, c, r[c], !0, a, s);
                    else if (void 0 !== i && (o = !0, y(i) || (s = !0), u && (s ? (n.call(t, i), n = null) : (u = n, n = function (e, t, n) {
                        return u.call(S(e), n)
                    })), n))
                        for (; c < l; c++) n(t[c], r, s ? i : i.call(t[c], c, n(t[c], r)));
                    return o ? t : u ? n.call(t) : l ? n(t[0], r) : a
                },
                    G = /^-ms-/,
                    V = /-([a-z])/g;

                function q(e, t) {
                    return t.toUpperCase()
                }

                function W(e) {
                    return e.replace(G, "ms-").replace(V, q)
                }
                var X = function (e) {
                    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
                };

                function Y() {
                    this.expando = S.expando + Y.uid++
                }
                Y.uid = 1, Y.prototype = {
                    cache: function (e) {
                        var t = e[this.expando];
                        return t || (t = {}, X(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                            value: t,
                            configurable: !0
                        }))), t
                    },
                    set: function (e, t, n) {
                        var r, i = this.cache(e);
                        if ("string" == typeof t) i[W(t)] = n;
                        else
                            for (r in t) i[W(r)] = t[r];
                        return i
                    },
                    get: function (e, t) {
                        return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][W(t)]
                    },
                    access: function (e, t, n) {
                        return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
                    },
                    remove: function (e, t) {
                        var n, r = e[this.expando];
                        if (void 0 !== r) {
                            if (void 0 !== t) {
                                n = (t = Array.isArray(t) ? t.map(W) : (t = W(t)) in r ? [t] : t.match(j) || []).length;
                                for (; n--;) delete r[t[n]]
                            } (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
                        }
                    },
                    hasData: function (e) {
                        var t = e[this.expando];
                        return void 0 !== t && !S.isEmptyObject(t)
                    }
                };
                var J = new Y,
                    Z = new Y,
                    $ = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                    Q = /[A-Z]/g;

                function K(e, t, n) {
                    var r, i;
                    if (void 0 === n && 1 === e.nodeType)
                        if (r = "data-" + t.replace(Q, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) {
                            try {
                                n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : $.test(i) ? JSON.parse(i) : i)
                            } catch (e) { }
                            Z.set(e, t, n)
                        } else n = void 0;
                    return n
                }
                S.extend({
                    hasData: function (e) {
                        return Z.hasData(e) || J.hasData(e)
                    },
                    data: function (e, t, n) {
                        return Z.access(e, t, n)
                    },
                    removeData: function (e, t) {
                        Z.remove(e, t)
                    },
                    _data: function (e, t, n) {
                        return J.access(e, t, n)
                    },
                    _removeData: function (e, t) {
                        J.remove(e, t)
                    }
                }), S.fn.extend({
                    data: function (n, e) {
                        var t, r, i, o = this[0],
                            a = o && o.attributes;
                        if (void 0 === n) {
                            if (this.length && (i = Z.get(o), 1 === o.nodeType && !J.get(o, "hasDataAttrs"))) {
                                for (t = a.length; t--;) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = W(r.slice(5)), K(o, r, i[r]));
                                J.set(o, "hasDataAttrs", !0)
                            }
                            return i
                        }
                        return "object" === (void 0 === n ? "undefined" : Xt(n)) ? this.each(function () {
                            Z.set(this, n)
                        }) : z(this, function (e) {
                            var t;
                            if (o && void 0 === e) return void 0 !== (t = Z.get(o, n)) ? t : void 0 !== (t = K(o, n)) ? t : void 0;
                            this.each(function () {
                                Z.set(this, n, e)
                            })
                        }, null, e, 1 < arguments.length, null, !0)
                    },
                    removeData: function (e) {
                        return this.each(function () {
                            Z.remove(this, e)
                        })
                    }
                }), S.extend({
                    queue: function (e, t, n) {
                        var r;
                        if (e) return t = (t || "fx") + "queue", r = J.get(e, t), n && (!r || Array.isArray(n) ? r = J.access(e, t, S.makeArray(n)) : r.push(n)), r || []
                    },
                    dequeue: function (e, t) {
                        t = t || "fx";
                        var n = S.queue(e, t),
                            r = n.length,
                            i = n.shift(),
                            o = S._queueHooks(e, t);
                        "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () {
                            S.dequeue(e, t)
                        }, o)), !r && o && o.empty.fire()
                    },
                    _queueHooks: function (e, t) {
                        var n = t + "queueHooks";
                        return J.get(e, n) || J.access(e, n, {
                            empty: S.Callbacks("once memory").add(function () {
                                J.remove(e, [t + "queue", n])
                            })
                        })
                    }
                }), S.fn.extend({
                    queue: function (t, n) {
                        var e = 2;
                        return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () {
                            var e = S.queue(this, t, n);
                            S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t)
                        })
                    },
                    dequeue: function (e) {
                        return this.each(function () {
                            S.dequeue(this, e)
                        })
                    },
                    clearQueue: function (e) {
                        return this.queue(e || "fx", [])
                    },
                    promise: function (e, t) {
                        var n, r = 1,
                            i = S.Deferred(),
                            o = this,
                            a = this.length,
                            s = function () {
                                --r || i.resolveWith(o, [o])
                            };
                        for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;)(n = J.get(o[a], e + "queueHooks")) && n.empty && (r++ , n.empty.add(s));
                        return s(), i.promise(t)
                    }
                });
                var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                    te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
                    ne = ["Top", "Right", "Bottom", "Left"],
                    re = function (e, t) {
                        return "none" === (e = t || e).style.display || "" === e.style.display && S.contains(e.ownerDocument, e) && "none" === S.css(e, "display")
                    },
                    ie = function (e, t, n, r) {
                        var i, o, a = {};
                        for (o in t) a[o] = e.style[o], e.style[o] = t[o];
                        for (o in i = n.apply(e, r || []), t) e.style[o] = a[o];
                        return i
                    };

                function oe(e, t, n, r) {
                    var i, o, a = 20,
                        s = r ? function () {
                            return r.cur()
                        } : function () {
                            return S.css(e, t, "")
                        },
                        c = s(),
                        l = n && n[3] || (S.cssNumber[t] ? "" : "px"),
                        u = (S.cssNumber[t] || "px" !== l && +c) && te.exec(S.css(e, t));
                    if (u && u[3] !== l) {
                        for (c /= 2, l = l || u[3], u = +c || 1; a--;) S.style(e, t, u + l), (1 - o) * (1 - (o = s() / c || .5)) <= 0 && (a = 0), u /= o;
                        u *= 2, S.style(e, t, u + l), n = n || []
                    }
                    return n && (u = +u || +c || 0, i = n[1] ? u + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = u, r.end = i)), i
                }
                var ae = {};

                function se(e, t) {
                    for (var n, r, i, o, a, s, c, l = [], u = 0, h = e.length; u < h; u++)(r = e[u]).style && (n = r.style.display, t ? ("none" === n && (l[u] = J.get(r, "display") || null, l[u] || (r.style.display = "")), "" === r.style.display && re(r) && (l[u] = (c = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (c = ae[s]) || (o = a.body.appendChild(a.createElement(s)), c = S.css(o, "display"), o.parentNode.removeChild(o), "none" === c && (c = "block"), ae[s] = c)))) : "none" !== n && (l[u] = "none", J.set(r, "display", n)));
                    for (u = 0; u < h; u++) null != l[u] && (e[u].style.display = l[u]);
                    return e
                }
                S.fn.extend({
                    show: function () {
                        return se(this, !0)
                    },
                    hide: function () {
                        return se(this)
                    },
                    toggle: function (e) {
                        return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
                            re(this) ? S(this).show() : S(this).hide()
                        })
                    }
                });
                var ce = /^(?:checkbox|radio)$/i,
                    le = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
                    ue = /^$|^module$|\/(?:java|ecma)script/i,
                    he = {
                        option: [1, "<select multiple='multiple'>", "</select>"],
                        thead: [1, "<table>", "</table>"],
                        col: [2, "<table><colgroup>", "</colgroup></table>"],
                        tr: [2, "<table><tbody>", "</tbody></table>"],
                        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                        _default: [0, "", ""]
                    };

                function de(e, t) {
                    var n;
                    return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n
                }

                function pe(e, t) {
                    for (var n = 0, r = e.length; n < r; n++) J.set(e[n], "globalEval", !t || J.get(t[n], "globalEval"))
                }
                he.optgroup = he.option, he.tbody = he.tfoot = he.colgroup = he.caption = he.thead, he.th = he.td;
                var fe, me, ge = /<|&#?\w+;/;

                function ve(e, t, n, r, i) {
                    for (var o, a, s, c, l, u, h = t.createDocumentFragment(), d = [], p = 0, f = e.length; p < f; p++)
                        if ((o = e[p]) || 0 === o)
                            if ("object" === b(o)) S.merge(d, o.nodeType ? [o] : o);
                            else if (ge.test(o)) {
                                for (a = a || h.appendChild(t.createElement("div")), s = (le.exec(o) || ["", ""])[1].toLowerCase(), c = he[s] || he._default, a.innerHTML = c[1] + S.htmlPrefilter(o) + c[2], u = c[0]; u--;) a = a.lastChild;
                                S.merge(d, a.childNodes), (a = h.firstChild).textContent = ""
                            } else d.push(t.createTextNode(o));
                    for (h.textContent = "", p = 0; o = d[p++];)
                        if (r && -1 < S.inArray(o, r)) i && i.push(o);
                        else if (l = S.contains(o.ownerDocument, o), a = de(h.appendChild(o), "script"), l && pe(a), n)
                            for (u = 0; o = a[u++];) ue.test(o.type || "") && n.push(o);
                    return h
                }
                fe = T.createDocumentFragment().appendChild(T.createElement("div")), (me = T.createElement("input")).setAttribute("type", "radio"), me.setAttribute("checked", "checked"), me.setAttribute("name", "t"), fe.appendChild(me), v.checkClone = fe.cloneNode(!0).cloneNode(!0).lastChild.checked, fe.innerHTML = "<textarea>x</textarea>", v.noCloneChecked = !!fe.cloneNode(!0).lastChild.defaultValue;
                var ye = T.documentElement,
                    _e = /^key/,
                    xe = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                    be = /^([^.]*)(?:\.(.+)|)/;

                function we() {
                    return !0
                }

                function Ee() {
                    return !1
                }

                function Te() {
                    try {
                        return T.activeElement
                    } catch (e) { }
                }

                function Se(e, t, n, r, i, o) {
                    var a, s;
                    if ("object" === (void 0 === t ? "undefined" : Xt(t))) {
                        for (s in "string" != typeof n && (r = r || n, n = void 0), t) Se(e, s, n, r, t[s], o);
                        return e
                    }
                    if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Ee;
                    else if (!i) return e;
                    return 1 === o && (a = i, (i = function (e) {
                        return S().off(e), a.apply(this, arguments)
                    }).guid = a.guid || (a.guid = S.guid++)), e.each(function () {
                        S.event.add(this, t, i, r, n)
                    })
                }
                S.event = {
                    global: {},
                    add: function (t, e, n, r, i) {
                        var o, a, s, c, l, u, h, d, p, f, m, g = J.get(t);
                        if (g)
                            for (n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(ye, i), n.guid || (n.guid = S.guid++), (c = g.events) || (c = g.events = {}), (a = g.handle) || (a = g.handle = function (e) {
                                return void 0 !== S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0
                            }), l = (e = (e || "").match(j) || [""]).length; l--;) p = m = (s = be.exec(e[l]) || [])[1], f = (s[2] || "").split(".").sort(), p && (h = S.event.special[p] || {}, p = (i ? h.delegateType : h.bindType) || p, h = S.event.special[p] || {}, u = S.extend({
                                type: p,
                                origType: m,
                                data: r,
                                handler: n,
                                guid: n.guid,
                                selector: i,
                                needsContext: i && S.expr.match.needsContext.test(i),
                                namespace: f.join(".")
                            }, o), (d = c[p]) || ((d = c[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(t, r, f, a) || t.addEventListener && t.addEventListener(p, a)), h.add && (h.add.call(t, u), u.handler.guid || (u.handler.guid = n.guid)), i ? d.splice(d.delegateCount++, 0, u) : d.push(u), S.event.global[p] = !0)
                    },
                    remove: function (e, t, n, r, i) {
                        var o, a, s, c, l, u, h, d, p, f, m, g = J.hasData(e) && J.get(e);
                        if (g && (c = g.events)) {
                            for (l = (t = (t || "").match(j) || [""]).length; l--;)
                                if (p = m = (s = be.exec(t[l]) || [])[1], f = (s[2] || "").split(".").sort(), p) {
                                    for (h = S.event.special[p] || {}, d = c[p = (r ? h.delegateType : h.bindType) || p] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = d.length; o--;) u = d[o], !i && m !== u.origType || n && n.guid !== u.guid || s && !s.test(u.namespace) || r && r !== u.selector && ("**" !== r || !u.selector) || (d.splice(o, 1), u.selector && d.delegateCount-- , h.remove && h.remove.call(e, u));
                                    a && !d.length && (h.teardown && !1 !== h.teardown.call(e, f, g.handle) || S.removeEvent(e, p, g.handle), delete c[p])
                                } else
                                    for (p in c) S.event.remove(e, p + t[l], n, r, !0);
                            S.isEmptyObject(c) && J.remove(e, "handle events")
                        }
                    },
                    dispatch: function (e) {
                        var t, n, r, i, o, a, s = S.event.fix(e),
                            c = new Array(arguments.length),
                            l = (J.get(this, "events") || {})[s.type] || [],
                            u = S.event.special[s.type] || {};
                        for (c[0] = s, t = 1; t < arguments.length; t++) c[t] = arguments[t];
                        if (s.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, s)) {
                            for (a = S.event.handlers.call(this, s, l), t = 0;
                                (i = a[t++]) && !s.isPropagationStopped();)
                                for (s.currentTarget = i.elem, n = 0;
                                    (o = i.handlers[n++]) && !s.isImmediatePropagationStopped();) s.rnamespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, c)) && !1 === (s.result = r) && (s.preventDefault(), s.stopPropagation()));
                            return u.postDispatch && u.postDispatch.call(this, s), s.result
                        }
                    },
                    handlers: function (e, t) {
                        var n, r, i, o, a, s = [],
                            c = t.delegateCount,
                            l = e.target;
                        if (c && l.nodeType && !("click" === e.type && 1 <= e.button))
                            for (; l !== this; l = l.parentNode || this)
                                if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
                                    for (o = [], a = {}, n = 0; n < c; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r);
                                    o.length && s.push({
                                        elem: l,
                                        handlers: o
                                    })
                                }
                        return l = this, c < t.length && s.push({
                            elem: l,
                            handlers: t.slice(c)
                        }), s
                    },
                    addProp: function (t, e) {
                        Object.defineProperty(S.Event.prototype, t, {
                            enumerable: !0,
                            configurable: !0,
                            get: y(e) ? function () {
                                if (this.originalEvent) return e(this.originalEvent)
                            } : function () {
                                if (this.originalEvent) return this.originalEvent[t]
                            },
                            set: function (e) {
                                Object.defineProperty(this, t, {
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0,
                                    value: e
                                })
                            }
                        })
                    },
                    fix: function (e) {
                        return e[S.expando] ? e : new S.Event(e)
                    },
                    special: {
                        load: {
                            noBubble: !0
                        },
                        focus: {
                            trigger: function () {
                                if (this !== Te() && this.focus) return this.focus(), !1
                            },
                            delegateType: "focusin"
                        },
                        blur: {
                            trigger: function () {
                                if (this === Te() && this.blur) return this.blur(), !1
                            },
                            delegateType: "focusout"
                        },
                        click: {
                            trigger: function () {
                                if ("checkbox" === this.type && this.click && A(this, "input")) return this.click(), !1
                            },
                            _default: function (e) {
                                return A(e.target, "a")
                            }
                        },
                        beforeunload: {
                            postDispatch: function (e) {
                                void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                            }
                        }
                    }
                }, S.removeEvent = function (e, t, n) {
                    e.removeEventListener && e.removeEventListener(t, n)
                }, S.Event = function (e, t) {
                    if (!(this instanceof S.Event)) return new S.Event(e, t);
                    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Ee, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0
                }, S.Event.prototype = {
                    constructor: S.Event,
                    isDefaultPrevented: Ee,
                    isPropagationStopped: Ee,
                    isImmediatePropagationStopped: Ee,
                    isSimulated: !1,
                    preventDefault: function () {
                        var e = this.originalEvent;
                        this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault()
                    },
                    stopPropagation: function () {
                        var e = this.originalEvent;
                        this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation()
                    },
                    stopImmediatePropagation: function () {
                        var e = this.originalEvent;
                        this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
                    }
                }, S.each({
                    altKey: !0,
                    bubbles: !0,
                    cancelable: !0,
                    changedTouches: !0,
                    ctrlKey: !0,
                    detail: !0,
                    eventPhase: !0,
                    metaKey: !0,
                    pageX: !0,
                    pageY: !0,
                    shiftKey: !0,
                    view: !0,
                    char: !0,
                    charCode: !0,
                    key: !0,
                    keyCode: !0,
                    button: !0,
                    buttons: !0,
                    clientX: !0,
                    clientY: !0,
                    offsetX: !0,
                    offsetY: !0,
                    pointerId: !0,
                    pointerType: !0,
                    screenX: !0,
                    screenY: !0,
                    targetTouches: !0,
                    toElement: !0,
                    touches: !0,
                    which: function (e) {
                        var t = e.button;
                        return null == e.which && _e.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && xe.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which
                    }
                }, S.event.addProp), S.each({
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, function (e, i) {
                    S.event.special[e] = {
                        delegateType: i,
                        bindType: i,
                        handle: function (e) {
                            var t, n = e.relatedTarget,
                                r = e.handleObj;
                            return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t
                        }
                    }
                }), S.fn.extend({
                    on: function (e, t, n, r) {
                        return Se(this, e, t, n, r)
                    },
                    one: function (e, t, n, r) {
                        return Se(this, e, t, n, r, 1)
                    },
                    off: function (e, t, n) {
                        var r, i;
                        if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
                        if ("object" === (void 0 === e ? "undefined" : Xt(e))) {
                            for (i in e) this.off(i, t, e[i]);
                            return this
                        }
                        return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Ee), this.each(function () {
                            S.event.remove(this, e, n, t)
                        })
                    }
                });
                var Me = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
                    Ae = /<script|<style|<link/i,
                    Ce = /checked\s*(?:[^=]|=\s*.checked.)/i,
                    Le = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

                function Re(e, t) {
                    return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e
                }

                function Pe(e) {
                    return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
                }

                function Oe(e) {
                    return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
                }

                function Ie(e, t) {
                    var n, r, i, o, a, s, c, l;
                    if (1 === t.nodeType) {
                        if (J.hasData(e) && (o = J.access(e), a = J.set(t, o), l = o.events))
                            for (i in delete a.handle, a.events = {}, l)
                                for (n = 0, r = l[i].length; n < r; n++) S.event.add(t, i, l[i][n]);
                        Z.hasData(e) && (s = Z.access(e), c = S.extend({}, s), Z.set(t, c))
                    }
                }

                function De(n, r, i, o) {
                    r = m.apply([], r);
                    var e, t, a, s, c, l, u = 0,
                        h = n.length,
                        d = h - 1,
                        p = r[0],
                        f = y(p);
                    if (f || 1 < h && "string" == typeof p && !v.checkClone && Ce.test(p)) return n.each(function (e) {
                        var t = n.eq(e);
                        f && (r[0] = p.call(this, e, t.html())), De(t, r, i, o)
                    });
                    if (h && (t = (e = ve(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
                        for (s = (a = S.map(de(e, "script"), Pe)).length; u < h; u++) c = e, u !== d && (c = S.clone(c, !0, !0), s && S.merge(a, de(c, "script"))), i.call(n[u], c, u);
                        if (s)
                            for (l = a[a.length - 1].ownerDocument, S.map(a, Oe), u = 0; u < s; u++) c = a[u], ue.test(c.type || "") && !J.access(c, "globalEval") && S.contains(l, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? S._evalUrl && S._evalUrl(c.src) : x(c.textContent.replace(Le, ""), l, c))
                    }
                    return n
                }

                function je(e, t, n) {
                    for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || S.cleanData(de(r)), r.parentNode && (n && S.contains(r.ownerDocument, r) && pe(de(r, "script")), r.parentNode.removeChild(r));
                    return e
                }
                S.extend({
                    htmlPrefilter: function (e) {
                        return e.replace(Me, "<$1></$2>")
                    },
                    clone: function (e, t, n) {
                        var r, i, o, a, s, c, l, u = e.cloneNode(!0),
                            h = S.contains(e.ownerDocument, e);
                        if (!(v.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e)))
                            for (a = de(u), r = 0, i = (o = de(e)).length; r < i; r++) s = o[r], c = a[r], void 0, "input" === (l = c.nodeName.toLowerCase()) && ce.test(s.type) ? c.checked = s.checked : "input" !== l && "textarea" !== l || (c.defaultValue = s.defaultValue);
                        if (t)
                            if (n)
                                for (o = o || de(e), a = a || de(u), r = 0, i = o.length; r < i; r++) Ie(o[r], a[r]);
                            else Ie(e, u);
                        return 0 < (a = de(u, "script")).length && pe(a, !h && de(e, "script")), u
                    },
                    cleanData: function (e) {
                        for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)
                            if (X(n)) {
                                if (t = n[J.expando]) {
                                    if (t.events)
                                        for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle);
                                    n[J.expando] = void 0
                                }
                                n[Z.expando] && (n[Z.expando] = void 0)
                            }
                    }
                }), S.fn.extend({
                    detach: function (e) {
                        return je(this, e, !0)
                    },
                    remove: function (e) {
                        return je(this, e)
                    },
                    text: function (e) {
                        return z(this, function (e) {
                            return void 0 === e ? S.text(this) : this.empty().each(function () {
                                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                            })
                        }, null, e, arguments.length)
                    },
                    append: function () {
                        return De(this, arguments, function (e) {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Re(this, e).appendChild(e)
                        })
                    },
                    prepend: function () {
                        return De(this, arguments, function (e) {
                            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                                var t = Re(this, e);
                                t.insertBefore(e, t.firstChild)
                            }
                        })
                    },
                    before: function () {
                        return De(this, arguments, function (e) {
                            this.parentNode && this.parentNode.insertBefore(e, this)
                        })
                    },
                    after: function () {
                        return De(this, arguments, function (e) {
                            this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                        })
                    },
                    empty: function () {
                        for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (S.cleanData(de(e, !1)), e.textContent = "");
                        return this
                    },
                    clone: function (e, t) {
                        return e = null != e && e, t = null == t ? e : t, this.map(function () {
                            return S.clone(this, e, t)
                        })
                    },
                    html: function (e) {
                        return z(this, function (e) {
                            var t = this[0] || {},
                                n = 0,
                                r = this.length;
                            if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                            if ("string" == typeof e && !Ae.test(e) && !he[(le.exec(e) || ["", ""])[1].toLowerCase()]) {
                                e = S.htmlPrefilter(e);
                                try {
                                    for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (S.cleanData(de(t, !1)), t.innerHTML = e);
                                    t = 0
                                } catch (e) { }
                            }
                            t && this.empty().append(e)
                        }, null, e, arguments.length)
                    },
                    replaceWith: function () {
                        var n = [];
                        return De(this, arguments, function (e) {
                            var t = this.parentNode;
                            S.inArray(this, n) < 0 && (S.cleanData(de(this)), t && t.replaceChild(e, this))
                        }, n)
                    }
                }), S.each({
                    appendTo: "append",
                    prependTo: "prepend",
                    insertBefore: "before",
                    insertAfter: "after",
                    replaceAll: "replaceWith"
                }, function (e, a) {
                    S.fn[e] = function (e) {
                        for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++) t = o === i ? this : this.clone(!0), S(r[o])[a](t), c.apply(n, t.get());
                        return this.pushStack(n)
                    }
                });
                var Ne = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
                    ke = function (e) {
                        var t = e.ownerDocument.defaultView;
                        return t && t.opener || (t = E), t.getComputedStyle(e)
                    },
                    Ue = new RegExp(ne.join("|"), "i");

                function He(e, t, n) {
                    var r, i, o, a, s = e.style;
                    return (n = n || ke(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || S.contains(e.ownerDocument, e) || (a = S.style(e, t)), !v.pixelBoxStyles() && Ne.test(a) && Ue.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a
                }

                function Be(e, t) {
                    return {
                        get: function () {
                            if (!e()) return (this.get = t).apply(this, arguments);
                            delete this.get
                        }
                    }
                } ! function () {
                    function e() {
                        if (c) {
                            s.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ye.appendChild(s).appendChild(c);
                            var e = E.getComputedStyle(c);
                            n = "1%" !== e.top, a = 12 === t(e.marginLeft), c.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), c.style.position = "absolute", i = 36 === c.offsetWidth || "absolute", ye.removeChild(s), c = null
                        }
                    }

                    function t(e) {
                        return Math.round(parseFloat(e))
                    }
                    var n, r, i, o, a, s = T.createElement("div"),
                        c = T.createElement("div");
                    c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", v.clearCloneStyle = "content-box" === c.style.backgroundClip, S.extend(v, {
                        boxSizingReliable: function () {
                            return e(), r
                        },
                        pixelBoxStyles: function () {
                            return e(), o
                        },
                        pixelPosition: function () {
                            return e(), n
                        },
                        reliableMarginLeft: function () {
                            return e(), a
                        },
                        scrollboxSize: function () {
                            return e(), i
                        }
                    }))
                }();
                var Fe = /^(none|table(?!-c[ea]).+)/,
                    ze = /^--/,
                    Ge = {
                        position: "absolute",
                        visibility: "hidden",
                        display: "block"
                    },
                    Ve = {
                        letterSpacing: "0",
                        fontWeight: "400"
                    },
                    qe = ["Webkit", "Moz", "ms"],
                    We = T.createElement("div").style;

                function Xe(e) {
                    var t = S.cssProps[e];
                    return t || (t = S.cssProps[e] = function (e) {
                        if (e in We) return e;
                        for (var t = e[0].toUpperCase() + e.slice(1), n = qe.length; n--;)
                            if ((e = qe[n] + t) in We) return e
                    }(e) || e), t
                }

                function Ye(e, t, n) {
                    var r = te.exec(t);
                    return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t
                }

                function Je(e, t, n, r, i, o) {
                    var a = "width" === t ? 1 : 0,
                        s = 0,
                        c = 0;
                    if (n === (r ? "border" : "content")) return 0;
                    for (; a < 4; a += 2) "margin" === n && (c += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (c -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (c -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (c += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? c += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i));
                    return !r && 0 <= o && (c += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - c - s - .5))), c
                }

                function Ze(e, t, n) {
                    var r = ke(e),
                        i = He(e, t, r),
                        o = "border-box" === S.css(e, "boxSizing", !1, r),
                        a = o;
                    if (Ne.test(i)) {
                        if (!n) return i;
                        i = "auto"
                    }
                    return a = a && (v.boxSizingReliable() || i === e.style[t]), ("auto" === i || !parseFloat(i) && "inline" === S.css(e, "display", !1, r)) && (i = e["offset" + t[0].toUpperCase() + t.slice(1)], a = !0), (i = parseFloat(i) || 0) + Je(e, t, n || (o ? "border" : "content"), a, r, i) + "px"
                }

                function $e(e, t, n, r, i) {
                    return new $e.prototype.init(e, t, n, r, i)
                }
                S.extend({
                    cssHooks: {
                        opacity: {
                            get: function (e, t) {
                                if (t) {
                                    var n = He(e, "opacity");
                                    return "" === n ? "1" : n
                                }
                            }
                        }
                    },
                    cssNumber: {
                        animationIterationCount: !0,
                        columnCount: !0,
                        fillOpacity: !0,
                        flexGrow: !0,
                        flexShrink: !0,
                        fontWeight: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0
                    },
                    cssProps: {},
                    style: function (e, t, n, r) {
                        if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                            var i, o, a, s = W(t),
                                c = ze.test(t),
                                l = e.style;
                            if (c || (t = Xe(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
                            "string" === (o = void 0 === n ? "undefined" : Xt(n)) && (i = te.exec(n)) && i[1] && (n = oe(e, t, i), o = "number"), null != n && n == n && ("number" === o && (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), v.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (c ? l.setProperty(t, n) : l[t] = n))
                        }
                    },
                    css: function (e, t, n, r) {
                        var i, o, a, s = W(t);
                        return ze.test(t) || (t = Xe(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = He(e, t, r)), "normal" === i && t in Ve && (i = Ve[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
                    }
                }), S.each(["height", "width"], function (e, s) {
                    S.cssHooks[s] = {
                        get: function (e, t, n) {
                            if (t) return !Fe.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Ze(e, s, n) : ie(e, Ge, function () {
                                return Ze(e, s, n)
                            })
                        },
                        set: function (e, t, n) {
                            var r, i = ke(e),
                                o = "border-box" === S.css(e, "boxSizing", !1, i),
                                a = n && Je(e, s, n, o, i);
                            return o && v.scrollboxSize() === i.position && (a -= Math.ceil(e["offset" + s[0].toUpperCase() + s.slice(1)] - parseFloat(i[s]) - Je(e, s, "border", !1, i) - .5)), a && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[s] = t, t = S.css(e, s)), Ye(0, t, a)
                        }
                    }
                }), S.cssHooks.marginLeft = Be(v.reliableMarginLeft, function (e, t) {
                    if (t) return (parseFloat(He(e, "marginLeft")) || e.getBoundingClientRect().left - ie(e, {
                        marginLeft: 0
                    }, function () {
                        return e.getBoundingClientRect().left
                    })) + "px"
                }), S.each({
                    margin: "",
                    padding: "",
                    border: "Width"
                }, function (i, o) {
                    S.cssHooks[i + o] = {
                        expand: function (e) {
                            for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) n[i + ne[t] + o] = r[t] || r[t - 2] || r[0];
                            return n
                        }
                    }, "margin" !== i && (S.cssHooks[i + o].set = Ye)
                }), S.fn.extend({
                    css: function (e, t) {
                        return z(this, function (e, t, n) {
                            var r, i, o = {},
                                a = 0;
                            if (Array.isArray(t)) {
                                for (r = ke(e), i = t.length; a < i; a++) o[t[a]] = S.css(e, t[a], !1, r);
                                return o
                            }
                            return void 0 !== n ? S.style(e, t, n) : S.css(e, t)
                        }, e, t, 1 < arguments.length)
                    }
                }), ((S.Tween = $e).prototype = {
                    constructor: $e,
                    init: function (e, t, n, r, i, o) {
                        this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px")
                    },
                    cur: function () {
                        var e = $e.propHooks[this.prop];
                        return e && e.get ? e.get(this) : $e.propHooks._default.get(this)
                    },
                    run: function (e) {
                        var t, n = $e.propHooks[this.prop];
                        return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : $e.propHooks._default.set(this), this
                    }
                }).init.prototype = $e.prototype, ($e.propHooks = {
                    _default: {
                        get: function (e) {
                            var t;
                            return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
                        },
                        set: function (e) {
                            S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[S.cssProps[e.prop]] && !S.cssHooks[e.prop] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit)
                        }
                    }
                }).scrollTop = $e.propHooks.scrollLeft = {
                    set: function (e) {
                        e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
                    }
                }, S.easing = {
                    linear: function (e) {
                        return e
                    },
                    swing: function (e) {
                        return .5 - Math.cos(e * Math.PI) / 2
                    },
                    _default: "swing"
                }, S.fx = $e.prototype.init, S.fx.step = {};
                var Qe, Ke, et, tt, nt = /^(?:toggle|show|hide)$/,
                    rt = /queueHooks$/;

                function it() {
                    Ke && (!1 === T.hidden && E.requestAnimationFrame ? E.requestAnimationFrame(it) : E.setTimeout(it, S.fx.interval), S.fx.tick())
                }

                function ot() {
                    return E.setTimeout(function () {
                        Qe = void 0
                    }), Qe = Date.now()
                }

                function at(e, t) {
                    var n, r = 0,
                        i = {
                            height: e
                        };
                    for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = ne[r])] = i["padding" + n] = e;
                    return t && (i.opacity = i.width = e), i
                }

                function st(e, t, n) {
                    for (var r, i = (ct.tweeners[t] || []).concat(ct.tweeners["*"]), o = 0, a = i.length; o < a; o++)
                        if (r = i[o].call(n, t, e)) return r
                }

                function ct(o, e, t) {
                    var n, a, r = 0,
                        i = ct.prefilters.length,
                        s = S.Deferred().always(function () {
                            delete c.elem
                        }),
                        c = function () {
                            if (a) return !1;
                            for (var e = Qe || ot(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) l.tweens[r].run(n);
                            return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1)
                        },
                        l = s.promise({
                            elem: o,
                            props: S.extend({}, e),
                            opts: S.extend(!0, {
                                specialEasing: {},
                                easing: S.easing._default
                            }, t),
                            originalProperties: e,
                            originalOptions: t,
                            startTime: Qe || ot(),
                            duration: t.duration,
                            tweens: [],
                            createTween: function (e, t) {
                                var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
                                return l.tweens.push(n), n
                            },
                            stop: function (e) {
                                var t = 0,
                                    n = e ? l.tweens.length : 0;
                                if (a) return this;
                                for (a = !0; t < n; t++) l.tweens[t].run(1);
                                return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this
                            }
                        }),
                        u = l.props;
                    for (! function (e, t) {
                        var n, r, i, o, a;
                        for (n in e)
                            if (i = t[r = W(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a)
                                for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i);
                            else t[r] = i
                    }(u, l.opts.specialEasing); r < i; r++)
                        if (n = ct.prefilters[r].call(l, o, u, l.opts)) return y(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
                    return S.map(u, st, l), y(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(c, {
                        elem: o,
                        anim: l,
                        queue: l.opts.queue
                    })), l
                }
                S.Animation = S.extend(ct, {
                    tweeners: {
                        "*": [function (e, t) {
                            var n = this.createTween(e, t);
                            return oe(n.elem, e, te.exec(t), n), n
                        }]
                    },
                    tweener: function (e, t) {
                        y(e) ? (t = e, e = ["*"]) : e = e.match(j);
                        for (var n, r = 0, i = e.length; r < i; r++) n = e[r], ct.tweeners[n] = ct.tweeners[n] || [], ct.tweeners[n].unshift(t)
                    },
                    prefilters: [function (e, t, n) {
                        var r, i, o, a, s, c, l, u, h = "width" in t || "height" in t,
                            d = this,
                            p = {},
                            f = e.style,
                            m = e.nodeType && re(e),
                            g = J.get(e, "fxshow");
                        for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
                            a.unqueued || s()
                        }), a.unqueued++ , d.always(function () {
                            d.always(function () {
                                a.unqueued-- , S.queue(e, "fx").length || a.empty.fire()
                            })
                        })), t)
                            if (i = t[r], nt.test(i)) {
                                if (delete t[r], o = o || "toggle" === i, i === (m ? "hide" : "show")) {
                                    if ("show" !== i || !g || void 0 === g[r]) continue;
                                    m = !0
                                }
                                p[r] = g && g[r] || S.style(e, r)
                            }
                        if ((c = !S.isEmptyObject(t)) || !S.isEmptyObject(p))
                            for (r in h && 1 === e.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], null == (l = g && g.display) && (l = J.get(e, "display")), "none" === (u = S.css(e, "display")) && (l ? u = l : (se([e], !0), l = e.style.display || l, u = S.css(e, "display"), se([e]))), ("inline" === u || "inline-block" === u && null != l) && "none" === S.css(e, "float") && (c || (d.done(function () {
                                f.display = l
                            }), null == l && (u = f.display, l = "none" === u ? "" : u)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", d.always(function () {
                                f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2]
                            })), c = !1, p) c || (g ? "hidden" in g && (m = g.hidden) : g = J.access(e, "fxshow", {
                                display: l
                            }), o && (g.hidden = !m), m && se([e], !0), d.done(function () {
                                for (r in m || se([e]), J.remove(e, "fxshow"), p) S.style(e, r, p[r])
                            })), c = st(m ? g[r] : 0, r, d), r in g || (g[r] = c.start, m && (c.end = c.start, c.start = 0))
                    }],
                    prefilter: function (e, t) {
                        t ? ct.prefilters.unshift(e) : ct.prefilters.push(e)
                    }
                }), S.speed = function (e, t, n) {
                    var r = e && "object" === (void 0 === e ? "undefined" : Xt(e)) ? S.extend({}, e) : {
                        complete: n || !n && t || y(e) && e,
                        duration: e,
                        easing: n && t || t && !y(t) && t
                    };
                    return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {
                        y(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue)
                    }, r
                }, S.fn.extend({
                    fadeTo: function (e, t, n, r) {
                        return this.filter(re).css("opacity", 0).show().end().animate({
                            opacity: t
                        }, e, n, r)
                    },
                    animate: function (t, e, n, r) {
                        var i = S.isEmptyObject(t),
                            o = S.speed(e, n, r),
                            a = function () {
                                var e = ct(this, S.extend({}, t), o);
                                (i || J.get(this, "finish")) && e.stop(!0)
                            };
                        return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
                    },
                    stop: function (i, e, o) {
                        var a = function (e) {
                            var t = e.stop;
                            delete e.stop, t(o)
                        };
                        return "string" != typeof i && (o = e, e = i, i = void 0), e && !1 !== i && this.queue(i || "fx", []), this.each(function () {
                            var e = !0,
                                t = null != i && i + "queueHooks",
                                n = S.timers,
                                r = J.get(this);
                            if (t) r[t] && r[t].stop && a(r[t]);
                            else
                                for (t in r) r[t] && r[t].stop && rt.test(t) && a(r[t]);
                            for (t = n.length; t--;) n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
                            !e && o || S.dequeue(this, i)
                        })
                    },
                    finish: function (a) {
                        return !1 !== a && (a = a || "fx"), this.each(function () {
                            var e, t = J.get(this),
                                n = t[a + "queue"],
                                r = t[a + "queueHooks"],
                                i = S.timers,
                                o = n ? n.length : 0;
                            for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
                            for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);
                            delete t.finish
                        })
                    }
                }), S.each(["toggle", "show", "hide"], function (e, r) {
                    var i = S.fn[r];
                    S.fn[r] = function (e, t, n) {
                        return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(at(r, !0), e, t, n)
                    }
                }), S.each({
                    slideDown: at("show"),
                    slideUp: at("hide"),
                    slideToggle: at("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, function (e, r) {
                    S.fn[e] = function (e, t, n) {
                        return this.animate(r, e, t, n)
                    }
                }), S.timers = [], S.fx.tick = function () {
                    var e, t = 0,
                        n = S.timers;
                    for (Qe = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
                    n.length || S.fx.stop(), Qe = void 0
                }, S.fx.timer = function (e) {
                    S.timers.push(e), S.fx.start()
                }, S.fx.interval = 13, S.fx.start = function () {
                    Ke || (Ke = !0, it())
                }, S.fx.stop = function () {
                    Ke = null
                }, S.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    _default: 400
                }, S.fn.delay = function (r, e) {
                    return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) {
                        var n = E.setTimeout(e, r);
                        t.stop = function () {
                            E.clearTimeout(n)
                        }
                    })
                }, et = T.createElement("input"), tt = T.createElement("select").appendChild(T.createElement("option")), et.type = "checkbox", v.checkOn = "" !== et.value, v.optSelected = tt.selected, (et = T.createElement("input")).value = "t", et.type = "radio", v.radioValue = "t" === et.value;
                var lt, ut = S.expr.attrHandle;
                S.fn.extend({
                    attr: function (e, t) {
                        return z(this, S.attr, e, t, 1 < arguments.length)
                    },
                    removeAttr: function (e) {
                        return this.each(function () {
                            S.removeAttr(this, e)
                        })
                    }
                }), S.extend({
                    attr: function (e, t, n) {
                        var r, i, o = e.nodeType;
                        if (3 !== o && 8 !== o && 2 !== o) return void 0 === e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? lt : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r)
                    },
                    attrHooks: {
                        type: {
                            set: function (e, t) {
                                if (!v.radioValue && "radio" === t && A(e, "input")) {
                                    var n = e.value;
                                    return e.setAttribute("type", t), n && (e.value = n), t
                                }
                            }
                        }
                    },
                    removeAttr: function (e, t) {
                        var n, r = 0,
                            i = t && t.match(j);
                        if (i && 1 === e.nodeType)
                            for (; n = i[r++];) e.removeAttribute(n)
                    }
                }), lt = {
                    set: function (e, t, n) {
                        return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n
                    }
                }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) {
                    var a = ut[t] || S.find.attr;
                    ut[t] = function (e, t, n) {
                        var r, i, o = t.toLowerCase();
                        return n || (i = ut[o], ut[o] = r, r = null != a(e, t, n) ? o : null, ut[o] = i), r
                    }
                });
                var ht = /^(?:input|select|textarea|button)$/i,
                    dt = /^(?:a|area)$/i;

                function pt(e) {
                    return (e.match(j) || []).join(" ")
                }

                function ft(e) {
                    return e.getAttribute && e.getAttribute("class") || ""
                }

                function mt(e) {
                    return Array.isArray(e) ? e : "string" == typeof e && e.match(j) || []
                }
                S.fn.extend({
                    prop: function (e, t) {
                        return z(this, S.prop, e, t, 1 < arguments.length)
                    },
                    removeProp: function (e) {
                        return this.each(function () {
                            delete this[S.propFix[e] || e]
                        })
                    }
                }), S.extend({
                    prop: function (e, t, n) {
                        var r, i, o = e.nodeType;
                        if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
                    },
                    propHooks: {
                        tabIndex: {
                            get: function (e) {
                                var t = S.find.attr(e, "tabindex");
                                return t ? parseInt(t, 10) : ht.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1
                            }
                        }
                    },
                    propFix: {
                        for: "htmlFor",
                        class: "className"
                    }
                }), v.optSelected || (S.propHooks.selected = {
                    get: function (e) {
                        var t = e.parentNode;
                        return t && t.parentNode && t.parentNode.selectedIndex, null
                    },
                    set: function (e) {
                        var t = e.parentNode;
                        t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
                    }
                }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
                    S.propFix[this.toLowerCase()] = this
                }), S.fn.extend({
                    addClass: function (t) {
                        var e, n, r, i, o, a, s, c = 0;
                        if (y(t)) return this.each(function (e) {
                            S(this).addClass(t.call(this, e, ft(this)))
                        });
                        if ((e = mt(t)).length)
                            for (; n = this[c++];)
                                if (i = ft(n), r = 1 === n.nodeType && " " + pt(i) + " ") {
                                    for (a = 0; o = e[a++];) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                                    i !== (s = pt(r)) && n.setAttribute("class", s)
                                }
                        return this
                    },
                    removeClass: function (t) {
                        var e, n, r, i, o, a, s, c = 0;
                        if (y(t)) return this.each(function (e) {
                            S(this).removeClass(t.call(this, e, ft(this)))
                        });
                        if (!arguments.length) return this.attr("class", "");
                        if ((e = mt(t)).length)
                            for (; n = this[c++];)
                                if (i = ft(n), r = 1 === n.nodeType && " " + pt(i) + " ") {
                                    for (a = 0; o = e[a++];)
                                        for (; - 1 < r.indexOf(" " + o + " ");) r = r.replace(" " + o + " ", " ");
                                    i !== (s = pt(r)) && n.setAttribute("class", s)
                                }
                        return this
                    },
                    toggleClass: function (i, t) {
                        var o = void 0 === i ? "undefined" : Xt(i),
                            a = "string" === o || Array.isArray(i);
                        return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : y(i) ? this.each(function (e) {
                            S(this).toggleClass(i.call(this, e, ft(this), t), t)
                        }) : this.each(function () {
                            var e, t, n, r;
                            if (a)
                                for (t = 0, n = S(this), r = mt(i); e = r[t++];) n.hasClass(e) ? n.removeClass(e) : n.addClass(e);
                            else void 0 !== i && "boolean" !== o || ((e = ft(this)) && J.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : J.get(this, "__className__") || ""))
                        })
                    },
                    hasClass: function (e) {
                        var t, n, r = 0;
                        for (t = " " + e + " "; n = this[r++];)
                            if (1 === n.nodeType && -1 < (" " + pt(ft(n)) + " ").indexOf(t)) return !0;
                        return !1
                    }
                });
                var gt = /\r/g;
                S.fn.extend({
                    val: function (n) {
                        var r, e, i, t = this[0];
                        return arguments.length ? (i = y(n), this.each(function (e) {
                            var t;
                            1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) {
                                return null == e ? "" : e + ""
                            })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t))
                        })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(gt, "") : null == e ? "" : e : void 0
                    }
                }), S.extend({
                    valHooks: {
                        option: {
                            get: function (e) {
                                var t = S.find.attr(e, "value");
                                return null != t ? t : pt(S.text(e))
                            }
                        },
                        select: {
                            get: function (e) {
                                var t, n, r, i = e.options,
                                    o = e.selectedIndex,
                                    a = "select-one" === e.type,
                                    s = a ? null : [],
                                    c = a ? o + 1 : i.length;
                                for (r = o < 0 ? c : a ? o : 0; r < c; r++)
                                    if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
                                        if (t = S(n).val(), a) return t;
                                        s.push(t)
                                    }
                                return s
                            },
                            set: function (e, t) {
                                for (var n, r, i = e.options, o = S.makeArray(t), a = i.length; a--;)((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0);
                                return n || (e.selectedIndex = -1), o
                            }
                        }
                    }
                }), S.each(["radio", "checkbox"], function () {
                    S.valHooks[this] = {
                        set: function (e, t) {
                            if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t)
                        }
                    }, v.checkOn || (S.valHooks[this].get = function (e) {
                        return null === e.getAttribute("value") ? "on" : e.value
                    })
                }), v.focusin = "onfocusin" in E;
                var vt = /^(?:focusinfocus|focusoutblur)$/,
                    yt = function (e) {
                        e.stopPropagation()
                    };
                S.extend(S.event, {
                    trigger: function (e, t, n, r) {
                        var i, o, a, s, c, l, u, h, d = [n || T],
                            p = g.call(e, "type") ? e.type : e,
                            f = g.call(e, "namespace") ? e.namespace.split(".") : [];
                        if (o = h = a = n = n || T, 3 !== n.nodeType && 8 !== n.nodeType && !vt.test(p + S.event.triggered) && (-1 < p.indexOf(".") && (p = (f = p.split(".")).shift(), f.sort()), c = p.indexOf(":") < 0 && "on" + p, (e = e[S.expando] ? e : new S.Event(p, "object" === (void 0 === e ? "undefined" : Xt(e)) && e)).isTrigger = r ? 2 : 3, e.namespace = f.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), u = S.event.special[p] || {}, r || !u.trigger || !1 !== u.trigger.apply(n, t))) {
                            if (!r && !u.noBubble && !_(n)) {
                                for (s = u.delegateType || p, vt.test(s + p) || (o = o.parentNode); o; o = o.parentNode) d.push(o), a = o;
                                a === (n.ownerDocument || T) && d.push(a.defaultView || a.parentWindow || E)
                            }
                            for (i = 0;
                                (o = d[i++]) && !e.isPropagationStopped();) h = o, e.type = 1 < i ? s : u.bindType || p, (l = (J.get(o, "events") || {})[e.type] && J.get(o, "handle")) && l.apply(o, t), (l = c && o[c]) && l.apply && X(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
                            return e.type = p, r || e.isDefaultPrevented() || u._default && !1 !== u._default.apply(d.pop(), t) || !X(n) || c && y(n[p]) && !_(n) && ((a = n[c]) && (n[c] = null), S.event.triggered = p, e.isPropagationStopped() && h.addEventListener(p, yt), n[p](), e.isPropagationStopped() && h.removeEventListener(p, yt), S.event.triggered = void 0, a && (n[c] = a)), e.result
                        }
                    },
                    simulate: function (e, t, n) {
                        var r = S.extend(new S.Event, n, {
                            type: e,
                            isSimulated: !0
                        });
                        S.event.trigger(r, null, t)
                    }
                }), S.fn.extend({
                    trigger: function (e, t) {
                        return this.each(function () {
                            S.event.trigger(e, t, this)
                        })
                    },
                    triggerHandler: function (e, t) {
                        var n = this[0];
                        if (n) return S.event.trigger(e, t, n, !0)
                    }
                }), v.focusin || S.each({
                    focus: "focusin",
                    blur: "focusout"
                }, function (n, r) {
                    var i = function (e) {
                        S.event.simulate(r, e.target, S.event.fix(e))
                    };
                    S.event.special[r] = {
                        setup: function () {
                            var e = this.ownerDocument || this,
                                t = J.access(e, r);
                            t || e.addEventListener(n, i, !0), J.access(e, r, (t || 0) + 1)
                        },
                        teardown: function () {
                            var e = this.ownerDocument || this,
                                t = J.access(e, r) - 1;
                            t ? J.access(e, r, t) : (e.removeEventListener(n, i, !0), J.remove(e, r))
                        }
                    }
                });
                var _t = E.location,
                    xt = Date.now(),
                    bt = /\?/;
                S.parseXML = function (e) {
                    var t;
                    if (!e || "string" != typeof e) return null;
                    try {
                        t = (new E.DOMParser).parseFromString(e, "text/xml")
                    } catch (e) {
                        t = void 0
                    }
                    return t && !t.getElementsByTagName("parsererror").length || S.error("Invalid XML: " + e), t
                };
                var wt = /\[\]$/,
                    Et = /\r?\n/g,
                    Tt = /^(?:submit|button|image|reset|file)$/i,
                    St = /^(?:input|select|textarea|keygen)/i;

                function Mt(n, e, r, i) {
                    var t;
                    if (Array.isArray(e)) S.each(e, function (e, t) {
                        r || wt.test(n) ? i(n, t) : Mt(n + "[" + ("object" === (void 0 === t ? "undefined" : Xt(t)) && null != t ? e : "") + "]", t, r, i)
                    });
                    else if (r || "object" !== b(e)) i(n, e);
                    else
                        for (t in e) Mt(n + "[" + t + "]", e[t], r, i)
                }
                S.param = function (e, t) {
                    var n, r = [],
                        i = function (e, t) {
                            var n = y(t) ? t() : t;
                            r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
                        };
                    if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () {
                        i(this.name, this.value)
                    });
                    else
                        for (n in e) Mt(n, e[n], t, i);
                    return r.join("&")
                }, S.fn.extend({
                    serialize: function () {
                        return S.param(this.serializeArray())
                    },
                    serializeArray: function () {
                        return this.map(function () {
                            var e = S.prop(this, "elements");
                            return e ? S.makeArray(e) : this
                        }).filter(function () {
                            var e = this.type;
                            return this.name && !S(this).is(":disabled") && St.test(this.nodeName) && !Tt.test(e) && (this.checked || !ce.test(e))
                        }).map(function (e, t) {
                            var n = S(this).val();
                            return null == n ? null : Array.isArray(n) ? S.map(n, function (e) {
                                return {
                                    name: t.name,
                                    value: e.replace(Et, "\r\n")
                                }
                            }) : {
                                    name: t.name,
                                    value: n.replace(Et, "\r\n")
                                }
                        }).get()
                    }
                });
                var At = /%20/g,
                    Ct = /#.*$/,
                    Lt = /([?&])_=[^&]*/,
                    Rt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
                    Pt = /^(?:GET|HEAD)$/,
                    Ot = /^\/\//,
                    It = {},
                    Dt = {},
                    jt = "*/".concat("*"),
                    Nt = T.createElement("a");

                function kt(o) {
                    return function (e, t) {
                        "string" != typeof e && (t = e, e = "*");
                        var n, r = 0,
                            i = e.toLowerCase().match(j) || [];
                        if (y(t))
                            for (; n = i[r++];) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t)
                    }
                }

                function Ut(t, i, o, a) {
                    var s = {},
                        c = t === Dt;

                    function l(e) {
                        var r;
                        return s[e] = !0, S.each(t[e] || [], function (e, t) {
                            var n = t(i, o, a);
                            return "string" != typeof n || c || s[n] ? c ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1)
                        }), r
                    }
                    return l(i.dataTypes[0]) || !s["*"] && l("*")
                }

                function Ht(e, t) {
                    var n, r, i = S.ajaxSettings.flatOptions || {};
                    for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
                    return r && S.extend(!0, e, r), e
                }
                Nt.href = _t.href, S.extend({
                    active: 0,
                    lastModified: {},
                    etag: {},
                    ajaxSettings: {
                        url: _t.href,
                        type: "GET",
                        isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(_t.protocol),
                        global: !0,
                        processData: !0,
                        async: !0,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                        accepts: {
                            "*": jt,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },
                        contents: {
                            xml: /\bxml\b/,
                            html: /\bhtml/,
                            json: /\bjson\b/
                        },
                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },
                        converters: {
                            "* text": String,
                            "text html": !0,
                            "text json": JSON.parse,
                            "text xml": S.parseXML
                        },
                        flatOptions: {
                            url: !0,
                            context: !0
                        }
                    },
                    ajaxSetup: function (e, t) {
                        return t ? Ht(Ht(e, S.ajaxSettings), t) : Ht(S.ajaxSettings, e)
                    },
                    ajaxPrefilter: kt(It),
                    ajaxTransport: kt(Dt),
                    ajax: function (e, t) {
                        "object" === (void 0 === e ? "undefined" : Xt(e)) && (t = e, e = void 0), t = t || {};
                        var u, h, d, n, p, r, f, m, i, o, g = S.ajaxSetup({}, t),
                            v = g.context || g,
                            y = g.context && (v.nodeType || v.jquery) ? S(v) : S.event,
                            _ = S.Deferred(),
                            x = S.Callbacks("once memory"),
                            b = g.statusCode || {},
                            a = {},
                            s = {},
                            c = "canceled",
                            w = {
                                readyState: 0,
                                getResponseHeader: function (e) {
                                    var t;
                                    if (f) {
                                        if (!n)
                                            for (n = {}; t = Rt.exec(d);) n[t[1].toLowerCase()] = t[2];
                                        t = n[e.toLowerCase()]
                                    }
                                    return null == t ? null : t
                                },
                                getAllResponseHeaders: function () {
                                    return f ? d : null
                                },
                                setRequestHeader: function (e, t) {
                                    return null == f && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this
                                },
                                overrideMimeType: function (e) {
                                    return null == f && (g.mimeType = e), this
                                },
                                statusCode: function (e) {
                                    var t;
                                    if (e)
                                        if (f) w.always(e[w.status]);
                                        else
                                            for (t in e) b[t] = [b[t], e[t]];
                                    return this
                                },
                                abort: function (e) {
                                    var t = e || c;
                                    return u && u.abort(t), l(0, t), this
                                }
                            };
                        if (_.promise(w), g.url = ((e || g.url || _t.href) + "").replace(Ot, _t.protocol + "//"), g.type = t.method || t.type || g.method || g.type, g.dataTypes = (g.dataType || "*").toLowerCase().match(j) || [""], null == g.crossDomain) {
                            r = T.createElement("a");
                            try {
                                r.href = g.url, r.href = r.href, g.crossDomain = Nt.protocol + "//" + Nt.host != r.protocol + "//" + r.host
                            } catch (e) {
                                g.crossDomain = !0
                            }
                        }
                        if (g.data && g.processData && "string" != typeof g.data && (g.data = S.param(g.data, g.traditional)), Ut(It, g, t, w), f) return w;
                        for (i in (m = S.event && g.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), g.type = g.type.toUpperCase(), g.hasContent = !Pt.test(g.type), h = g.url.replace(Ct, ""), g.hasContent ? g.data && g.processData && 0 === (g.contentType || "").indexOf("application/x-www-form-urlencoded") && (g.data = g.data.replace(At, "+")) : (o = g.url.slice(h.length), g.data && (g.processData || "string" == typeof g.data) && (h += (bt.test(h) ? "&" : "?") + g.data, delete g.data), !1 === g.cache && (h = h.replace(Lt, "$1"), o = (bt.test(h) ? "&" : "?") + "_=" + xt++ + o), g.url = h + o), g.ifModified && (S.lastModified[h] && w.setRequestHeader("If-Modified-Since", S.lastModified[h]), S.etag[h] && w.setRequestHeader("If-None-Match", S.etag[h])), (g.data && g.hasContent && !1 !== g.contentType || t.contentType) && w.setRequestHeader("Content-Type", g.contentType), w.setRequestHeader("Accept", g.dataTypes[0] && g.accepts[g.dataTypes[0]] ? g.accepts[g.dataTypes[0]] + ("*" !== g.dataTypes[0] ? ", " + jt + "; q=0.01" : "") : g.accepts["*"]), g.headers) w.setRequestHeader(i, g.headers[i]);
                        if (g.beforeSend && (!1 === g.beforeSend.call(v, w, g) || f)) return w.abort();
                        if (c = "abort", x.add(g.complete), w.done(g.success), w.fail(g.error), u = Ut(Dt, g, t, w)) {
                            if (w.readyState = 1, m && y.trigger("ajaxSend", [w, g]), f) return w;
                            g.async && 0 < g.timeout && (p = E.setTimeout(function () {
                                w.abort("timeout")
                            }, g.timeout));
                            try {
                                f = !1, u.send(a, l)
                            } catch (e) {
                                if (f) throw e;
                                l(-1, e)
                            }
                        } else l(-1, "No Transport");

                        function l(e, t, n, r) {
                            var i, o, a, s, c, l = t;
                            f || (f = !0, p && E.clearTimeout(p), u = void 0, d = r || "", w.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) {
                                for (var r, i, o, a, s = e.contents, c = e.dataTypes;
                                    "*" === c[0];) c.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                                if (r)
                                    for (i in s)
                                        if (s[i] && s[i].test(r)) {
                                            c.unshift(i);
                                            break
                                        }
                                if (c[0] in n) o = c[0];
                                else {
                                    for (i in n) {
                                        if (!c[0] || e.converters[i + " " + c[0]]) {
                                            o = i;
                                            break
                                        }
                                        a || (a = i)
                                    }
                                    o = o || a
                                }
                                if (o) return o !== c[0] && c.unshift(o), n[o]
                            }(g, w, n)), s = function (e, t, n, r) {
                                var i, o, a, s, c, l = {},
                                    u = e.dataTypes.slice();
                                if (u[1])
                                    for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
                                for (o = u.shift(); o;)
                                    if (e.responseFields[o] && (n[e.responseFields[o]] = t), !c && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), c = o, o = u.shift())
                                        if ("*" === o) o = c;
                                        else if ("*" !== c && c !== o) {
                                            if (!(a = l[c + " " + o] || l["* " + o]))
                                                for (i in l)
                                                    if ((s = i.split(" "))[1] === o && (a = l[c + " " + s[0]] || l["* " + s[0]])) {
                                                        !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], u.unshift(s[1]));
                                                        break
                                                    }
                                            if (!0 !== a)
                                                if (a && e.throws) t = a(t);
                                                else try {
                                                    t = a(t)
                                                } catch (e) {
                                                    return {
                                                        state: "parsererror",
                                                        error: a ? e : "No conversion from " + c + " to " + o
                                                    }
                                                }
                                        }
                                return {
                                    state: "success",
                                    data: t
                                }
                            }(g, s, w, i), i ? (g.ifModified && ((c = w.getResponseHeader("Last-Modified")) && (S.lastModified[h] = c), (c = w.getResponseHeader("etag")) && (S.etag[h] = c)), 204 === e || "HEAD" === g.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), w.status = e, w.statusText = (t || l) + "", i ? _.resolveWith(v, [o, l, w]) : _.rejectWith(v, [w, l, a]), w.statusCode(b), b = void 0, m && y.trigger(i ? "ajaxSuccess" : "ajaxError", [w, g, i ? o : a]), x.fireWith(v, [w, l]), m && (y.trigger("ajaxComplete", [w, g]), --S.active || S.event.trigger("ajaxStop")))
                        }
                        return w
                    },
                    getJSON: function (e, t, n) {
                        return S.get(e, t, n, "json")
                    },
                    getScript: function (e, t) {
                        return S.get(e, void 0, t, "script")
                    }
                }), S.each(["get", "post"], function (e, i) {
                    S[i] = function (e, t, n, r) {
                        return y(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({
                            url: e,
                            type: i,
                            dataType: r,
                            data: t,
                            success: n
                        }, S.isPlainObject(e) && e))
                    }
                }), S._evalUrl = function (e) {
                    return S.ajax({
                        url: e,
                        type: "GET",
                        dataType: "script",
                        cache: !0,
                        async: !1,
                        global: !1,
                        throws: !0
                    })
                }, S.fn.extend({
                    wrapAll: function (e) {
                        var t;
                        return this[0] && (y(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
                            for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                            return e
                        }).append(this)), this
                    },
                    wrapInner: function (n) {
                        return y(n) ? this.each(function (e) {
                            S(this).wrapInner(n.call(this, e))
                        }) : this.each(function () {
                            var e = S(this),
                                t = e.contents();
                            t.length ? t.wrapAll(n) : e.append(n)
                        })
                    },
                    wrap: function (t) {
                        var n = y(t);
                        return this.each(function (e) {
                            S(this).wrapAll(n ? t.call(this, e) : t)
                        })
                    },
                    unwrap: function (e) {
                        return this.parent(e).not("body").each(function () {
                            S(this).replaceWith(this.childNodes)
                        }), this
                    }
                }), S.expr.pseudos.hidden = function (e) {
                    return !S.expr.pseudos.visible(e)
                }, S.expr.pseudos.visible = function (e) {
                    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
                }, S.ajaxSettings.xhr = function () {
                    try {
                        return new E.XMLHttpRequest
                    } catch (e) { }
                };
                var Bt = {
                    0: 200,
                    1223: 204
                },
                    Ft = S.ajaxSettings.xhr();
                v.cors = !!Ft && "withCredentials" in Ft, v.ajax = Ft = !!Ft, S.ajaxTransport(function (i) {
                    var o, a;
                    if (v.cors || Ft && !i.crossDomain) return {
                        send: function (e, t) {
                            var n, r = i.xhr();
                            if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields)
                                for (n in i.xhrFields) r[n] = i.xhrFields[n];
                            for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]);
                            o = function (e) {
                                return function () {
                                    o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
                                        binary: r.response
                                    } : {
                                            text: r.responseText
                                        }, r.getAllResponseHeaders()))
                                }
                            }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () {
                                4 === r.readyState && E.setTimeout(function () {
                                    o && a()
                                })
                            }, o = o("abort");
                            try {
                                r.send(i.hasContent && i.data || null)
                            } catch (e) {
                                if (o) throw e
                            }
                        },
                        abort: function () {
                            o && o()
                        }
                    }
                }), S.ajaxPrefilter(function (e) {
                    e.crossDomain && (e.contents.script = !1)
                }), S.ajaxSetup({
                    accepts: {
                        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /\b(?:java|ecma)script\b/
                    },
                    converters: {
                        "text script": function (e) {
                            return S.globalEval(e), e
                        }
                    }
                }), S.ajaxPrefilter("script", function (e) {
                    void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
                }), S.ajaxTransport("script", function (n) {
                    var r, i;
                    if (n.crossDomain) return {
                        send: function (e, t) {
                            r = S("<script>").prop({
                                charset: n.scriptCharset,
                                src: n.url
                            }).on("load error", i = function (e) {
                                r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type)
                            }), T.head.appendChild(r[0])
                        },
                        abort: function () {
                            i && i()
                        }
                    }
                });
                var zt, Gt = [],
                    Vt = /(=)\?(?=&|$)|\?\?/;
                S.ajaxSetup({
                    jsonp: "callback",
                    jsonpCallback: function () {
                        var e = Gt.pop() || S.expando + "_" + xt++;
                        return this[e] = !0, e
                    }
                }), S.ajaxPrefilter("json jsonp", function (e, t, n) {
                    var r, i, o, a = !1 !== e.jsonp && (Vt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Vt.test(e.data) && "data");
                    if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = y(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Vt, "$1" + r) : !1 !== e.jsonp && (e.url += (bt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
                        return o || S.error(r + " was not called"), o[0]
                    }, e.dataTypes[0] = "json", i = E[r], E[r] = function () {
                        o = arguments
                    }, n.always(function () {
                        void 0 === i ? S(E).removeProp(r) : E[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Gt.push(r)), o && y(i) && i(o[0]), o = i = void 0
                    }), "script"
                }), v.createHTMLDocument = ((zt = T.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === zt.childNodes.length), S.parseHTML = function (e, t, n) {
                    return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (v.createHTMLDocument ? ((r = (t = T.implementation.createHTMLDocument("")).createElement("base")).href = T.location.href, t.head.appendChild(r)) : t = T), o = !n && [], (i = C.exec(e)) ? [t.createElement(i[1])] : (i = ve([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes)));
                    var r, i, o
                }, S.fn.load = function (e, t, n) {
                    var r, i, o, a = this,
                        s = e.indexOf(" ");
                    return -1 < s && (r = pt(e.slice(s)), e = e.slice(0, s)), y(t) ? (n = t, t = void 0) : t && "object" === (void 0 === t ? "undefined" : Xt(t)) && (i = "POST"), 0 < a.length && S.ajax({
                        url: e,
                        type: i || "GET",
                        dataType: "html",
                        data: t
                    }).done(function (e) {
                        o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e)
                    }).always(n && function (e, t) {
                        a.each(function () {
                            n.apply(this, o || [e.responseText, t, e])
                        })
                    }), this
                }, S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
                    S.fn[t] = function (e) {
                        return this.on(t, e)
                    }
                }), S.expr.pseudos.animated = function (t) {
                    return S.grep(S.timers, function (e) {
                        return t === e.elem
                    }).length
                }, S.offset = {
                    setOffset: function (e, t, n) {
                        var r, i, o, a, s, c, l = S.css(e, "position"),
                            u = S(e),
                            h = {};
                        "static" === l && (e.style.position = "relative"), s = u.offset(), o = S.css(e, "top"), c = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + c).indexOf("auto") ? (a = (r = u.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(c) || 0), y(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (h.top = t.top - s.top + a), null != t.left && (h.left = t.left - s.left + i), "using" in t ? t.using.call(e, h) : u.css(h)
                    }
                }, S.fn.extend({
                    offset: function (t) {
                        if (arguments.length) return void 0 === t ? this : this.each(function (e) {
                            S.offset.setOffset(this, t, e)
                        });
                        var e, n, r = this[0];
                        return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
                            top: e.top + n.pageYOffset,
                            left: e.left + n.pageXOffset
                        }) : {
                                top: 0,
                                left: 0
                            } : void 0
                    },
                    position: function () {
                        if (this[0]) {
                            var e, t, n, r = this[0],
                                i = {
                                    top: 0,
                                    left: 0
                                };
                            if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect();
                            else {
                                for (t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position");) e = e.parentNode;
                                e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0))
                            }
                            return {
                                top: t.top - i.top - S.css(r, "marginTop", !0),
                                left: t.left - i.left - S.css(r, "marginLeft", !0)
                            }
                        }
                    },
                    offsetParent: function () {
                        return this.map(function () {
                            for (var e = this.offsetParent; e && "static" === S.css(e, "position");) e = e.offsetParent;
                            return e || ye
                        })
                    }
                }), S.each({
                    scrollLeft: "pageXOffset",
                    scrollTop: "pageYOffset"
                }, function (t, i) {
                    var o = "pageYOffset" === i;
                    S.fn[t] = function (e) {
                        return z(this, function (e, t, n) {
                            var r;
                            if (_(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
                            r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n
                        }, t, e, arguments.length)
                    }
                }), S.each(["top", "left"], function (e, n) {
                    S.cssHooks[n] = Be(v.pixelPosition, function (e, t) {
                        if (t) return t = He(e, n), Ne.test(t) ? S(e).position()[n] + "px" : t
                    })
                }), S.each({
                    Height: "height",
                    Width: "width"
                }, function (a, s) {
                    S.each({
                        padding: "inner" + a,
                        content: s,
                        "": "outer" + a
                    }, function (r, o) {
                        S.fn[o] = function (e, t) {
                            var n = arguments.length && (r || "boolean" != typeof e),
                                i = r || (!0 === e || !0 === t ? "margin" : "border");
                            return z(this, function (e, t, n) {
                                var r;
                                return _(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i)
                            }, s, n ? e : void 0, n)
                        }
                    })
                }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) {
                    S.fn[n] = function (e, t) {
                        return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n)
                    }
                }), S.fn.extend({
                    hover: function (e, t) {
                        return this.mouseenter(e).mouseleave(t || e)
                    }
                }), S.fn.extend({
                    bind: function (e, t, n) {
                        return this.on(e, null, t, n)
                    },
                    unbind: function (e, t) {
                        return this.off(e, null, t)
                    },
                    delegate: function (e, t, n, r) {
                        return this.on(t, e, n, r)
                    },
                    undelegate: function (e, t, n) {
                        return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
                    }
                }), S.proxy = function (e, t) {
                    var n, r, i;
                    if ("string" == typeof t && (n = e[t], t = e, e = n), y(e)) return r = s.call(arguments, 2), (i = function () {
                        return e.apply(t || this, r.concat(s.call(arguments)))
                    }).guid = e.guid = e.guid || S.guid++ , i
                }, S.holdReady = function (e) {
                    e ? S.readyWait++ : S.ready(!0)
                }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = y, S.isWindow = _, S.camelCase = W, S.type = b, S.now = Date.now, S.isNumeric = function (e) {
                    var t = S.type(e);
                    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
                }, "function" == typeof define && define.amd && define("jquery", [], function () {
                    return S
                });
                var qt = E.jQuery,
                    Wt = E.$;
                return S.noConflict = function (e) {
                    return E.$ === S && (E.$ = Wt), e && E.jQuery === S && (E.jQuery = qt), S
                }, e || (E.jQuery = E.$ = S), S
            }, "object" === (void 0 === t ? "undefined" : Xt(t)) && "object" === Xt(t.exports) ? t.exports = r.document ? i(r, !0) : function (e) {
                if (!e.document) throw new Error("jQuery requires a window with a document");
                return i(e)
            } : i(r)
        }, {}],
       // three module
        6: [function (e, t, n) {
            "use strict";
            Object.defineProperty(n, "__esModule", {
                value: !0
            });
            var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            };

            function i() { }
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e
            }), void 0 === Math.sign && (Math.sign = function (e) {
                return e < 0 ? -1 : 0 < e ? 1 : +e
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function () {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function (e) {
                if (null == e) throw new TypeError("Cannot convert undefined or null to object");
                for (var t = Object(e), n = 1; n < arguments.length; n++) {
                    var r = arguments[n];
                    if (null != r)
                        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
                }
                return t
            }), Object.assign(i.prototype, {
                addEventListener: function (e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                },
                hasEventListener: function (e, t) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                },
                removeEventListener: function (e, t) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners[e];
                        if (void 0 !== n) {
                            var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function (e) {
                    if (void 0 !== this._listeners) {
                        var t = this._listeners[e.type];
                        if (void 0 !== t) {
                            e.target = this;
                            for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e)
                        }
                    }
                }
            });
            var o, a, u, h, s, c, l, d, p, f, m, g, v, y, _, x, b, w, E, T, G = 0,
                V = 1,
                q = 2,
                k = 1,
                U = 2,
                j = 0,
                J = 1,
                Z = 2,
                Se = 0,
                S = 2,
                W = 0,
                X = 1,
                Y = 2,
                $ = 3,
                Q = 4,
                K = 5,
                M = 100,
                A = 101,
                C = 102,
                L = 103,
                R = 104,
                P = 200,
                O = 201,
                I = 202,
                D = 203,
                N = 204,
                H = 205,
                B = 206,
                F = 207,
                z = 208,
                ee = 209,
                te = 210,
                ne = 0,
                re = 1,
                ie = 2,
                oe = 3,
                ae = 4,
                se = 5,
                ce = 6,
                le = 7,
                ue = 0,
                he = 1,
                de = 2,
                pe = 0,
                Me = 1,
                fe = 2,
                me = 3,
                ge = 4,
                ve = 301,
                ye = 302,
                _e = 303,
                xe = 304,
                be = 305,
                we = 306,
                Ee = 307,
                Te = 1e3,
                Ae = 1001,
                Ce = 1002,
                Le = 1003,
                Re = 1004,
                Pe = 1005,
                Oe = 1006,
                Ie = 1007,
                De = 1008,
                je = 1009,
                Ne = 1010,
                ke = 1011,
                Ue = 1012,
                He = 1013,
                Be = 1014,
                Fe = 1015,
                ze = 1016,
                Ge = 1017,
                Ve = 1018,
                qe = 1019,
                We = 1020,
                Xe = 1021,
                Ye = 1022,
                Je = 1023,
                Ze = 1024,
                $e = 1025,
                Qe = Je,
                Ke = 1026,
                et = 1027,
                tt = 33776,
                nt = 33777,
                rt = 33778,
                it = 33779,
                ot = 35840,
                at = 35841,
                st = 35842,
                ct = 35843,
                lt = 36196,
                ut = 37808,
                ht = 37809,
                dt = 37810,
                pt = 37811,
                ft = 37812,
                mt = 37813,
                gt = 37814,
                vt = 37815,
                yt = 37816,
                _t = 37817,
                xt = 37818,
                bt = 37819,
                wt = 37820,
                Et = 37821,
                Tt = 0,
                St = 3e3,
                Mt = 3001,
                At = 3007,
                Ct = 3002,
                Lt = 3004,
                Rt = 3005,
                Pt = 3006,
                Ot = 3200,
                It = 3201,
                Dt = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function () {
                        for (var i = [], e = 0; e < 256; e++) i[e] = (e < 16 ? "0" : "") + e.toString(16);
                        return function () {
                            var e = 4294967295 * Math.random() | 0,
                                t = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0;
                            return (i[255 & e] + i[e >> 8 & 255] + i[e >> 16 & 255] + i[e >> 24 & 255] + "-" + i[255 & t] + i[t >> 8 & 255] + "-" + i[t >> 16 & 15 | 64] + i[t >> 24 & 255] + "-" + i[63 & n | 128] + i[n >> 8 & 255] + "-" + i[n >> 16 & 255] + i[n >> 24 & 255] + i[255 & r] + i[r >> 8 & 255] + i[r >> 16 & 255] + i[r >> 24 & 255]).toUpperCase()
                        }
                    }(),
                    clamp: function (e, t, n) {
                        return Math.max(t, Math.min(n, e))
                    },
                    euclideanModulo: function (e, t) {
                        return (e % t + t) % t
                    },
                    mapLinear: function (e, t, n, r, i) {
                        return r + (e - t) * (i - r) / (n - t)
                    },
                    lerp: function (e, t, n) {
                        return (1 - n) * e + n * t
                    },
                    smoothstep: function (e, t, n) {
                        return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                    },
                    smootherstep: function (e, t, n) {
                        return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                    },
                    randInt: function (e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1))
                    },
                    randFloat: function (e, t) {
                        return e + Math.random() * (t - e)
                    },
                    randFloatSpread: function (e) {
                        return e * (.5 - Math.random())
                    },
                    degToRad: function (e) {
                        return e * Dt.DEG2RAD
                    },
                    radToDeg: function (e) {
                        return e * Dt.RAD2DEG
                    },
                    isPowerOfTwo: function (e) {
                        return 0 == (e & e - 1) && 0 !== e
                    },
                    ceilPowerOfTwo: function (e) {
                        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                    },
                    floorPowerOfTwo: function (e) {
                        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                    }
                };

            function jt(e, t) {
                this.x = e || 0, this.y = t || 0
            }

            function Nt() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function kt(e, t, n, r) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
            }

            function Ut(e, t, n) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0
            }

            function Ht() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.defineProperties(jt.prototype, {
                width: {
                    get: function () {
                        return this.x
                    },
                    set: function (e) {
                        this.x = e
                    }
                },
                height: {
                    get: function () {
                        return this.y
                    },
                    set: function (e) {
                        this.y = e
                    }
                }
            }), Object.assign(jt.prototype, {
                isVector2: !0,
                set: function (e, t) {
                    return this.x = e, this.y = t, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                },
                multiply: function (e) {
                    return this.x *= e.x, this.y *= e.y, this
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this
                },
                divide: function (e) {
                    return this.x /= e.x, this.y /= e.y, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                applyMatrix3: function (e) {
                    var t = this.x,
                        n = this.y,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                },
                clampScalar: (o = new jt, a = new jt, function (e, t) {
                    return o.set(e, e), a.set(t, t), this.clamp(o, a)
                }),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function () {
                    var e = Math.atan2(this.y, this.x);
                    return e < 0 && (e += 2 * Math.PI), e
                },
                distanceTo: function (e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function (e) {
                    var t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                },
                manhattanDistanceTo: function (e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                },
                rotateAround: function (e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = this.x - e.x,
                        o = this.y - e.y;
                    return this.x = i * n - o * r + e.x, this.y = i * r + o * n + e.y, this
                }
            }), Object.assign(Nt.prototype, {
                isMatrix4: !0,
                set: function (e, t, n, r, i, o, a, s, c, l, u, h, d, p, f, m) {
                    var g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                },
                identity: function () {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function () {
                    return (new Nt).fromArray(this.elements)
                },
                copy: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                },
                copyPosition: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                },
                extractBasis: function (e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function (e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: (p = new Ut, function (e) {
                    var t = this.elements,
                        n = e.elements,
                        r = 1 / p.setFromMatrixColumn(e, 0).length(),
                        i = 1 / p.setFromMatrixColumn(e, 1).length(),
                        o = 1 / p.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, this
                }),
                makeRotationFromEuler: function (e) {
                    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z,
                        o = Math.cos(n),
                        a = Math.sin(n),
                        s = Math.cos(r),
                        c = Math.sin(r),
                        l = Math.cos(i),
                        u = Math.sin(i);
                    if ("XYZ" === e.order) {
                        var h = o * l,
                            d = o * u,
                            p = a * l,
                            f = a * u;
                        t[0] = s * l, t[4] = -s * u, t[8] = c, t[1] = d + p * c, t[5] = h - f * c, t[9] = -a * s, t[2] = f - h * c, t[6] = p + d * c, t[10] = o * s
                    } else if ("YXZ" === e.order) {
                        var m = s * l,
                            g = s * u,
                            v = c * l,
                            y = c * u;
                        t[0] = m + y * a, t[4] = v * a - g, t[8] = o * c, t[1] = o * u, t[5] = o * l, t[9] = -a, t[2] = g * a - v, t[6] = y + m * a, t[10] = o * s
                    } else if ("ZXY" === e.order) {
                        m = s * l, g = s * u, v = c * l, y = c * u;
                        t[0] = m - y * a, t[4] = -o * u, t[8] = v + g * a, t[1] = g + v * a, t[5] = o * l, t[9] = y - m * a, t[2] = -o * c, t[6] = a, t[10] = o * s
                    } else if ("ZYX" === e.order) {
                        h = o * l, d = o * u, p = a * l, f = a * u;
                        t[0] = s * l, t[4] = p * c - d, t[8] = h * c + f, t[1] = s * u, t[5] = f * c + h, t[9] = d * c - p, t[2] = -c, t[6] = a * s, t[10] = o * s
                    } else if ("YZX" === e.order) {
                        var _ = o * s,
                            x = o * c,
                            b = a * s,
                            w = a * c;
                        t[0] = s * l, t[4] = w - _ * u, t[8] = b * u + x, t[1] = u, t[5] = o * l, t[9] = -a * l, t[2] = -c * l, t[6] = x * u + b, t[10] = _ - w * u
                    } else if ("XZY" === e.order) {
                        _ = o * s, x = o * c, b = a * s, w = a * c;
                        t[0] = s * l, t[4] = -u, t[8] = c * l, t[1] = _ * u + w, t[5] = o * l, t[9] = x * u - b, t[2] = b * u - x, t[6] = a * l, t[10] = w * u + _
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                makeRotationFromQuaternion: function (e) {
                    var t = this.elements,
                        n = e._x,
                        r = e._y,
                        i = e._z,
                        o = e._w,
                        a = n + n,
                        s = r + r,
                        c = i + i,
                        l = n * a,
                        u = n * s,
                        h = n * c,
                        d = r * s,
                        p = r * c,
                        f = i * c,
                        m = o * a,
                        g = o * s,
                        v = o * c;
                    return t[0] = 1 - (d + f), t[4] = u - v, t[8] = h + g, t[1] = u + v, t[5] = 1 - (l + f), t[9] = p - m, t[2] = h - g, t[6] = p + m, t[10] = 1 - (l + d), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                lookAt: (c = new Ut, l = new Ut, d = new Ut, function (e, t, n) {
                    var r = this.elements;
                    return d.subVectors(e, t), 0 === d.lengthSq() && (d.z = 1), d.normalize(), c.crossVectors(n, d), 0 === c.lengthSq() && (1 === Math.abs(n.z) ? d.x += 1e-4 : d.z += 1e-4, d.normalize(), c.crossVectors(n, d)), c.normalize(), l.crossVectors(d, c), r[0] = c.x, r[4] = l.x, r[8] = d.x, r[1] = c.y, r[5] = l.y, r[9] = d.y, r[2] = c.z, r[6] = l.z, r[10] = d.z, this
                }),
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function (e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        c = n[12],
                        l = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        g = n[14],
                        v = n[3],
                        y = n[7],
                        _ = n[11],
                        x = n[15],
                        b = r[0],
                        w = r[4],
                        E = r[8],
                        T = r[12],
                        S = r[1],
                        M = r[5],
                        A = r[9],
                        C = r[13],
                        L = r[2],
                        R = r[6],
                        P = r[10],
                        O = r[14],
                        I = r[3],
                        D = r[7],
                        j = r[11],
                        N = r[15];
                    return i[0] = o * b + a * S + s * L + c * I, i[4] = o * w + a * M + s * R + c * D, i[8] = o * E + a * A + s * P + c * j, i[12] = o * T + a * C + s * O + c * N, i[1] = l * b + u * S + h * L + d * I, i[5] = l * w + u * M + h * R + d * D, i[9] = l * E + u * A + h * P + d * j, i[13] = l * T + u * C + h * O + d * N, i[2] = p * b + f * S + m * L + g * I, i[6] = p * w + f * M + m * R + g * D, i[10] = p * E + f * A + m * P + g * j, i[14] = p * T + f * C + m * O + g * N, i[3] = v * b + y * S + _ * L + x * I, i[7] = v * w + y * M + _ * R + x * D, i[11] = v * E + y * A + _ * P + x * j, i[15] = v * T + y * C + _ * O + x * N, this
                },
                multiplyScalar: function (e) {
                    var t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                },
                applyToBufferAttribute: (s = new Ut, function (e) {
                    for (var t = 0, n = e.count; t < n; t++) s.x = e.getX(t), s.y = e.getY(t), s.z = e.getZ(t), s.applyMatrix4(this), e.setXYZ(t, s.x, s.y, s.z);
                    return e
                }),
                determinant: function () {
                    var e = this.elements,
                        t = e[0],
                        n = e[4],
                        r = e[8],
                        i = e[12],
                        o = e[1],
                        a = e[5],
                        s = e[9],
                        c = e[13],
                        l = e[2],
                        u = e[6],
                        h = e[10],
                        d = e[14];
                    return e[3] * (+i * s * u - r * c * u - i * a * h + n * c * h + r * a * d - n * s * d) + e[7] * (+t * s * d - t * c * h + i * o * h - r * o * d + r * c * l - i * s * l) + e[11] * (+t * c * u - t * a * d - i * o * u + n * o * d + i * a * l - n * c * l) + e[15] * (-r * a * l - t * s * u + t * a * h + r * o * u - n * o * h + n * s * l)
                },
                transpose: function () {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                },
                setPosition: function (e) {
                    var t = this.elements;
                    return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
                },
                getInverse: function (e, t) {
                    var n = this.elements,
                        r = e.elements,
                        i = r[0],
                        o = r[1],
                        a = r[2],
                        s = r[3],
                        c = r[4],
                        l = r[5],
                        u = r[6],
                        h = r[7],
                        d = r[8],
                        p = r[9],
                        f = r[10],
                        m = r[11],
                        g = r[12],
                        v = r[13],
                        y = r[14],
                        _ = r[15],
                        x = p * y * h - v * f * h + v * u * m - l * y * m - p * u * _ + l * f * _,
                        b = g * f * h - d * y * h - g * u * m + c * y * m + d * u * _ - c * f * _,
                        w = d * v * h - g * p * h + g * l * m - c * v * m - d * l * _ + c * p * _,
                        E = g * p * u - d * v * u - g * l * f + c * v * f + d * l * y - c * p * y,
                        T = i * x + o * b + a * w + s * E;
                    if (0 === T) {
                        var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === t) throw new Error(S);
                        return console.warn(S), this.identity()
                    }
                    var M = 1 / T;
                    return n[0] = x * M, n[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * _ - o * f * _) * M, n[2] = (l * y * s - v * u * s + v * a * h - o * y * h - l * a * _ + o * u * _) * M, n[3] = (p * u * s - l * f * s - p * a * h + o * f * h + l * a * m - o * u * m) * M, n[4] = b * M, n[5] = (d * y * s - g * f * s + g * a * m - i * y * m - d * a * _ + i * f * _) * M, n[6] = (g * u * s - c * y * s - g * a * h + i * y * h + c * a * _ - i * u * _) * M, n[7] = (c * f * s - d * u * s + d * a * h - i * f * h - c * a * m + i * u * m) * M, n[8] = w * M, n[9] = (g * p * s - d * v * s - g * o * m + i * v * m + d * o * _ - i * p * _) * M, n[10] = (c * v * s - g * l * s + g * o * h - i * v * h - c * o * _ + i * l * _) * M, n[11] = (d * l * s - c * p * s - d * o * h + i * p * h + c * o * m - i * l * m) * M, n[12] = E * M, n[13] = (d * v * a - g * p * a + g * o * f - i * v * f - d * o * y + i * p * y) * M, n[14] = (g * l * a - c * v * a - g * o * u + i * v * u + c * o * y - i * l * y) * M, n[15] = (c * p * a - d * l * a + d * o * u - i * p * u - c * o * f + i * l * f) * M, this
                },
                scale: function (e) {
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z;
                    return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                },
                getMaxScaleOnAxis: function () {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, r))
                },
                makeTranslation: function (e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function (e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 - n,
                        o = e.x,
                        a = e.y,
                        s = e.z,
                        c = i * o,
                        l = i * a;
                    return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, l * a + n, l * s - r * o, 0, c * s - r * a, l * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function (e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function (e, t, n) {
                    return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
                },
                compose: function (e, t, n) {
                    return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this
                },
                decompose: (u = new Ut, h = new Nt, function (e, t, n) {
                    var r = this.elements,
                        i = u.set(r[0], r[1], r[2]).length(),
                        o = u.set(r[4], r[5], r[6]).length(),
                        a = u.set(r[8], r[9], r[10]).length();
                    this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], h.copy(this);
                    var s = 1 / i,
                        c = 1 / o,
                        l = 1 / a;
                    return h.elements[0] *= s, h.elements[1] *= s, h.elements[2] *= s, h.elements[4] *= c, h.elements[5] *= c, h.elements[6] *= c, h.elements[8] *= l, h.elements[9] *= l, h.elements[10] *= l, t.setFromRotationMatrix(h), n.x = i, n.y = o, n.z = a, this
                }),
                makePerspective: function (e, t, n, r, i, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * i / (t - e),
                        c = 2 * i / (n - r),
                        l = (t + e) / (t - e),
                        u = (n + r) / (n - r),
                        h = -(o + i) / (o - i),
                        d = -2 * o * i / (o - i);
                    return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function (e, t, n, r, i, o) {
                    var a = this.elements,
                        s = 1 / (t - e),
                        c = 1 / (n - r),
                        l = 1 / (o - i),
                        u = (t + e) * s,
                        h = (n + r) * c,
                        d = (o + i) * l;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function (e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function (e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function (e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }), Object.assign(kt, {
                slerp: function (e, t, n, r) {
                    return n.copy(e).slerp(t, r)
                },
                slerpFlat: function (e, t, n, r, i, o, a) {
                    var s = n[r + 0],
                        c = n[r + 1],
                        l = n[r + 2],
                        u = n[r + 3],
                        h = i[o + 0],
                        d = i[o + 1],
                        p = i[o + 2],
                        f = i[o + 3];
                    if (u !== f || s !== h || c !== d || l !== p) {
                        var m = 1 - a,
                            g = s * h + c * d + l * p + u * f,
                            v = 0 <= g ? 1 : -1,
                            y = 1 - g * g;
                        if (y > Number.EPSILON) {
                            var _ = Math.sqrt(y),
                                x = Math.atan2(_, g * v);
                            m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                        }
                        var b = a * v;
                        if (s = s * m + h * b, c = c * m + d * b, l = l * m + p * b, u = u * m + f * b, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                            s *= w, c *= w, l *= w, u *= w
                        }
                    }
                    e[t] = s, e[t + 1] = c, e[t + 2] = l, e[t + 3] = u
                }
            }), Object.defineProperties(kt.prototype, {
                x: {
                    get: function () {
                        return this._x
                    },
                    set: function (e) {
                        this._x = e, this.onChangeCallback()
                    }
                },
                y: {
                    get: function () {
                        return this._y
                    },
                    set: function (e) {
                        this._y = e, this.onChangeCallback()
                    }
                },
                z: {
                    get: function () {
                        return this._z
                    },
                    set: function (e) {
                        this._z = e, this.onChangeCallback()
                    }
                },
                w: {
                    get: function () {
                        return this._w
                    },
                    set: function (e) {
                        this._w = e, this.onChangeCallback()
                    }
                }
            }), Object.assign(kt.prototype, {
                set: function (e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._w = r, this.onChangeCallback(), this
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function (e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
                },
                setFromEuler: function (e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        o = e.order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(n / 2),
                        l = a(r / 2),
                        u = a(i / 2),
                        h = s(n / 2),
                        d = s(r / 2),
                        p = s(i / 2);
                    return "XYZ" === o ? (this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p) : "YXZ" === o ? (this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p) : "ZXY" === o ? (this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p) : "ZYX" === o ? (this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p) : "YZX" === o ? (this._x = h * l * u + c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u - h * d * p) : "XZY" === o && (this._x = h * l * u - c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u + h * d * p), !1 !== t && this.onChangeCallback(), this
                },
                setFromAxisAngle: function (e, t) {
                    var n = t / 2,
                        r = Math.sin(n);
                    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function (e) {
                    var t, n = e.elements,
                        r = n[0],
                        i = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        c = n[9],
                        l = n[2],
                        u = n[6],
                        h = n[10],
                        d = r + s + h;
                    return 0 < d ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (u - c) * t, this._y = (o - l) * t, this._z = (a - i) * t) : s < r && h < r ? (t = 2 * Math.sqrt(1 + r - s - h), this._w = (u - c) / t, this._x = .25 * t, this._y = (i + a) / t, this._z = (o + l) / t) : h < s ? (t = 2 * Math.sqrt(1 + s - r - h), this._w = (o - l) / t, this._x = (i + a) / t, this._y = .25 * t, this._z = (c + u) / t) : (t = 2 * Math.sqrt(1 + h - r - s), this._w = (a - i) / t, this._x = (o + l) / t, this._y = (c + u) / t, this._z = .25 * t), this.onChangeCallback(), this
                },
                setFromUnitVectors: (m = new Ut, function (e, t) {
                    return void 0 === m && (m = new Ut), (f = e.dot(t) + 1) < 1e-6 ? (f = 0, Math.abs(e.x) > Math.abs(e.z) ? m.set(-e.y, e.x, 0) : m.set(0, -e.z, e.y)) : m.crossVectors(e, t), this._x = m.x, this._y = m.y, this._z = m.z, this._w = f, this.normalize()
                }),
                inverse: function () {
                    return this.conjugate()
                },
                conjugate: function () {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function (e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                },
                lengthSq: function () {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function () {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function () {
                    var e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this
                },
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyQuaternions(e, this)
                },
                multiplyQuaternions: function (e, t) {
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        o = e._w,
                        a = t._x,
                        s = t._y,
                        c = t._z,
                        l = t._w;
                    return this._x = n * l + o * a + r * c - i * s, this._y = r * l + o * s + i * a - n * c, this._z = i * l + o * c + n * s - r * a, this._w = o * l - n * a - r * s - i * c, this.onChangeCallback(), this
                },
                slerp: function (e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        r = this._y,
                        i = this._z,
                        o = this._w,
                        a = o * e._w + n * e._x + r * e._y + i * e._z;
                    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), 1 <= a) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                    var s = Math.sqrt(1 - a * a);
                    if (Math.abs(s) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (n + this._x), this._y = .5 * (r + this._y), this._z = .5 * (i + this._z), this;
                    var c = Math.atan2(s, a),
                        l = Math.sin((1 - t) * c) / s,
                        u = Math.sin(t * c) / s;
                    return this._w = o * l + this._w * u, this._x = n * l + this._x * u, this._y = r * l + this._y * u, this._z = i * l + this._z * u, this.onChangeCallback(), this
                },
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                },
                onChange: function (e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function () { }
            }), Object.assign(Ut.prototype, {
                isVector3: !0,
                set: function (e, t, n) {
                    return this.x = e, this.y = t, this.z = n, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this.z = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setZ: function (e) {
                    return this.z = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this.z += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                },
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                },
                multiplyVectors: function (e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                },
                applyEuler: (E = new kt, function (e) {
                    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(E.setFromEuler(e))
                }),
                applyAxisAngle: (w = new kt, function (e, t) {
                    return this.applyQuaternion(w.setFromAxisAngle(e, t))
                }),
                applyMatrix3: function (e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                },
                applyMatrix4: function (e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements,
                        o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o, this
                },
                applyQuaternion: function (e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.x,
                        o = e.y,
                        a = e.z,
                        s = e.w,
                        c = s * t + o * r - a * n,
                        l = s * n + a * t - i * r,
                        u = s * r + i * n - o * t,
                        h = -i * t - o * n - a * r;
                    return this.x = c * s + h * -i + l * -a - u * -o, this.y = l * s + h * -o + u * -i - c * -a, this.z = u * s + h * -a + c * -o - l * -i, this
                },
                project: (b = new Nt, function (e) {
                    return b.multiplyMatrices(e.projectionMatrix, b.getInverse(e.matrixWorld)), this.applyMatrix4(b)
                }),
                unproject: (x = new Nt, function (e) {
                    return x.multiplyMatrices(e.matrixWorld, x.getInverse(e.projectionMatrix)), this.applyMatrix4(x)
                }),
                transformDirection: function (e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                },
                divide: function (e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                },
                clampScalar: (y = new Ut, _ = new Ut, function (e, t) {
                    return y.set(e, e, e), _.set(t, t, t), this.clamp(y, _)
                }),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                cross: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                },
                crossVectors: function (e, t) {
                    var n = e.x,
                        r = e.y,
                        i = e.z,
                        o = t.x,
                        a = t.y,
                        s = t.z;
                    return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
                },
                projectOnVector: function (e) {
                    var t = e.dot(this) / e.lengthSq();
                    return this.copy(e).multiplyScalar(t)
                },
                projectOnPlane: (v = new Ut, function (e) {
                    return v.copy(this).projectOnVector(e), this.sub(v)
                }),
                reflect: (g = new Ut, function (e) {
                    return this.sub(g.copy(e).multiplyScalar(2 * this.dot(e)))
                }),
                angleTo: function (e) {
                    var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
                    return Math.acos(Dt.clamp(t, -1, 1))
                },
                distanceTo: function (e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function (e) {
                    var t = this.x - e.x,
                        n = this.y - e.y,
                        r = this.z - e.z;
                    return t * t + n * n + r * r
                },
                manhattanDistanceTo: function (e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                },
                setFromSpherical: function (e) {
                    var t = Math.sin(e.phi) * e.radius;
                    return this.x = t * Math.sin(e.theta), this.y = Math.cos(e.phi) * e.radius, this.z = t * Math.cos(e.theta), this
                },
                setFromCylindrical: function (e) {
                    return this.x = e.radius * Math.sin(e.theta), this.y = e.y, this.z = e.radius * Math.cos(e.theta), this
                },
                setFromMatrixPosition: function (e) {
                    var t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                },
                setFromMatrixScale: function (e) {
                    var t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = r, this
                },
                setFromMatrixColumn: function (e, t) {
                    return this.fromArray(e.elements, 4 * t)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
            }), Object.assign(Ht.prototype, {
                isMatrix3: !0,
                set: function (e, t, n, r, i, o, a, s, c) {
                    var l = this.elements;
                    return l[0] = e, l[1] = r, l[2] = a, l[3] = t, l[4] = i, l[5] = s, l[6] = n, l[7] = o, l[8] = c, this
                },
                identity: function () {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function () {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                },
                setFromMatrix4: function (e) {
                    var t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                },
                applyToBufferAttribute: (T = new Ut, function (e) {
                    for (var t = 0, n = e.count; t < n; t++) T.x = e.getX(t), T.y = e.getY(t), T.z = e.getZ(t), T.applyMatrix3(this), e.setXYZ(t, T.x, T.y, T.z);
                    return e
                }),
                multiply: function (e) {
                    return this.multiplyMatrices(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function (e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[3],
                        s = n[6],
                        c = n[1],
                        l = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = r[0],
                        m = r[3],
                        g = r[6],
                        v = r[1],
                        y = r[4],
                        _ = r[7],
                        x = r[2],
                        b = r[5],
                        w = r[8];
                    return i[0] = o * f + a * v + s * x, i[3] = o * m + a * y + s * b, i[6] = o * g + a * _ + s * w, i[1] = c * f + l * v + u * x, i[4] = c * m + l * y + u * b, i[7] = c * g + l * _ + u * w, i[2] = h * f + d * v + p * x, i[5] = h * m + d * y + p * b, i[8] = h * g + d * _ + p * w, this
                },
                multiplyScalar: function (e) {
                    var t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                },
                determinant: function () {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        o = e[4],
                        a = e[5],
                        s = e[6],
                        c = e[7],
                        l = e[8];
                    return t * o * l - t * a * c - n * i * l + n * a * s + r * i * c - r * o * s
                },
                getInverse: function (e, t) {
                    e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = e.elements,
                        r = this.elements,
                        i = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4],
                        l = n[5],
                        u = n[6],
                        h = n[7],
                        d = n[8],
                        p = d * c - l * h,
                        f = l * u - d * s,
                        m = h * s - c * u,
                        g = i * p + o * f + a * m;
                    if (0 === g) {
                        var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === t) throw new Error(v);
                        return console.warn(v), this.identity()
                    }
                    var y = 1 / g;
                    return r[0] = p * y, r[1] = (a * h - d * o) * y, r[2] = (l * o - a * c) * y, r[3] = f * y, r[4] = (d * i - a * u) * y, r[5] = (a * s - l * i) * y, r[6] = m * y, r[7] = (o * u - h * i) * y, r[8] = (c * i - o * s) * y, this
                },
                transpose: function () {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                },
                getNormalMatrix: function (e) {
                    return this.setFromMatrix4(e).getInverse(this).transpose()
                },
                transposeIntoArray: function (e) {
                    var t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                },
                setUvTransform: function (e, t, n, r, i, o, a) {
                    var s = Math.cos(i),
                        c = Math.sin(i);
                    this.set(n * s, n * c, -n * (s * o + c * a) + o + e, -r * c, r * s, -r * (-c * o + s * a) + a + t, 0, 0, 1)
                },
                scale: function (e, t) {
                    var n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                },
                rotate: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e),
                        r = this.elements,
                        i = r[0],
                        o = r[3],
                        a = r[6],
                        s = r[1],
                        c = r[4],
                        l = r[7];
                    return r[0] = t * i + n * s, r[3] = t * o + n * c, r[6] = t * a + n * l, r[1] = -n * i + t * s, r[4] = -n * o + t * c, r[7] = -n * a + t * l, this
                },
                translate: function (e, t) {
                    var n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                },
                equals: function (e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function (e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function (e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
            });
            var Bt, Ft, zt, Gt, Vt, qt, Wt, Xt, Yt, Jt, Zt, $t, Qt, Kt, en, tn, nn, rn = 0;

            function on(e, t, n, r, i, o, a, s, c, l) {
                Object.defineProperty(this, "id", {
                    value: rn++
                }), this.uuid = Dt.generateUUID(), this.name = "", this.image = void 0 !== e ? e : on.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : on.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : Ae, this.wrapT = void 0 !== r ? r : Ae, this.magFilter = void 0 !== i ? i : Oe, this.minFilter = void 0 !== o ? o : De, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Je, this.type = void 0 !== s ? s : je, this.offset = new jt(0, 0), this.repeat = new jt(1, 1), this.center = new jt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ht, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : St, this.version = 0, this.onUpdate = null
            }

            function an(e, t, n, r) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
            }

            function sn(e, t, n) {
                this.width = e, this.height = t, this.scissor = new an(0, 0, e, t), this.scissorTest = !1, this.viewport = new an(0, 0, e, t), void 0 === (n = n || {}).minFilter && (n.minFilter = Oe), this.texture = new on(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function cn(e, t, n) {
                sn.call(this, e, t, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }

            function ln(e, t, n, r, i, o, a, s, c, l, u, h) {
                on.call(this, null, o, a, s, c, l, r, i, u, h), this.image = {
                    data: e,
                    width: t,
                    height: n
                }, this.magFilter = void 0 !== c ? c : Le, this.minFilter = void 0 !== l ? l : Le, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function un(e, t) {
                this.min = void 0 !== e ? e : new Ut(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Ut(-1 / 0, -1 / 0, -1 / 0)
            }

            function hn(e, t) {
                this.center = void 0 !== e ? e : new Ut, this.radius = void 0 !== t ? t : 0
            }

            function dn(e, t) {
                this.normal = void 0 !== e ? e : new Ut(1, 0, 0), this.constant = void 0 !== t ? t : 0
            }

            function pn(e, t, n, r, i, o) {
                this.planes = [void 0 !== e ? e : new dn, void 0 !== t ? t : new dn, void 0 !== n ? n : new dn, void 0 !== r ? r : new dn, void 0 !== i ? i : new dn, void 0 !== o ? o : new dn]
            }
            on.DEFAULT_IMAGE = void 0, on.DEFAULT_MAPPING = 300, on.prototype = Object.assign(Object.create(i.prototype), {
                constructor: on,
                isTexture: !0,
                updateMatrix: function () {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
                },
                toJSON: function (e) {
                    var t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var r = this.image;
                        void 0 === r.uuid && (r.uuid = Dt.generateUUID()), t || void 0 !== e.images[r.uuid] || (e.images[r.uuid] = {
                            uuid: r.uuid,
                            url: function (e) {
                                var t;
                                if (e instanceof HTMLCanvasElement) t = e;
                                else {
                                    (t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = e.width, t.height = e.height;
                                    var n = t.getContext("2d");
                                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height)
                                }
                                return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                            }(r)
                        }), n.image = r.uuid
                    }
                    return t || (e.textures[this.uuid] = n), n
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function (e) {
                    if (300 === this.mapping) {
                        if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) {
                            case Te:
                                e.x = e.x - Math.floor(e.x);
                                break;
                            case Ae:
                                e.x = e.x < 0 ? 0 : 1;
                                break;
                            case Ce:
                                1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                        }
                        if (e.y < 0 || 1 < e.y) switch (this.wrapT) {
                            case Te:
                                e.y = e.y - Math.floor(e.y);
                                break;
                            case Ae:
                                e.y = e.y < 0 ? 0 : 1;
                                break;
                            case Ce:
                                1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                        }
                        this.flipY && (e.y = 1 - e.y)
                    }
                }
            }), Object.defineProperty(on.prototype, "needsUpdate", {
                set: function (e) {
                    !0 === e && this.version++
                }
            }), Object.assign(an.prototype, {
                isVector4: !0,
                set: function (e, t, n, r) {
                    return this.x = e, this.y = t, this.z = n, this.w = r, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setZ: function (e) {
                    return this.z = e, this
                },
                setW: function (e) {
                    return this.w = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                },
                applyMatrix4: function (e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        o = e.elements;
                    return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                setAxisAngleFromQuaternion: function (e) {
                    this.w = 2 * Math.acos(e.w);
                    var t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                },
                setAxisAngleFromRotationMatrix: function (e) {
                    var t, n, r, i, o = e.elements,
                        a = o[0],
                        s = o[4],
                        c = o[8],
                        l = o[1],
                        u = o[5],
                        h = o[9],
                        d = o[2],
                        p = o[6],
                        f = o[10];
                    if (Math.abs(s - l) < .01 && Math.abs(c - d) < .01 && Math.abs(h - p) < .01) {
                        if (Math.abs(s + l) < .1 && Math.abs(c + d) < .1 && Math.abs(h + p) < .1 && Math.abs(a + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var m = (a + 1) / 2,
                            g = (u + 1) / 2,
                            v = (f + 1) / 2,
                            y = (s + l) / 4,
                            _ = (c + d) / 4,
                            x = (h + p) / 4;
                        return g < m && v < m ? m < .01 ? (n = 0, i = r = .707106781) : (r = y / (n = Math.sqrt(m)), i = _ / n) : v < g ? g < .01 ? (r = 0, i = n = .707106781) : (n = y / (r = Math.sqrt(g)), i = x / r) : v < .01 ? (r = n = .707106781, i = 0) : (n = _ / (i = Math.sqrt(v)), r = x / i), this.set(n, r, i, t), this
                    }
                    var b = Math.sqrt((p - h) * (p - h) + (c - d) * (c - d) + (l - s) * (l - s));
                    return Math.abs(b) < .001 && (b = 1), this.x = (p - h) / b, this.y = (c - d) / b, this.z = (l - s) / b, this.w = Math.acos((a + u + f - 1) / 2), this
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                },
                clampScalar: function (e, t) {
                    return void 0 === Bt && (Bt = new an, Ft = new an), Bt.set(e, e, e, e), Ft.set(t, t, t, t), this.clamp(Bt, Ft)
                },
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
            }), sn.prototype = Object.assign(Object.create(i.prototype), {
                constructor: sn,
                isWebGLRenderTarget: !0,
                setSize: function (e, t) {
                    this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), ((cn.prototype = Object.create(sn.prototype)).constructor = cn).prototype.isWebGLRenderTargetCube = !0, ((ln.prototype = Object.create(on.prototype)).constructor = ln).prototype.isDataTexture = !0, Object.assign(un.prototype, {
                isBox3: !0,
                set: function (e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromArray: function (e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
                        var l = e[s],
                            u = e[s + 1],
                            h = e[s + 2];
                        l < t && (t = l), u < n && (n = u), h < r && (r = h), i < l && (i = l), o < u && (o = u), a < h && (a = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, o, a), this
                },
                setFromBufferAttribute: function (e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.count; s < c; s++) {
                        var l = e.getX(s),
                            u = e.getY(s),
                            h = e.getZ(s);
                        l < t && (t = l), u < n && (n = u), h < r && (r = h), i < l && (i = l), o < u && (o = u), a < h && (a = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, o, a), this
                },
                setFromPoints: function (e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: (Wt = new Ut, function (e, t) {
                    var n = Wt.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }),
                setFromObject: function (e) {
                    return this.makeEmpty(), this.expandByObject(e)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function () {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function () {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Ut), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function (e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Ut), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function (e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function (e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function (e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                expandByObject: function () {
                    var i, o, a, s = new Ut;

                    function t(e) {
                        var t = e.geometry;
                        if (void 0 !== t)
                            if (t.isGeometry) {
                                var n = t.vertices;
                                for (o = 0, a = n.length; o < a; o++) s.copy(n[o]), s.applyMatrix4(e.matrixWorld), i.expandByPoint(s)
                            } else if (t.isBufferGeometry) {
                                var r = t.attributes.position;
                                if (void 0 !== r)
                                    for (o = 0, a = r.count; o < a; o++) s.fromBufferAttribute(r, o).applyMatrix4(e.matrixWorld), i.expandByPoint(s)
                            }
                    }
                    return function (e) {
                        return i = this, e.updateMatrixWorld(!0), e.traverse(t), this
                    }
                }(),
                containsPoint: function (e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                },
                containsBox: function (e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                },
                getParameter: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Ut), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function (e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                },
                intersectsSphere: (qt = new Ut, function (e) {
                    return this.clampPoint(e.center, qt), qt.distanceToSquared(e.center) <= e.radius * e.radius
                }),
                intersectsPlane: function (e) {
                    var t, n;
                    return 0 < e.normal.x ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= e.constant && n >= e.constant
                },
                intersectsTriangle: function () {
                    var s = new Ut,
                        c = new Ut,
                        l = new Ut,
                        n = new Ut,
                        r = new Ut,
                        i = new Ut,
                        u = new Ut,
                        o = new Ut,
                        h = new Ut,
                        a = new Ut;

                    function d(e) {
                        var t, n;
                        for (t = 0, n = e.length - 3; t <= n; t += 3) {
                            u.fromArray(e, t);
                            var r = h.x * Math.abs(u.x) + h.y * Math.abs(u.y) + h.z * Math.abs(u.z),
                                i = s.dot(u),
                                o = c.dot(u),
                                a = l.dot(u);
                            if (Math.max(-Math.max(i, o, a), Math.min(i, o, a)) > r) return !1
                        }
                        return !0
                    }
                    return function (e) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(o), h.subVectors(this.max, o), s.subVectors(e.a, o), c.subVectors(e.b, o), l.subVectors(e.c, o), n.subVectors(c, s), r.subVectors(l, c), i.subVectors(s, l);
                        var t = [0, -n.z, n.y, 0, -r.z, r.y, 0, -i.z, i.y, n.z, 0, -n.x, r.z, 0, -r.x, i.z, 0, -i.x, -n.y, n.x, 0, -r.y, r.x, 0, -i.y, i.x, 0];
                        return !!d(t) && (!!d(t = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (a.crossVectors(n, r), d(t = [a.x, a.y, a.z])))
                    }
                }(),
                clampPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Ut), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: (Vt = new Ut, function (e) {
                    return Vt.copy(e).clamp(this.min, this.max).sub(e).length()
                }),
                getBoundingSphere: (Gt = new Ut, function (e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new hn), this.getCenter(e.center), e.radius = .5 * this.getSize(Gt).length(), e
                }),
                intersect: function (e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function (e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                applyMatrix4: (zt = [new Ut, new Ut, new Ut, new Ut, new Ut, new Ut, new Ut, new Ut], function (e) {
                    return this.isEmpty() || (zt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), zt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), zt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), zt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), zt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), zt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), zt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), zt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(zt)), this
                }),
                translate: function (e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function (e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }), Object.assign(hn.prototype, {
                set: function (e, t) {
                    return this.center.copy(e), this.radius = t, this
                },
                setFromPoints: (Xt = new un, function (e, t) {
                    var n = this.center;
                    void 0 !== t ? n.copy(t) : Xt.setFromPoints(e).getCenter(n);
                    for (var r = 0, i = 0, o = e.length; i < o; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                    return this.radius = Math.sqrt(r), this
                }),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                },
                empty: function () {
                    return this.radius <= 0
                },
                containsPoint: function (e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function (e) {
                    return e.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function (e) {
                    var t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                },
                intersectsBox: function (e) {
                    return e.intersectsSphere(this)
                },
                intersectsPlane: function (e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function (e, t) {
                    var n = this.center.distanceToSquared(e);
                    return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Ut), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                },
                getBoundingBox: function (e) {
                    return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new un), e.set(this.center, this.center), e.expandByScalar(this.radius), e
                },
                applyMatrix4: function (e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                },
                translate: function (e) {
                    return this.center.add(e), this
                },
                equals: function (e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
            }), Object.assign(dn.prototype, {
                set: function (e, t) {
                    return this.normal.copy(e), this.constant = t, this
                },
                setComponents: function (e, t, n, r) {
                    return this.normal.set(e, t, n), this.constant = r, this
                },
                setFromNormalAndCoplanarPoint: function (e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                },
                setFromCoplanarPoints: ($t = new Ut, Qt = new Ut, function (e, t, n) {
                    var r = $t.subVectors(n, t).cross(Qt.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(r, e), this
                }),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                },
                normalize: function () {
                    var e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                },
                negate: function () {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function (e) {
                    return this.normal.dot(e) + this.constant
                },
                distanceToSphere: function (e) {
                    return this.distanceToPoint(e.center) - e.radius
                },
                projectPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Ut), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                },
                intersectLine: (Zt = new Ut, function (e, t) {
                    void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Ut);
                    var n = e.delta(Zt),
                        r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                    var i = -(e.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || 1 < i ? void 0 : t.copy(n).multiplyScalar(i).add(e.start)
                }),
                intersectsLine: function (e) {
                    var t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && 0 < n || n < 0 && 0 < t
                },
                intersectsBox: function (e) {
                    return e.intersectsPlane(this)
                },
                intersectsSphere: function (e) {
                    return e.intersectsPlane(this)
                },
                coplanarPoint: function (e) {
                    return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Ut), e.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: (Yt = new Ut, Jt = new Ht, function (e, t) {
                    var n = t || Jt.getNormalMatrix(e),
                        r = this.coplanarPoint(Yt).applyMatrix4(e),
                        i = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -r.dot(i), this
                }),
                translate: function (e) {
                    return this.constant -= e.dot(this.normal), this
                },
                equals: function (e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
            }), Object.assign(pn.prototype, {
                set: function (e, t, n, r, i, o) {
                    var a = this.planes;
                    return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                },
                setFromMatrix: function (e) {
                    var t = this.planes,
                        n = e.elements,
                        r = n[0],
                        i = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        c = n[5],
                        l = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        g = n[13],
                        v = n[14],
                        y = n[15];
                    return t[0].setComponents(a - r, u - s, f - h, y - m).normalize(), t[1].setComponents(a + r, u + s, f + h, y + m).normalize(), t[2].setComponents(a + i, u + c, f + d, y + g).normalize(), t[3].setComponents(a - i, u - c, f - d, y - g).normalize(), t[4].setComponents(a - o, u - l, f - p, y - v).normalize(), t[5].setComponents(a + o, u + l, f + p, y + v).normalize(), this
                },
                intersectsObject: (nn = new hn, function (e) {
                    var t = e.geometry;
                    if (null === t.boundingSphere && t.computeBoundingSphere(), nn.copy(t.boundingSphere), e.skeleton && e.skeleton.rootMotionBone) {
                        var n = e.skeleton.rootMotionBone.matrixWorld.clone();
                        n.multiply(e.skeleton.rootMotionBoneInitialMatrixInverse), nn.applyMatrix4(n)
                    } else nn.applyMatrix4(e.matrixWorld);
                    return this.intersectsSphere(nn)
                }),
                intersectsSprite: (tn = new hn, function (e) {
                    return tn.center.set(0, 0, 0), tn.radius = .7071067811865476, tn.applyMatrix4(e.matrixWorld), this.intersectsSphere(tn)
                }),
                intersectsSphere: function (e) {
                    for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) {
                        if (t[i].distanceToPoint(n) < r) return !1
                    }
                    return !0
                },
                intersectsBox: (Kt = new Ut, en = new Ut, function (e) {
                    for (var t = this.planes, n = 0; n < 6; n++) {
                        var r = t[n];
                        Kt.x = 0 < r.normal.x ? e.min.x : e.max.x, en.x = 0 < r.normal.x ? e.max.x : e.min.x, Kt.y = 0 < r.normal.y ? e.min.y : e.max.y, en.y = 0 < r.normal.y ? e.max.y : e.min.y, Kt.z = 0 < r.normal.z ? e.min.z : e.max.z, en.z = 0 < r.normal.z ? e.max.z : e.min.z;
                        var i = r.distanceToPoint(Kt),
                            o = r.distanceToPoint(en);
                        if (i < 0 && o < 0) return !1
                    }
                    return !0
                }),
                containsPoint: function (e) {
                    for (var t = this.planes, n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            });
            var fn, mn = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "\nvec3 transformed = vec3( position );\n",
                beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
                lights_pars_maps: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
                normal_fragment_maps: "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\t\tscale *= float( gl_FrontFacing ) * 2.0 - 1.0;\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
            },
                gn = {
                    merge: function (e) {
                        for (var t = {}, n = 0; n < e.length; n++) {
                            var r = this.clone(e[n]);
                            for (var i in r) t[i] = r[i]
                        }
                        return t
                    },
                    clone: function (e) {
                        var t = {};
                        for (var n in e)
                            for (var r in t[n] = {}, e[n]) {
                                var i = e[n][r];
                                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                            }
                        return t
                    }
                },
                vn = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };

            function yn(e, t, n) {
                return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
            }
            Object.assign(yn.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function (e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                },
                setScalar: function (e) {
                    return this.r = e, this.g = e, this.b = e, this
                },
                setHex: function (e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                },
                setRGB: function (e, t, n) {
                    return this.r = e, this.g = t, this.b = n, this
                },
                setHSL: function () {
                    function o(e, t, n) {
                        return n < 0 && (n += 1), 1 < n && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
                    }
                    return function (e, t, n) {
                        if (e = Dt.euclideanModulo(e, 1), t = Dt.clamp(t, 0, 1), n = Dt.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                        else {
                            var r = n <= .5 ? n * (1 + t) : n + t - n * t,
                                i = 2 * n - r;
                            this.r = o(i, r, e + 1 / 3), this.g = o(i, r, e), this.b = o(i, r, e - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function (t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var r, i = n[1],
                            o = n[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, e(r[5]), this;
                                if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, e(r[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(r[1]) / 360,
                                        s = parseInt(r[2], 10) / 100,
                                        c = parseInt(r[3], 10) / 100;
                                    return e(r[5]), this.setHSL(a, s, c)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var l, u = (l = n[1]).length;
                        if (3 === u) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                        if (6 === u) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                    }
                    t && 0 < t.length && (void 0 !== (l = vn[t]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t));
                    return this
                },
                clone: function () {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function (e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                },
                copyGammaToLinear: function (e, t) {
                    return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                },
                copyLinearToGamma: function (e, t) {
                    void 0 === t && (t = 2);
                    var n = 0 < t ? 1 / t : 1;
                    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
                },
                convertGammaToLinear: function () {
                    var e = this.r,
                        t = this.g,
                        n = this.b;
                    return this.r = e * e, this.g = t * t, this.b = n * n, this
                },
                convertLinearToGamma: function () {
                    return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
                },
                getHex: function () {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function () {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function (e) {
                    void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var t, n, r = this.r,
                        i = this.g,
                        o = this.b,
                        a = Math.max(r, i, o),
                        s = Math.min(r, i, o),
                        c = (s + a) / 2;
                    if (s === a) n = t = 0;
                    else {
                        var l = a - s;
                        switch (n = c <= .5 ? l / (a + s) : l / (2 - a - s), a) {
                            case r:
                                t = (i - o) / l + (i < o ? 6 : 0);
                                break;
                            case i:
                                t = (o - r) / l + 2;
                                break;
                            case o:
                                t = (r - i) / l + 4
                        }
                        t /= 6
                    }
                    return e.h = t, e.s = n, e.l = c, e
                },
                getStyle: function () {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: (fn = {}, function (e, t, n) {
                    return this.getHSL(fn), fn.h += e, fn.s += t, fn.l += n, this.setHSL(fn.h, fn.s, fn.l), this
                }),
                add: function (e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                },
                addColors: function (e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                },
                addScalar: function (e) {
                    return this.r += e, this.g += e, this.b += e, this
                },
                sub: function (e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                },
                multiply: function (e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                },
                multiplyScalar: function (e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                },
                lerp: function (e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                },
                equals: function (e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                },
                toJSON: function () {
                    return this.getHex()
                }
            });
            var _n, xn, bn = {
                common: {
                    diffuse: {
                        value: new yn(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new Ht
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new jt(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new yn(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new yn(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new Ht
                    }
                }
            },
                wn = {
                    basic: {
                        uniforms: gn.merge([bn.common, bn.specularmap, bn.envmap, bn.aomap, bn.lightmap, bn.fog]),
                        vertexShader: mn.meshbasic_vert,
                        fragmentShader: mn.meshbasic_frag
                    },
                    lambert: {
                        uniforms: gn.merge([bn.common, bn.specularmap, bn.envmap, bn.aomap, bn.lightmap, bn.emissivemap, bn.fog, bn.lights, {
                            emissive: {
                                value: new yn(0)
                            }
                        }]),
                        vertexShader: mn.meshlambert_vert,
                        fragmentShader: mn.meshlambert_frag
                    },
                    phong: {
                        uniforms: gn.merge([bn.common, bn.specularmap, bn.envmap, bn.aomap, bn.lightmap, bn.emissivemap, bn.bumpmap, bn.normalmap, bn.displacementmap, bn.gradientmap, bn.fog, bn.lights, {
                            emissive: {
                                value: new yn(0)
                            },
                            specular: {
                                value: new yn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: mn.meshphong_vert,
                        fragmentShader: mn.meshphong_frag
                    },
                    standard: {
                        uniforms: gn.merge([bn.common, bn.envmap, bn.aomap, bn.lightmap, bn.emissivemap, bn.bumpmap, bn.normalmap, bn.displacementmap, bn.roughnessmap, bn.metalnessmap, bn.fog, bn.lights, {
                            emissive: {
                                value: new yn(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: mn.meshphysical_vert,
                        fragmentShader: mn.meshphysical_frag
                    },
                    points: {
                        uniforms: gn.merge([bn.points, bn.fog]),
                        vertexShader: mn.points_vert,
                        fragmentShader: mn.points_frag
                    },
                    dashed: {
                        uniforms: gn.merge([bn.common, bn.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: mn.linedashed_vert,
                        fragmentShader: mn.linedashed_frag
                    },
                    depth: {
                        uniforms: gn.merge([bn.common, bn.displacementmap]),
                        vertexShader: mn.depth_vert,
                        fragmentShader: mn.depth_frag
                    },
                    normal: {
                        uniforms: gn.merge([bn.common, bn.bumpmap, bn.normalmap, bn.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: mn.normal_vert,
                        fragmentShader: mn.normal_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: mn.cube_vert,
                        fragmentShader: mn.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: mn.equirect_vert,
                        fragmentShader: mn.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: gn.merge([bn.common, bn.displacementmap, {
                            referencePosition: {
                                value: new Ut
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: mn.distanceRGBA_vert,
                        fragmentShader: mn.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: gn.merge([bn.lights, bn.fog, {
                            color: {
                                value: new yn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: mn.shadow_vert,
                        fragmentShader: mn.shadow_frag
                    }
                };

            function En(c) {
                var l = new WeakMap;
                return {
                    get: function (e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), l.get(e)
                    },
                    remove: function (e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        var t = l.get(e);
                        t && (c.deleteBuffer(t.buffer), l.delete(e))
                    },
                    update: function (e, t) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        var n, r, i, o, a, s = l.get(e);
                        void 0 === s ? l.set(e, function (e, t) {
                            var n = e.array,
                                r = e.dynamic ? c.DYNAMIC_DRAW : c.STATIC_DRAW,
                                i = c.createBuffer();
                            c.bindBuffer(t, i), c.bufferData(t, n, r), e.onUploadCallback();
                            var o = c.FLOAT;
                            return n instanceof Float32Array ? o = c.FLOAT : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? o = c.UNSIGNED_SHORT : n instanceof Int16Array ? o = c.SHORT : n instanceof Uint32Array ? o = c.UNSIGNED_INT : n instanceof Int32Array ? o = c.INT : n instanceof Int8Array ? o = c.BYTE : n instanceof Uint8Array && (o = c.UNSIGNED_BYTE), {
                                buffer: i,
                                type: o,
                                bytesPerElement: n.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(e, t)) : s.version < e.version && (n = s.buffer, i = t, o = (r = e).array, a = r.updateRange, c.bindBuffer(i, n), !1 === r.dynamic ? c.bufferData(i, o, c.STATIC_DRAW) : -1 === a.count ? c.bufferSubData(i, 0, o) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (c.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)), a.count = -1), s.version = e.version)
                    }
                }
            }

            function Tn(e, t, n, r) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || Tn.DefaultOrder
            }

            function Sn() {
                this.mask = 1
            }
            wn.physical = {
                uniforms: gn.merge([wn.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: mn.meshphysical_vert,
                fragmentShader: mn.meshphysical_frag
            }, Tn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Tn.DefaultOrder = "XYZ", Object.defineProperties(Tn.prototype, {
                x: {
                    get: function () {
                        return this._x
                    },
                    set: function (e) {
                        this._x = e, this.onChangeCallback()
                    }
                },
                y: {
                    get: function () {
                        return this._y
                    },
                    set: function (e) {
                        this._y = e, this.onChangeCallback()
                    }
                },
                z: {
                    get: function () {
                        return this._z
                    },
                    set: function (e) {
                        this._z = e, this.onChangeCallback()
                    }
                },
                order: {
                    get: function () {
                        return this._order
                    },
                    set: function (e) {
                        this._order = e, this.onChangeCallback()
                    }
                }
            }), Object.assign(Tn.prototype, {
                isEuler: !0,
                set: function (e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this.onChangeCallback(), this
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function (e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function (e, t, n) {
                    var r = Dt.clamp,
                        i = e.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        c = i[1],
                        l = i[5],
                        u = i[9],
                        h = i[2],
                        d = i[6],
                        p = i[10];
                    return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === t ? (this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === t ? (this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this.onChangeCallback(), this
                },
                setFromQuaternion: (xn = new Nt, function (e, t, n) {
                    return xn.makeRotationFromQuaternion(e), this.setFromRotationMatrix(xn, t, n)
                }),
                setFromVector3: function (e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                },
                reorder: (_n = new kt, function (e) {
                    return _n.setFromEuler(this), this.setFromQuaternion(_n, e)
                }),
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                },
                fromArray: function (e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                },
                toVector3: function (e) {
                    return e ? e.set(this._x, this._y, this._z) : new Ut(this._x, this._y, this._z)
                },
                onChange: function (e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function () { }
            }), Object.assign(Sn.prototype, {
                set: function (e) {
                    this.mask = 1 << e | 0
                },
                enable: function (e) {
                    this.mask |= 1 << e | 0
                },
                toggle: function (e) {
                    this.mask ^= 1 << e | 0
                },
                disable: function (e) {
                    this.mask &= ~(1 << e | 0)
                },
                test: function (e) {
                    return 0 != (this.mask & e.mask)
                }
            });
            var Mn, An, Cn, Ln, Rn, Pn, On, In, Dn, jn, Nn, kn, Un, Hn, Bn, Fn, zn, Gn, Vn = 0;

            function qn() {
                Object.defineProperty(this, "id", {
                    value: Vn++
                }), this.uuid = Dt.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = qn.DefaultUp.clone();
                var e = new Ut,
                    t = new Tn,
                    n = new kt,
                    r = new Ut(1, 1, 1);
                t.onChange(function () {
                    n.setFromEuler(t, !1)
                }), n.onChange(function () {
                    t.setFromQuaternion(n, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new Nt
                    },
                    normalMatrix: {
                        value: new Ht
                    }
                }), this.matrix = new Nt, this.matrixWorld = new Nt, this.matrixAutoUpdate = qn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Sn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }

            function Wn() {
                qn.call(this), this.type = "Camera", this.matrixWorldInverse = new Nt, this.projectionMatrix = new Nt
            }

            function Xn(e, t, n, r, i, o) {
                Wn.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function Yn(e, t, n, r, i, o) {
                this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new Ut, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new yn, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
            }
            qn.DefaultUp = new Ut(0, 1, 0), qn.DefaultMatrixAutoUpdate = !0, qn.prototype = Object.assign(Object.create(i.prototype), {
                constructor: qn,
                isObject3D: !0,
                onBeforeRender: function () { },
                onAfterRender: function () { },
                applyMatrix: function (e) {
                    this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function (e) {
                    return this.quaternion.premultiply(e), this
                },
                setRotationFromAxisAngle: function (e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                },
                setRotationFromEuler: function (e) {
                    this.quaternion.setFromEuler(e, !0)
                },
                setRotationFromMatrix: function (e) {
                    this.quaternion.setFromRotationMatrix(e)
                },
                setRotationFromQuaternion: function (e) {
                    this.quaternion.copy(e)
                },
                rotateOnAxis: (zn = new kt, function (e, t) {
                    return zn.setFromAxisAngle(e, t), this.quaternion.multiply(zn), this
                }),
                rotateOnWorldAxis: (Fn = new kt, function (e, t) {
                    return Fn.setFromAxisAngle(e, t), this.quaternion.premultiply(Fn), this
                }),
                rotateX: (Bn = new Ut(1, 0, 0), function (e) {
                    return this.rotateOnAxis(Bn, e)
                }),
                rotateY: (Hn = new Ut(0, 1, 0), function (e) {
                    return this.rotateOnAxis(Hn, e)
                }),
                rotateZ: (Un = new Ut(0, 0, 1), function (e) {
                    return this.rotateOnAxis(Un, e)
                }),
                translateOnAxis: (kn = new Ut, function (e, t) {
                    return kn.copy(e).applyQuaternion(this.quaternion), this.position.add(kn.multiplyScalar(t)), this
                }),
                translateX: (Nn = new Ut(1, 0, 0), function (e) {
                    return this.translateOnAxis(Nn, e)
                }),
                translateY: (jn = new Ut(0, 1, 0), function (e) {
                    return this.translateOnAxis(jn, e)
                }),
                translateZ: (Dn = new Ut(0, 0, 1), function (e) {
                    return this.translateOnAxis(Dn, e)
                }),
                localToWorld: function (e) {
                    return e.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: (In = new Nt, function (e) {
                    return e.applyMatrix4(In.getInverse(this.matrixWorld))
                }),
                lookAt: (Pn = new Nt, On = new Ut, function (e, t, n) {
                    e.isVector3 ? On.copy(e) : On.set(e, t, n), this.isCamera ? Pn.lookAt(this.position, On, this.up) : Pn.lookAt(On, this.position, this.up), this.quaternion.setFromRotationMatrix(Pn)
                }),
                add: function (e) {
                    if (1 < arguments.length) {
                        for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                        type: "added"
                    }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this
                },
                remove: function (e) {
                    if (1 < arguments.length) {
                        for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    var n = this.children.indexOf(e);
                    return -1 !== n && (e.parent = null, e.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(n, 1)), this
                },
                getObjectById: function (e) {
                    return this.getObjectByProperty("id", e)
                },
                getObjectByName: function (e) {
                    return this.getObjectByProperty("name", e)
                },
                getObjectByProperty: function (e, t) {
                    if (this[e] === t) return this;
                    for (var n = 0, r = this.children.length; n < r; n++) {
                        var i = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== i) return i
                    }
                },
                getWorldPosition: function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Ut), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: (Ln = new Ut, Rn = new Ut, function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new kt), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ln, e, Rn), e
                }),
                getWorldScale: (An = new Ut, Cn = new kt, function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Ut), this.updateMatrixWorld(!0), this.matrixWorld.decompose(An, Cn, e), e
                }),
                getWorldDirection: (Mn = new kt, function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Ut), this.getWorldQuaternion(Mn), e.set(0, 0, 1).applyQuaternion(Mn)
                }),
                raycast: function () { },
                traverse: function (e) {
                    e(this);
                    for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
                },
                traverseVisible: function (e) {
                    if (!1 !== this.visible) {
                        e(this);
                        for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                    }
                },
                traverseAncestors: function (e) {
                    var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                },
                updateMatrix: function () {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function (e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e = !(this.matrixWorldNeedsUpdate = !1));
                    for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
                },
                toJSON: function (n) {
                    var e = void 0 === n || "string" == typeof n,
                        t = {};
                    e && (n = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, t.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var r = {};

                    function i(e, t) {
                        return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(n)), t.uuid
                    }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), void 0 !== this.geometry) {
                        r.geometry = i(n.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, c = a.length; s < c; s++) {
                                    var l = a[s];
                                    i(n.shapes, l)
                                } else i(n.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var u = [];
                            for (s = 0, c = this.material.length; s < c; s++) u.push(i(n.materials, this.material[s]));
                            r.material = u
                        } else r.material = i(n.materials, this.material);
                    if (0 < this.children.length) {
                        r.children = [];
                        for (s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(n).object)
                    }
                    if (e) {
                        var h = m(n.geometries),
                            d = m(n.materials),
                            p = m(n.textures),
                            f = m(n.images);
                        a = m(n.shapes);
                        0 < h.length && (t.geometries = h), 0 < d.length && (t.materials = d), 0 < p.length && (t.textures = p), 0 < f.length && (t.images = f), 0 < a.length && (t.shapes = a)
                    }
                    return t.object = r, t;

                    function m(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                },
                clone: function (e) {
                    return (new this.constructor).copy(this, e)
                },
                copy: function (e, t) {
                    if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (var n = 0; n < e.children.length; n++) {
                            var r = e.children[n];
                            this.add(r.clone())
                        }
                    return this
                }
            }), Wn.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: Wn,
                isCamera: !0,
                copy: function (e, t) {
                    return qn.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this
                },
                getWorldDirection: (Gn = new kt, function (e) {
                    return void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Ut), this.getWorldQuaternion(Gn), e.set(0, 0, -1).applyQuaternion(Gn)
                }),
                updateMatrixWorld: function (e) {
                    qn.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), Xn.prototype = Object.assign(Object.create(Wn.prototype), {
                constructor: Xn,
                isOrthographicCamera: !0,
                copy: function (e, t) {
                    return Wn.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                },
                setViewOffset: function (e, t, n, r, i, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function () {
                    var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2,
                        i = n - e,
                        o = n + e,
                        a = r + t,
                        s = r - t;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            l = this.zoom / (this.view.height / this.view.fullHeight),
                            u = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        o = (i += u * (this.view.offsetX / c)) + u * (this.view.width / c), s = (a -= h * (this.view.offsetY / l)) - h * (this.view.height / l)
                    }
                    this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far)
                },
                toJSON: function (e) {
                    var t = qn.prototype.toJSON.call(this, e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }), Object.assign(Yn.prototype, {
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                    for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                    return this
                }
            });
            var Jn, Zn, $n, Qn, Kn, er, tr, nr = 0;

            function rr() {
                Object.defineProperty(this, "id", {
                    value: nr += 2
                }), this.uuid = Dt.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function ir(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function or(e, t, n) {
                ir.call(this, new Int8Array(e), t, n)
            }

            function ar(e, t, n) {
                ir.call(this, new Uint8Array(e), t, n)
            }

            function sr(e, t, n) {
                ir.call(this, new Uint8ClampedArray(e), t, n)
            }

            function cr(e, t, n) {
                ir.call(this, new Int16Array(e), t, n)
            }

            function lr(e, t, n) {
                ir.call(this, new Uint16Array(e), t, n)
            }

            function ur(e, t, n) {
                ir.call(this, new Int32Array(e), t, n)
            }

            function hr(e, t, n) {
                ir.call(this, new Uint32Array(e), t, n)
            }

            function dr(e, t, n) {
                ir.call(this, new Float32Array(e), t, n)
            }

            function pr(e, t, n) {
                ir.call(this, new Float64Array(e), t, n)
            }

            function fr() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function mr(e) {
                if (0 === e.length) return -1 / 0;
                for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
                return t
            }
            rr.prototype = Object.assign(Object.create(i.prototype), {
                constructor: rr,
                isGeometry: !0,
                applyMatrix: function (e) {
                    for (var t = (new Ht).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) {
                        this.vertices[n].applyMatrix4(e)
                    }
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n];
                        i.normal.applyMatrix3(t).normalize();
                        for (var o = 0, a = i.vertexNormals.length; o < a; o++) i.vertexNormals[o].applyMatrix3(t).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: (tr = new Nt, function (e) {
                    return tr.makeRotationX(e), this.applyMatrix(tr), this
                }),
                rotateY: (er = new Nt, function (e) {
                    return er.makeRotationY(e), this.applyMatrix(er), this
                }),
                rotateZ: (Kn = new Nt, function (e) {
                    return Kn.makeRotationZ(e), this.applyMatrix(Kn), this
                }),
                translate: (Qn = new Nt, function (e, t, n) {
                    return Qn.makeTranslation(e, t, n), this.applyMatrix(Qn), this
                }),
                scale: ($n = new Nt, function (e, t, n) {
                    return $n.makeScale(e, t, n), this.applyMatrix($n), this
                }),
                lookAt: (Zn = new qn, function (e) {
                    Zn.lookAt(e), Zn.updateMatrix(), this.applyMatrix(Zn.matrix)
                }),
                fromBufferGeometry: function (e) {
                    var o = this,
                        t = null !== e.index ? e.index.array : void 0,
                        n = e.attributes,
                        r = n.position.array,
                        a = void 0 !== n.normal ? n.normal.array : void 0,
                        s = void 0 !== n.color ? n.color.array : void 0,
                        c = void 0 !== n.uv ? n.uv.array : void 0,
                        l = void 0 !== n.uv2 ? n.uv2.array : void 0;
                    void 0 !== l && (this.faceVertexUvs[1] = []);
                    for (var u = [], h = [], d = [], i = 0, p = 0; i < r.length; i += 3, p += 2) o.vertices.push(new Ut(r[i], r[i + 1], r[i + 2])), void 0 !== a && u.push(new Ut(a[i], a[i + 1], a[i + 2])), void 0 !== s && o.colors.push(new yn(s[i], s[i + 1], s[i + 2])), void 0 !== c && h.push(new jt(c[p], c[p + 1])), void 0 !== l && d.push(new jt(l[p], l[p + 1]));

                    function f(e, t, n, r) {
                        var i = new Yn(e, t, n, void 0 !== a ? [u[e].clone(), u[t].clone(), u[n].clone()] : [], void 0 !== s ? [o.colors[e].clone(), o.colors[t].clone(), o.colors[n].clone()] : [], r);
                        o.faces.push(i), void 0 !== c && o.faceVertexUvs[0].push([h[e].clone(), h[t].clone(), h[n].clone()]), void 0 !== l && o.faceVertexUvs[1].push([d[e].clone(), d[t].clone(), d[n].clone()])
                    }
                    var m = e.groups;
                    if (0 < m.length)
                        for (i = 0; i < m.length; i++)
                            for (var g = m[i], v = g.start, y = (p = v, v + g.count); p < y; p += 3) void 0 !== t ? f(t[p], t[p + 1], t[p + 2], g.materialIndex) : f(p, p + 1, p + 2, g.materialIndex);
                    else if (void 0 !== t)
                        for (i = 0; i < t.length; i += 3) f(t[i], t[i + 1], t[i + 2]);
                    else
                        for (i = 0; i < r.length / 3; i += 3) f(i, i + 1, i + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: (Jn = new Ut, function () {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Jn).negate(), this.translate(Jn.x, Jn.y, Jn.z), this
                }),
                normalize: function () {
                    this.computeBoundingSphere();
                    var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        n = 0 === t ? 1 : 1 / t,
                        r = new Nt;
                    return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
                },
                computeFaceNormals: function () {
                    for (var e = new Ut, t = new Ut, n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n],
                            o = this.vertices[i.a],
                            a = this.vertices[i.b],
                            s = this.vertices[i.c];
                        e.subVectors(s, a), t.subVectors(o, a), e.cross(t), e.normalize(), i.normal.copy(e)
                    }
                },
                computeVertexNormals: function (e) {
                    var t, n, r, i, o, a;
                    for (void 0 === e && (e = !0), a = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) a[t] = new Ut;
                    if (e) {
                        var s, c, l, u = new Ut,
                            h = new Ut;
                        for (r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], s = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c], u.subVectors(l, c), h.subVectors(s, c), u.cross(h), a[o.a].add(u), a[o.b].add(u), a[o.c].add(u)
                    } else
                        for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) a[(o = this.faces[r]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (t = 0, n = this.vertices.length; t < n; t++) a[t].normalize();
                    for (r = 0, i = this.faces.length; r < i; r++) {
                        var d = (o = this.faces[r]).vertexNormals;
                        3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(), d[1] = a[o.b].clone(), d[2] = a[o.c].clone())
                    }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function () {
                    var e, t, n;
                    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                        var r = (n = this.faces[e]).vertexNormals;
                        3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
                    }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function () {
                    var e, t, n, r, i;
                    for (n = 0, r = this.faces.length; n < r; n++)
                        for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
                    var o = new rr;
                    for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            var a = this.morphNormals[e].faceNormals,
                                s = this.morphNormals[e].vertexNormals;
                            for (n = 0, r = this.faces.length; n < r; n++) c = new Ut, l = {
                                a: new Ut,
                                b: new Ut,
                                c: new Ut
                            }, a.push(c), s.push(l)
                        }
                        var c, l, u = this.morphNormals[e];
                        for (o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], c = u.faceNormals[n], l = u.vertexNormals[n], c.copy(i.normal), l.a.copy(i.vertexNormals[0]), l.b.copy(i.vertexNormals[1]), l.c.copy(i.vertexNormals[2])
                    }
                    for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
                },
                computeBoundingBox: function () {
                    null === this.boundingBox && (this.boundingBox = new un), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function () {
                    null === this.boundingSphere && (this.boundingSphere = new hn), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function (e, t, n) {
                    if (e && e.isGeometry) {
                        var r, i = this.vertices.length,
                            o = this.vertices,
                            a = e.vertices,
                            s = this.faces,
                            c = e.faces,
                            l = this.faceVertexUvs[0],
                            u = e.faceVertexUvs[0],
                            h = this.colors,
                            d = e.colors;
                        void 0 === n && (n = 0), void 0 !== t && (r = (new Ht).getNormalMatrix(t));
                        for (var p = 0, f = a.length; p < f; p++) {
                            var m = a[p].clone();
                            void 0 !== t && m.applyMatrix4(t), o.push(m)
                        }
                        for (p = 0, f = d.length; p < f; p++) h.push(d[p].clone());
                        for (p = 0, f = c.length; p < f; p++) {
                            var g, v, y, _ = c[p],
                                x = _.vertexNormals,
                                b = _.vertexColors;
                            (g = new Yn(_.a + i, _.b + i, _.c + i)).normal.copy(_.normal), void 0 !== r && g.normal.applyMatrix3(r).normalize();
                            for (var w = 0, E = x.length; w < E; w++) v = x[w].clone(), void 0 !== r && v.applyMatrix3(r).normalize(), g.vertexNormals.push(v);
                            g.color.copy(_.color);
                            for (w = 0, E = b.length; w < E; w++) y = b[w], g.vertexColors.push(y.clone());
                            g.materialIndex = _.materialIndex + n, s.push(g)
                        }
                        for (p = 0, f = u.length; p < f; p++) {
                            var T = u[p],
                                S = [];
                            if (void 0 !== T) {
                                for (w = 0, E = T.length; w < E; w++) S.push(T[w].clone());
                                l.push(S)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
                },
                mergeMesh: function (e) {
                    e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
                },
                mergeVertices: function () {
                    var e, t, n, r, i, o, a, s, c = {},
                        l = [],
                        u = [],
                        h = Math.pow(10, 4);
                    for (n = 0, r = this.vertices.length; n < r; n++) e = this.vertices[n], void 0 === c[t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h)] ? (c[t] = n, l.push(this.vertices[n]), u[n] = l.length - 1) : u[n] = u[c[t]];
                    var d = [];
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        (i = this.faces[n]).a = u[i.a], i.b = u[i.b], i.c = u[i.c], o = [i.a, i.b, i.c];
                        for (var p = 0; p < 3; p++)
                            if (o[p] === o[(p + 1) % 3]) {
                                d.push(n);
                                break
                            }
                    }
                    for (n = d.length - 1; 0 <= n; n--) {
                        var f = d[n];
                        for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                    }
                    var m = this.vertices.length - l.length;
                    return this.vertices = l, m
                },
                setFromPoints: function (e) {
                    this.vertices = [];
                    for (var t = 0, n = e.length; t < n; t++) {
                        var r = e[t];
                        this.vertices.push(new Ut(r.x, r.y, r.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function () {
                    for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
                    e.sort(function (e, t) {
                        return e.materialIndex - t.materialIndex
                    });
                    var r, i, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    o && o.length === t && (r = []), a && a.length === t && (i = []);
                    for (n = 0; n < t; n++) {
                        var s = e[n]._id;
                        r && r.push(o[s]), i && i.push(a[s])
                    }
                    r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
                },
                toJSON: function () {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                        var t = this.parameters;
                        for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    for (var r = [], i = 0; i < this.vertices.length; i++) {
                        var o = this.vertices[i];
                        r.push(o.x, o.y, o.z)
                    }
                    var a = [],
                        s = [],
                        c = {},
                        l = [],
                        u = {},
                        h = [],
                        d = {};
                    for (i = 0; i < this.faces.length; i++) {
                        var p = this.faces[i],
                            f = void 0 !== this.faceVertexUvs[0][i],
                            m = 0 < p.normal.length(),
                            g = 0 < p.vertexNormals.length,
                            v = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                            y = 0 < p.vertexColors.length,
                            _ = 0;
                        if (_ = E(_ = E(_ = E(_ = E(_ = E(_ = E(_ = E(_ = E(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, g), 6, v), 7, y), a.push(_), a.push(p.a, p.b, p.c), a.push(p.materialIndex), f) {
                            var x = this.faceVertexUvs[0][i];
                            a.push(M(x[0]), M(x[1]), M(x[2]))
                        }
                        if (m && a.push(T(p.normal)), g) {
                            var b = p.vertexNormals;
                            a.push(T(b[0]), T(b[1]), T(b[2]))
                        }
                        if (v && a.push(S(p.color)), y) {
                            var w = p.vertexColors;
                            a.push(S(w[0]), S(w[1]), S(w[2]))
                        }
                    }

                    function E(e, t, n) {
                        return n ? e | 1 << t : e & ~(1 << t)
                    }

                    function T(e) {
                        var t = e.x.toString() + e.y.toString() + e.z.toString();
                        return void 0 !== c[t] || (c[t] = s.length / 3, s.push(e.x, e.y, e.z)), c[t]
                    }

                    function S(e) {
                        var t = e.r.toString() + e.g.toString() + e.b.toString();
                        return void 0 !== u[t] || (u[t] = l.length, l.push(e.getHex())), u[t]
                    }

                    function M(e) {
                        var t = e.x.toString() + e.y.toString();
                        return void 0 !== d[t] || (d[t] = h.length / 2, h.push(e.x, e.y)), d[t]
                    }
                    return e.data = {}, e.data.vertices = r, e.data.normals = s, 0 < l.length && (e.data.colors = l), 0 < h.length && (e.data.uvs = [h]), e.data.faces = a, e
                },
                clone: function () {
                    return (new rr).copy(this)
                },
                copy: function (e) {
                    var t, n, r, i, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var s = e.vertices;
                    for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                    var c = e.colors;
                    for (t = 0, n = c.length; t < n; t++) this.colors.push(c[t].clone());
                    var l = e.faces;
                    for (t = 0, n = l.length; t < n; t++) this.faces.push(l[t].clone());
                    for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                        var u = e.faceVertexUvs[t];
                        for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), r = 0, i = u.length; r < i; r++) {
                            var h = u[r],
                                d = [];
                            for (o = 0, a = h.length; o < a; o++) {
                                var p = h[o];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[t].push(d)
                        }
                    }
                    var f = e.morphTargets;
                    for (t = 0, n = f.length; t < n; t++) {
                        var m = {};
                        if (m.name = f[t].name, void 0 !== f[t].vertices)
                            for (m.vertices = [], r = 0, i = f[t].vertices.length; r < i; r++) m.vertices.push(f[t].vertices[r].clone());
                        if (void 0 !== f[t].normals)
                            for (m.normals = [], r = 0, i = f[t].normals.length; r < i; r++) m.normals.push(f[t].normals[r].clone());
                        this.morphTargets.push(m)
                    }
                    var g = e.morphNormals;
                    for (t = 0, n = g.length; t < n; t++) {
                        var v = {};
                        if (void 0 !== g[t].vertexNormals)
                            for (v.vertexNormals = [], r = 0, i = g[t].vertexNormals.length; r < i; r++) {
                                var y = g[t].vertexNormals[r],
                                    _ = {};
                                _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                            }
                        if (void 0 !== g[t].faceNormals)
                            for (v.faceNormals = [], r = 0, i = g[t].faceNormals.length; r < i; r++) v.faceNormals.push(g[t].faceNormals[r].clone());
                        this.morphNormals.push(v)
                    }
                    var x = e.skinWeights;
                    for (t = 0, n = x.length; t < n; t++) this.skinWeights.push(x[t].clone());
                    var b = e.skinIndices;
                    for (t = 0, n = b.length; t < n; t++) this.skinIndices.push(b[t].clone());
                    var w = e.lineDistances;
                    for (t = 0, n = w.length; t < n; t++) this.lineDistances.push(w[t]);
                    var E = e.boundingBox;
                    null !== E && (this.boundingBox = E.clone());
                    var T = e.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(ir.prototype, "needsUpdate", {
                set: function (e) {
                    !0 === e && this.version++
                }
            }), Object.assign(ir.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function () { },
                setArray: function (e) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
                },
                setDynamic: function (e) {
                    return this.dynamic = e, this
                },
                copy: function (e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
                },
                copyAt: function (e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                },
                copyArray: function (e) {
                    return this.array.set(e), this
                },
                copyColorsArray: function (e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new yn), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function (e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new jt), t[n++] = o.x, t[n++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function (e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new Ut), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function (e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new an), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w
                    }
                    return this
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                getX: function (e) {
                    return this.array[e * this.itemSize]
                },
                setX: function (e, t) {
                    return this.array[e * this.itemSize] = t, this
                },
                getY: function (e) {
                    return this.array[e * this.itemSize + 1]
                },
                setY: function (e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                },
                getZ: function (e) {
                    return this.array[e * this.itemSize + 2]
                },
                setZ: function (e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                },
                getW: function (e) {
                    return this.array[e * this.itemSize + 3]
                },
                setW: function (e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                },
                setXY: function (e, t, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                },
                setXYZ: function (e, t, n, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
                },
                setXYZW: function (e, t, n, r, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
                },
                onUpload: function (e) {
                    return this.onUploadCallback = e, this
                },
                clone: function () {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), (or.prototype = Object.create(ir.prototype)).constructor = or, (ar.prototype = Object.create(ir.prototype)).constructor = ar, (sr.prototype = Object.create(ir.prototype)).constructor = sr, (cr.prototype = Object.create(ir.prototype)).constructor = cr, (lr.prototype = Object.create(ir.prototype)).constructor = lr, (ur.prototype = Object.create(ir.prototype)).constructor = ur, (hr.prototype = Object.create(ir.prototype)).constructor = hr, (dr.prototype = Object.create(ir.prototype)).constructor = dr, (pr.prototype = Object.create(ir.prototype)).constructor = pr, Object.assign(fr.prototype, {
                computeGroups: function (e) {
                    for (var t, n = [], r = void 0, i = e.faces, o = 0; o < i.length; o++) {
                        var a = i[o];
                        a.materialIndex !== r && (r = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), t = {
                            start: 3 * o,
                            materialIndex: r
                        })
                    }
                    void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), this.groups = n
                },
                fromGeometry: function (e) {
                    var t, n = e.faces,
                        r = e.vertices,
                        i = e.faceVertexUvs,
                        o = i[0] && 0 < i[0].length,
                        a = i[1] && 0 < i[1].length,
                        s = e.morphTargets,
                        c = s.length;
                    if (0 < c) {
                        t = [];
                        for (var l = 0; l < c; l++) t[l] = [];
                        this.morphTargets.position = t
                    }
                    var u, h = e.morphNormals,
                        d = h.length;
                    if (0 < d) {
                        u = [];
                        for (l = 0; l < d; l++) u[l] = [];
                        this.morphTargets.normal = u
                    }
                    var p = e.skinIndices,
                        f = e.skinWeights,
                        m = p.length === r.length,
                        g = f.length === r.length;
                    for (l = 0; l < n.length; l++) {
                        var v = n[l];
                        this.vertices.push(r[v.a], r[v.b], r[v.c]);
                        var y = v.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var _ = v.normal;
                            this.normals.push(_, _, _)
                        }
                        var x, b = v.vertexColors;
                        if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                        else {
                            var w = v.color;
                            this.colors.push(w, w, w)
                        }
                        if (!0 === o) void 0 !== (x = i[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new jt, new jt, new jt));
                        if (!0 === a) void 0 !== (x = i[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new jt, new jt, new jt));
                        for (var E = 0; E < c; E++) {
                            var T = s[E].vertices;
                            t[E].push(T[v.a], T[v.b], T[v.c])
                        }
                        for (E = 0; E < d; E++) {
                            var S = h[E].vertexNormals[l];
                            u[E].push(S.a, S.b, S.c)
                        }
                        m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
                    }
                    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                }
            });
            var gr, vr, yr, _r, xr, br, wr, Er, Tr, Sr, Mr = 1;

            function Ar() {
                Object.defineProperty(this, "id", {
                    value: Mr += 2
                }), this.uuid = Dt.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }
            }

            function Cr(e, t, n, r, i, o) {
                rr.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                }, this.fromBufferGeometry(new Lr(e, t, n, r, i, o)), this.mergeVertices()
            }

            function Lr(e, t, n, r, i, o) {
                Ar.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                };
                var L = this;
                e = e || 1, t = t || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1, o = Math.floor(o) || 1;
                var R = [],
                    P = [],
                    O = [],
                    I = [],
                    D = 0,
                    j = 0;

                function a(e, t, n, r, i, o, a, s, c, l, u) {
                    var h, d, p = o / c,
                        f = a / l,
                        m = o / 2,
                        g = a / 2,
                        v = s / 2,
                        y = c + 1,
                        _ = l + 1,
                        x = 0,
                        b = 0,
                        w = new Ut;
                    for (d = 0; d < _; d++) {
                        var E = d * f - g;
                        for (h = 0; h < y; h++) {
                            var T = h * p - m;
                            w[e] = T * r, w[t] = E * i, w[n] = v, P.push(w.x, w.y, w.z), w[e] = 0, w[t] = 0, w[n] = 0 < s ? 1 : -1, O.push(w.x, w.y, w.z), I.push(h / c), I.push(1 - d / l), x += 1
                        }
                    }
                    for (d = 0; d < l; d++)
                        for (h = 0; h < c; h++) {
                            var S = D + h + y * d,
                                M = D + h + y * (d + 1),
                                A = D + (h + 1) + y * (d + 1),
                                C = D + (h + 1) + y * d;
                            R.push(S, M, C), R.push(M, A, C), b += 6
                        }
                    L.addGroup(j, b, u), j += b, D += x
                }
                a("z", "y", "x", -1, -1, n, t, e, o, i, 0), a("z", "y", "x", 1, -1, n, t, -e, o, i, 1), a("x", "z", "y", 1, 1, e, n, t, r, o, 2), a("x", "z", "y", 1, -1, e, n, -t, r, o, 3), a("x", "y", "z", 1, -1, e, t, n, r, i, 4), a("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(R), this.addAttribute("position", new dr(P, 3)), this.addAttribute("normal", new dr(O, 3)), this.addAttribute("uv", new dr(I, 2))
            }

            function Rr(e, t, n, r) {
                rr.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                }, this.fromBufferGeometry(new Pr(e, t, n, r)), this.mergeVertices()
            }

            function Pr(e, t, n, r) {
                Ar.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                };
                var i, o, a = (e = e || 1) / 2,
                    s = (t = t || 1) / 2,
                    c = Math.floor(n) || 1,
                    l = Math.floor(r) || 1,
                    u = c + 1,
                    h = l + 1,
                    d = e / c,
                    p = t / l,
                    f = [],
                    m = [],
                    g = [],
                    v = [];
                for (o = 0; o < h; o++) {
                    var y = o * p - s;
                    for (i = 0; i < u; i++) {
                        var _ = i * d - a;
                        m.push(_, -y, 0), g.push(0, 0, 1), v.push(i / c), v.push(1 - o / l)
                    }
                }
                for (o = 0; o < l; o++)
                    for (i = 0; i < c; i++) {
                        var x = i + u * o,
                            b = i + u * (o + 1),
                            w = i + 1 + u * (o + 1),
                            E = i + 1 + u * o;
                        f.push(x, b, E), f.push(b, w, E)
                    }
                this.setIndex(f), this.addAttribute("position", new dr(m, 3)), this.addAttribute("normal", new dr(g, 3)), this.addAttribute("uv", new dr(v, 2))
            }
            Ar.prototype = Object.assign(Object.create(i.prototype), {
                constructor: Ar,
                isBufferGeometry: !0,
                getIndex: function () {
                    return this.index
                },
                setIndex: function (e) {
                    Array.isArray(e) ? this.index = new (65535 < mr(e) ? hr : lr)(e, 1) : this.index = e
                },
                addAttribute: function (e, t) {
                    return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(t)) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(e, new ir(t, arguments[2])))
                },
                getAttribute: function (e) {
                    return this.attributes[e]
                },
                removeAttribute: function (e) {
                    return delete this.attributes[e], this
                },
                addGroup: function (e, t, n) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function () {
                    this.groups = []
                },
                setDrawRange: function (e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                },
                applyMatrix: function (e) {
                    var t = this.attributes.position;
                    void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
                    var n = this.attributes.normal;
                    void 0 !== n && ((new Ht).getNormalMatrix(e).applyToBufferAttribute(n), n.needsUpdate = !0);
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: (Sr = new Nt, function (e) {
                    return Sr.makeRotationX(e), this.applyMatrix(Sr), this
                }),
                rotateY: (Tr = new Nt, function (e) {
                    return Tr.makeRotationY(e), this.applyMatrix(Tr), this
                }),
                rotateZ: (Er = new Nt, function (e) {
                    return Er.makeRotationZ(e), this.applyMatrix(Er), this
                }),
                translate: (wr = new Nt, function (e, t, n) {
                    return wr.makeTranslation(e, t, n), this.applyMatrix(wr), this
                }),
                scale: (br = new Nt, function (e, t, n) {
                    return br.makeScale(e, t, n), this.applyMatrix(br), this
                }),
                lookAt: (xr = new qn, function (e) {
                    xr.lookAt(e), xr.updateMatrix(), this.applyMatrix(xr.matrix)
                }),
                center: (_r = new Ut, function () {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(_r).negate(), this.translate(_r.x, _r.y, _r.z), this
                }),
                setFromObject: function (e) {
                    var t = e.geometry;
                    if (e.isPoints || e.isLine) {
                        var n = new dr(3 * t.vertices.length, 3),
                            r = new dr(3 * t.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(t.vertices)), this.addAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                            var i = new dr(t.lineDistances.length, 1);
                            this.addAttribute("lineDistance", i.copyArray(t.lineDistances))
                        }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                    return this
                },
                setFromPoints: function (e) {
                    for (var t = [], n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    return this.addAttribute("position", new dr(t, 3)), this
                },
                updateFromObject: function (e) {
                    var t, n = e.geometry;
                    if (e.isMesh) {
                        var r = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                        r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices), t.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals), t.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors), t.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs), t.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances), t.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(e.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function (e) {
                    return e.__directGeometry = (new fr).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
                },
                fromDirectGeometry: function (e) {
                    var t = new Float32Array(3 * e.vertices.length);
                    if (this.addAttribute("position", new ir(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length) {
                        var n = new Float32Array(3 * e.normals.length);
                        this.addAttribute("normal", new ir(n, 3).copyVector3sArray(e.normals))
                    }
                    if (0 < e.colors.length) {
                        var r = new Float32Array(3 * e.colors.length);
                        this.addAttribute("color", new ir(r, 3).copyColorsArray(e.colors))
                    }
                    if (0 < e.uvs.length) {
                        var i = new Float32Array(2 * e.uvs.length);
                        this.addAttribute("uv", new ir(i, 2).copyVector2sArray(e.uvs))
                    }
                    if (0 < e.uvs2.length) {
                        var o = new Float32Array(2 * e.uvs2.length);
                        this.addAttribute("uv2", new ir(o, 2).copyVector2sArray(e.uvs2))
                    }
                    for (var a in this.groups = e.groups, e.morphTargets) {
                        for (var s = [], c = e.morphTargets[a], l = 0, u = c.length; l < u; l++) {
                            var h = c[l],
                                d = new dr(3 * h.length, 3);
                            s.push(d.copyVector3sArray(h))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (0 < e.skinIndices.length) {
                        var p = new dr(4 * e.skinIndices.length, 4);
                        this.addAttribute("skinIndex", p.copyVector4sArray(e.skinIndices))
                    }
                    if (0 < e.skinWeights.length) {
                        var f = new dr(4 * e.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
                    }
                    return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                },
                computeBoundingBox: function () {
                    null === this.boundingBox && (this.boundingBox = new un);
                    var e = this.attributes.position;
                    void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: (vr = new un, yr = new Ut, function () {
                    null === this.boundingSphere && (this.boundingSphere = new hn);
                    var e = this.attributes.position;
                    if (e) {
                        var t = this.boundingSphere.center;
                        vr.setFromBufferAttribute(e), vr.getCenter(t);
                        for (var n = 0, r = 0, i = e.count; r < i; r++) yr.x = e.getX(r), yr.y = e.getY(r), yr.z = e.getZ(r), n = Math.max(n, t.distanceToSquared(yr));
                        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }),
                computeFaceNormals: function () { },
                computeVertexNormals: function () {
                    var e = this.index,
                        t = this.attributes,
                        n = this.groups;
                    if (t.position) {
                        var r = t.position.array;
                        if (void 0 === t.normal) this.addAttribute("normal", new ir(new Float32Array(r.length), 3));
                        else
                            for (var i = t.normal.array, o = 0, a = i.length; o < a; o++) i[o] = 0;
                        var s, c, l, u = t.normal.array,
                            h = new Ut,
                            d = new Ut,
                            p = new Ut,
                            f = new Ut,
                            m = new Ut;
                        if (e) {
                            var g = e.array;
                            0 === n.length && this.addGroup(0, g.length);
                            for (var v = 0, y = n.length; v < y; ++v) {
                                var _ = n[v],
                                    x = _.start;
                                for (o = x, a = x + _.count; o < a; o += 3) s = 3 * g[o + 0], c = 3 * g[o + 1], l = 3 * g[o + 2], h.fromArray(r, s), d.fromArray(r, c), p.fromArray(r, l), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[s] += f.x, u[s + 1] += f.y, u[s + 2] += f.z, u[c] += f.x, u[c + 1] += f.y, u[c + 2] += f.z, u[l] += f.x, u[l + 1] += f.y, u[l + 2] += f.z
                            }
                        } else
                            for (o = 0, a = r.length; o < a; o += 9) h.fromArray(r, o), d.fromArray(r, o + 3), p.fromArray(r, o + 6), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[o] = f.x, u[o + 1] = f.y, u[o + 2] = f.z, u[o + 3] = f.x, u[o + 4] = f.y, u[o + 5] = f.z, u[o + 6] = f.x, u[o + 7] = f.y, u[o + 8] = f.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0
                    }
                },
                merge: function (e, t) {
                    if (e && e.isBufferGeometry) {
                        void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var n = this.attributes;
                        for (var r in n)
                            if (void 0 !== e.attributes[r])
                                for (var i = n[r].array, o = e.attributes[r], a = o.array, s = 0, c = o.itemSize * t; s < a.length; s++ , c++) i[c] = a[s];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
                },
                normalizeNormals: (gr = new Ut, function () {
                    for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) gr.x = e.getX(t), gr.y = e.getY(t), gr.z = e.getZ(t), gr.normalize(), e.setXYZ(t, gr.x, gr.y, gr.z)
                }),
                toNonIndexed: function () {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var e = new Ar,
                        t = this.index.array,
                        n = this.attributes;
                    for (var r in n) {
                        for (var i = n[r], o = i.array, a = i.itemSize, s = new o.constructor(t.length * a), c = 0, l = 0, u = 0, h = t.length; u < h; u++) {
                            c = t[u] * a;
                            for (var d = 0; d < a; d++) s[l++] = o[c++]
                        }
                        e.addAttribute(r, new ir(s, a))
                    }
                    var p = this.groups;
                    for (u = 0, h = p.length; u < h; u++) {
                        var f = p[u];
                        e.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return e
                },
                toJSON: function () {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                        var t = this.parameters;
                        for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    var r = this.index;
                    if (null !== r) {
                        var i = Array.prototype.slice.call(r.array);
                        e.data.index = {
                            type: r.array.constructor.name,
                            array: i
                        }
                    }
                    var o = this.attributes;
                    for (var n in o) {
                        var a = o[n];
                        i = Array.prototype.slice.call(a.array);
                        e.data.attributes[n] = {
                            itemSize: a.itemSize,
                            type: a.array.constructor.name,
                            array: i,
                            normalized: a.normalized
                        }
                    }
                    var s = this.groups;
                    0 < s.length && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    var c = this.boundingSphere;
                    return null !== c && (e.data.boundingSphere = {
                        center: c.center.toArray(),
                        radius: c.radius
                    }), e
                },
                clone: function () {
                    return (new Ar).copy(this)
                },
                copy: function (e) {
                    var t, n, r;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var i = e.index;
                    null !== i && this.setIndex(i.clone());
                    var o = e.attributes;
                    for (t in o) {
                        var a = o[t];
                        this.addAttribute(t, a.clone())
                    }
                    var s = e.morphAttributes;
                    for (t in s) {
                        var c = [],
                            l = s[t];
                        for (n = 0, r = l.length; n < r; n++) c.push(l[n].clone());
                        this.morphAttributes[t] = c
                    }
                    var u = e.groups;
                    for (n = 0, r = u.length; n < r; n++) {
                        var h = u[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var d = e.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = e.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), (Cr.prototype = Object.create(rr.prototype)).constructor = Cr, (Lr.prototype = Object.create(Ar.prototype)).constructor = Lr, (Rr.prototype = Object.create(rr.prototype)).constructor = Rr, (Pr.prototype = Object.create(Ar.prototype)).constructor = Pr;
            var Or, Ir, Dr, jr, Nr, kr, Ur, Hr, Br, Fr, zr, Gr, Vr, qr, Wr, Xr, Yr, Jr, Zr, $r, Qr, Kr, ei, ti, ni = 0;

            function ri() {
                Object.defineProperty(this, "id", {
                    value: ni++
                }), this.uuid = Dt.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = X, this.side = j, this.flatShading = !1, this.vertexColors = Se, this.opacity = 1, this.transparent = !1, this.blendSrc = N, this.blendDst = H, this.blendEquation = M, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = oe, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function ii(e) {
                ri.call(this), this.type = "MeshBasicMaterial", this.color = new yn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ue, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e)
            }

            function oi(e) {
                ri.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
            }

            function ai(e, t) {
                this.origin = void 0 !== e ? e : new Ut, this.direction = void 0 !== t ? t : new Ut
            }

            function si(e, t) {
                this.start = void 0 !== e ? e : new Ut, this.end = void 0 !== t ? t : new Ut
            }

            function ci(e, t, n) {
                this.a = void 0 !== e ? e : new Ut, this.b = void 0 !== t ? t : new Ut, this.c = void 0 !== n ? n : new Ut
            }

            function li(e, t) {
                qn.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Ar, this.material = void 0 !== t ? t : new ii({
                    color: 16777215 * Math.random()
                }), this.drawMode = Tt, this.updateMorphTargets()
            }

            function ui(o, n, a, r) {
                var s, c, l, u = new yn(0),
                    h = 0;

                function d(e, t) {
                    n.buffers.color.setClear(e.r, e.g, e.b, t, r)
                }
                return {
                    getClearColor: function () {
                        return u
                    },
                    setClearColor: function (e, t) {
                        u.set(e), d(u, h = void 0 !== t ? t : 1)
                    },
                    getClearAlpha: function () {
                        return h
                    },
                    setClearAlpha: function (e) {
                        d(u, h = e)
                    },
                    render: function (e, t, n, r) {
                        var i = t.background;
                        null === i ? d(u, h) : i && i.isColor && (d(i, 1), r = !0), (o.autoClear || r) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), i && i.isCubeTexture ? (void 0 === l && ((l = new li(new Lr(1, 1, 1), new oi({
                            uniforms: wn.cube.uniforms,
                            vertexShader: wn.cube.vertexShader,
                            fragmentShader: wn.cube.fragmentShader,
                            side: J,
                            depthTest: !0,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function (e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, a.update(l.geometry)), l.material.uniforms.tCube.value = i, e.push(l, l.geometry, l.material, 0, null)) : i && i.isTexture && (void 0 === s && (s = new Xn(-1, 1, 1, -1, 0, 1), c = new li(new Pr(2, 2), new ii({
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), a.update(c.geometry)), c.material.map = i, o.renderBufferDirect(s, null, c.geometry, c.material, c, null))
                    }
                }
            }

            function hi(n, o, a) {
                var s;
                this.setMode = function (e) {
                    s = e
                }, this.render = function (e, t) {
                    n.drawArrays(s, e, t), a.update(t, s)
                }, this.renderInstances = function (e, t, n) {
                    var r = o.get("ANGLE_instanced_arrays");
                    if (null !== r) {
                        var i = e.attributes.position;
                        i.isInterleavedBufferAttribute ? (n = i.data.count, r.drawArraysInstancedANGLE(s, 0, n, e.maxInstancedCount)) : r.drawArraysInstancedANGLE(s, t, n, e.maxInstancedCount), a.update(n, s, e.maxInstancedCount)
                    } else console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                }
            }

            function di(t, n, e) {
                var r;

                function i(e) {
                    if ("highp" === e) {
                        if (0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && 0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
                }
                var o = void 0 !== e.precision ? e.precision : "highp",
                    a = i(o);
                a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                var s = !0 === e.logarithmicDepthBuffer,
                    c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                    l = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    u = t.getParameter(t.MAX_TEXTURE_SIZE),
                    h = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                    d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                    p = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                    f = t.getParameter(t.MAX_VARYING_VECTORS),
                    m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                    g = 0 < l,
                    v = !!n.get("OES_texture_float");
                return {
                    getMaxAnisotropy: function () {
                        if (void 0 !== r) return r;
                        var e = n.get("EXT_texture_filter_anisotropic");
                        return r = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: i,
                    precision: o,
                    logarithmicDepthBuffer: s,
                    maxTextures: c,
                    maxVertexTextures: l,
                    maxTextureSize: u,
                    maxCubemapSize: h,
                    maxAttributes: d,
                    maxVertexUniforms: p,
                    maxVaryings: f,
                    maxFragmentUniforms: m,
                    vertexTextures: g,
                    floatFragmentTextures: v,
                    floatVertexTextures: g && v
                }
            }

            function pi() {
                var u = this,
                    h = null,
                    d = 0,
                    p = !1,
                    f = !1,
                    m = new dn,
                    g = new Ht,
                    v = {
                        value: null,
                        needsUpdate: !1
                    };

                function y() {
                    v.value !== h && (v.value = h, v.needsUpdate = 0 < d), u.numPlanes = d, u.numIntersection = 0
                }

                function _(e, t, n, r) {
                    var i = null !== e ? e.length : 0,
                        o = null;
                    if (0 !== i) {
                        if (o = v.value, !0 !== r || null === o) {
                            var a = n + 4 * i,
                                s = t.matrixWorldInverse;
                            g.getNormalMatrix(s), (null === o || o.length < a) && (o = new Float32Array(a));
                            for (var c = 0, l = n; c !== i; ++c, l += 4) m.copy(e[c]).applyMatrix4(s, g), m.normal.toArray(o, l), o[l + 3] = m.constant
                        }
                        v.value = o, v.needsUpdate = !0
                    }
                    return u.numPlanes = i, o
                }
                this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, n) {
                    var r = 0 !== e.length || t || 0 !== d || p;
                    return p = t, h = _(e, n, 0), d = e.length, r
                }, this.beginShadows = function () {
                    f = !0, _(null)
                }, this.endShadows = function () {
                    f = !1, y()
                }, this.setState = function (e, t, n, r, i, o) {
                    if (!p || null === e || 0 === e.length || f && !n) f ? _(null) : y();
                    else {
                        var a = f ? 0 : d,
                            s = 4 * a,
                            c = i.clippingState || null;
                        v.value = c, c = _(e, r, s, o);
                        for (var l = 0; l !== s; ++l) c[l] = h[l];
                        i.clippingState = c, this.numIntersection = t ? this.numPlanes : 0, this.numPlanes += a
                    }
                }
            }

            function fi(n) {
                var r = {};
                return {
                    get: function (e) {
                        if (void 0 !== r[e]) return r[e];
                        var t;
                        switch (e) {
                            case "WEBGL_depth_texture":
                                t = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                t = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                t = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                t = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                t = n.getExtension(e)
                        }
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), r[e] = t
                    }
                }
            }

            function mi(h, d, o) {
                var a = {},
                    p = {};

                function s(e) {
                    var t = e.target,
                        n = a[t.id];
                    for (var r in null !== n.index && d.remove(n.index), n.attributes) d.remove(n.attributes[r]);
                    t.removeEventListener("dispose", s), delete a[t.id];
                    var i = p[t.id];
                    i && (d.remove(i), delete p[t.id]), (i = p[n.id]) && (d.remove(i), delete p[n.id]), o.memory.geometries--
                }
                return {
                    get: function (e, t) {
                        var n = a[t.id];
                        return n || (t.addEventListener("dispose", s), t.isBufferGeometry ? n = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Ar).setFromObject(e)), n = t._bufferGeometry), a[t.id] = n, o.memory.geometries++ , n)
                    },
                    update: function (e) {
                        var t = e.index,
                            n = e.attributes;
                        for (var r in null !== t && d.update(t, h.ELEMENT_ARRAY_BUFFER), n) d.update(n[r], h.ARRAY_BUFFER);
                        var i = e.morphAttributes;
                        for (var r in i)
                            for (var o = i[r], a = 0, s = o.length; a < s; a++) d.update(o[a], h.ARRAY_BUFFER)
                    },
                    getWireframeAttribute: function (e) {
                        var t = p[e.id];
                        if (t) return t;
                        var n, r = [],
                            i = e.index,
                            o = e.attributes;
                        if (null !== i)
                            for (var a = 0, s = (n = i.array).length; a < s; a += 3) {
                                var c = n[a + 0],
                                    l = n[a + 1],
                                    u = n[a + 2];
                                r.push(c, l, l, u, u, c)
                            } else
                            for (a = 0, s = (n = o.position.array).length / 3 - 1; a < s; a += 3) c = a + 0, l = a + 1, u = a + 2, r.push(c, l, l, u, u, c);
                        return t = new (65535 < mr(r) ? hr : lr)(r, 1), d.update(t, h.ELEMENT_ARRAY_BUFFER), p[e.id] = t
                    }
                }
            }

            function gi(n, i, o) {
                var a, s, c;
                this.setMode = function (e) {
                    a = e
                }, this.setIndex = function (e) {
                    s = e.type, c = e.bytesPerElement
                }, this.render = function (e, t) {
                    n.drawElements(a, t, s, e * c), o.update(t, a)
                }, this.renderInstances = function (e, t, n) {
                    var r = i.get("ANGLE_instanced_arrays");
                    null !== r ? (r.drawElementsInstancedANGLE(a, n, s, t * c, e.maxInstancedCount), o.update(n, a, e.maxInstancedCount)) : console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                }
            }

            function vi(r) {
                var i = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: i,
                    programs: null,
                    autoReset: !0,
                    reset: function () {
                        i.frame++ , i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0
                    },
                    update: function (e, t, n) {
                        switch (n = n || 1, i.calls++ , t) {
                            case r.TRIANGLES:
                                i.triangles += n * (e / 3);
                                break;
                            case r.TRIANGLE_STRIP:
                            case r.TRIANGLE_FAN:
                                i.triangles += n * (e - 2);
                                break;
                            case r.LINES:
                                i.lines += n * (e / 2);
                                break;
                            case r.LINE_STRIP:
                                i.lines += n * (e - 1);
                                break;
                            case r.LINE_LOOP:
                                i.lines += n * e;
                                break;
                            case r.POINTS:
                                i.points += n * e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                        }
                    }
                }
            }

            function yi(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function _i(p) {
                var f = {},
                    m = new Float32Array(8);
                return {
                    update: function (e, t, n, r) {
                        var i = e.morphTargetInfluences,
                            o = i.length,
                            a = f[t.id];
                        if (void 0 === a) {
                            a = [];
                            for (var s = 0; s < o; s++) a[s] = [s, 0];
                            f[t.id] = a
                        }
                        var c = n.morphTargets && t.morphAttributes.position,
                            l = n.morphNormals && t.morphAttributes.normal;
                        for (s = 0; s < o; s++) 0 !== (u = a[s])[1] && (c && t.removeAttribute("morphTarget" + s), l && t.removeAttribute("morphNormal" + s));
                        for (s = 0; s < o; s++)(u = a[s])[0] = s, u[1] = i[s];
                        for (a.sort(yi), s = 0; s < 8; s++) {
                            var u;
                            if (u = a[s]) {
                                var h = u[0],
                                    d = u[1];
                                if (d) {
                                    c && t.addAttribute("morphTarget" + s, c[h]), l && t.addAttribute("morphNormal" + s, l[h]), m[s] = d;
                                    continue
                                }
                            }
                            m[s] = 0
                        }
                        r.getUniforms().setValue(p, "morphTargetInfluences", m)
                    }
                }
            }

            function xi(i, o) {
                var a = {};
                return {
                    update: function (e) {
                        var t = o.render.frame,
                            n = e.geometry,
                            r = i.get(e, n);
                        return a[r.id] !== t && (n.isGeometry && r.updateFromObject(e), i.update(r), a[r.id] = t), r
                    },
                    dispose: function () {
                        a = {}
                    }
                }
            }

            function bi(e, t, n, r, i, o, a, s, c, l) {
                on.call(this, e = void 0 !== e ? e : [], t = void 0 !== t ? t : ve, n, r, i, o, a, s, c, l), this.flipY = !1
            }
            ri.prototype = Object.assign(Object.create(i.prototype), {
                constructor: ri,
                isMaterial: !0,
                onBeforeCompile: function () { },
                setValues: function (e) {
                    if (void 0 !== e)
                        for (var t in e) {
                            var n = e[t];
                            if (void 0 !== n)
                                if ("shading" !== t) {
                                    var r = this[t];
                                    void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = "overdraw" === t ? Number(n) : n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                        }
                },
                toJSON: function (e) {
                    var t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== X && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== j && (n.side = this.side), this.vertexColors !== Se && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                        var i = r(e.textures),
                            o = r(e.images);
                        0 < i.length && (n.textures = i), 0 < o.length && (n.images = o)
                    }
                    return n
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
                    var t = e.clippingPlanes,
                        n = null;
                    if (null !== t) {
                        var r = t.length;
                        n = new Array(r);
                        for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = e.shadowSide, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), ((ii.prototype = Object.create(ri.prototype)).constructor = ii).prototype.isMeshBasicMaterial = !0, ii.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
            }, ((oi.prototype = Object.create(ri.prototype)).constructor = oi).prototype.isShaderMaterial = !0, oi.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = gn.clone(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
            }, oi.prototype.toJSON = function (e) {
                var t = ri.prototype.toJSON.call(this, e);
                return t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
            }, Object.assign(ai.prototype, {
                set: function (e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                },
                at: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Ut), t.copy(this.direction).multiplyScalar(e).add(this.origin)
                },
                lookAt: function (e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                },
                recast: (zr = new Ut, function (e) {
                    return this.origin.copy(this.at(e, zr)), this
                }),
                closestPointToPoint: function (e, t) {
                    void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Ut), t.subVectors(e, this.origin);
                    var n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function (e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                },
                distanceSqToPoint: (Fr = new Ut, function (e) {
                    var t = Fr.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (Fr.copy(this.direction).multiplyScalar(t).add(this.origin), Fr.distanceToSquared(e))
                }),
                distanceSqToSegment: (Ur = new Ut, Hr = new Ut, Br = new Ut, function (e, t, n, r) {
                    Ur.copy(e).add(t).multiplyScalar(.5), Hr.copy(t).sub(e).normalize(), Br.copy(this.origin).sub(Ur);
                    var i, o, a, s, c = .5 * e.distanceTo(t),
                        l = -this.direction.dot(Hr),
                        u = Br.dot(this.direction),
                        h = -Br.dot(Hr),
                        d = Br.lengthSq(),
                        p = Math.abs(1 - l * l);
                    if (0 < p)
                        if (o = l * u - h, s = c * p, 0 <= (i = l * h - u))
                            if (-s <= o)
                                if (o <= s) {
                                    var f = 1 / p;
                                    a = (i *= f) * (i + l * (o *= f) + 2 * u) + o * (l * i + o + 2 * h) + d
                                } else o = c, a = -(i = Math.max(0, -(l * o + u))) * i + o * (o + 2 * h) + d;
                            else o = -c, a = -(i = Math.max(0, -(l * o + u))) * i + o * (o + 2 * h) + d;
                        else o <= -s ? a = -(i = Math.max(0, -(-l * c + u))) * i + (o = 0 < i ? -c : Math.min(Math.max(-c, -h), c)) * (o + 2 * h) + d : o <= s ? (i = 0, a = (o = Math.min(Math.max(-c, -h), c)) * (o + 2 * h) + d) : a = -(i = Math.max(0, -(l * c + u))) * i + (o = 0 < i ? c : Math.min(Math.max(-c, -h), c)) * (o + 2 * h) + d;
                    else o = 0 < l ? -c : c, a = -(i = Math.max(0, -(l * o + u))) * i + o * (o + 2 * h) + d;
                    return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(Hr).multiplyScalar(o).add(Ur), a
                }),
                intersectSphere: (kr = new Ut, function (e, t) {
                    kr.subVectors(e.center, this.origin);
                    var n = kr.dot(this.direction),
                        r = kr.dot(kr) - n * n,
                        i = e.radius * e.radius;
                    if (i < r) return null;
                    var o = Math.sqrt(i - r),
                        a = n - o,
                        s = n + o;
                    return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
                }),
                intersectsSphere: function (e) {
                    return this.distanceToPoint(e.center) <= e.radius
                },
                distanceToPlane: function (e) {
                    var t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return 0 <= n ? n : null
                },
                intersectPlane: function (e, t) {
                    var n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                },
                intersectsPlane: function (e) {
                    var t = e.distanceToPoint(this.origin);
                    return 0 === t || e.normal.dot(this.direction) * t < 0
                },
                intersectBox: function (e, t) {
                    var n, r, i, o, a, s, c = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return 0 <= c ? (n = (e.min.x - h.x) * c, r = (e.max.x - h.x) * c) : (n = (e.max.x - h.x) * c, r = (e.min.x - h.x) * c), 0 <= l ? (i = (e.min.y - h.y) * l, o = (e.max.y - h.y) * l) : (i = (e.max.y - h.y) * l, o = (e.min.y - h.y) * l), o < n || r < i ? null : ((n < i || n != n) && (n = i), (o < r || r != r) && (r = o), 0 <= u ? (a = (e.min.z - h.z) * u, s = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, s = (e.min.z - h.z) * u), s < n || r < a ? null : ((n < a || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(0 <= n ? n : r, t)))
                },
                intersectsBox: (Nr = new Ut, function (e) {
                    return null !== this.intersectBox(e, Nr)
                }),
                intersectTriangle: (Or = new Ut, Ir = new Ut, Dr = new Ut, jr = new Ut, function (e, t, n, r, i) {
                    Ir.subVectors(t, e), Dr.subVectors(n, e), jr.crossVectors(Ir, Dr);
                    var o, a = this.direction.dot(jr);
                    if (0 < a) {
                        if (r) return null;
                        o = 1
                    } else {
                        if (!(a < 0)) return null;
                        o = -1, a = -a
                    }
                    Or.subVectors(this.origin, e);
                    var s = o * this.direction.dot(Dr.crossVectors(Or, Dr));
                    if (s < 0) return null;
                    var c = o * this.direction.dot(Ir.cross(Or));
                    if (c < 0) return null;
                    if (a < s + c) return null;
                    var l = -o * Or.dot(jr);
                    return l < 0 ? null : this.at(l / a, i)
                }),
                applyMatrix4: function (e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                },
                equals: function (e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
            }), Object.assign(si.prototype, {
                set: function (e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Ut), e.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function (e) {
                    return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new Ut), e.subVectors(this.end, this.start)
                },
                distanceSq: function () {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function () {
                    return this.start.distanceTo(this.end)
                },
                at: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new Ut), this.delta(t).multiplyScalar(e).add(this.start)
                },
                closestPointToPointParameter: (Gr = new Ut, Vr = new Ut, function (e, t) {
                    Gr.subVectors(e, this.start), Vr.subVectors(this.end, this.start);
                    var n = Vr.dot(Vr),
                        r = Vr.dot(Gr) / n;
                    return t && (r = Dt.clamp(r, 0, 1)), r
                }),
                closestPointToPoint: function (e, t, n) {
                    var r = this.closestPointToPointParameter(e, t);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Ut), this.delta(n).multiplyScalar(r).add(this.start)
                },
                applyMatrix4: function (e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                },
                equals: function (e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
            }), Object.assign(ci, {
                getNormal: (Jr = new Ut, function (e, t, n, r) {
                    void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new Ut), r.subVectors(n, t), Jr.subVectors(e, t), r.cross(Jr);
                    var i = r.lengthSq();
                    return 0 < i ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                }),
                getBarycoord: (Wr = new Ut, Xr = new Ut, Yr = new Ut, function (e, t, n, r, i) {
                    Wr.subVectors(r, t), Xr.subVectors(n, t), Yr.subVectors(e, t);
                    var o = Wr.dot(Wr),
                        a = Wr.dot(Xr),
                        s = Wr.dot(Yr),
                        c = Xr.dot(Xr),
                        l = Xr.dot(Yr),
                        u = o * c - a * a;
                    if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new Ut), 0 === u) return i.set(-2, -1, -1);
                    var h = 1 / u,
                        d = (c * s - a * l) * h,
                        p = (o * l - a * s) * h;
                    return i.set(1 - d - p, p, d)
                }),
                containsPoint: (qr = new Ut, function (e, t, n, r) {
                    return ci.getBarycoord(e, t, n, r, qr), 0 <= qr.x && 0 <= qr.y && qr.x + qr.y <= 1
                })
            }), Object.assign(ci.prototype, {
                set: function (e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                },
                setFromPointsAndIndices: function (e, t, n, r) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                },
                getArea: (ei = new Ut, ti = new Ut, function () {
                    return ei.subVectors(this.c, this.b), ti.subVectors(this.a, this.b), .5 * ei.cross(ti).length()
                }),
                getMidpoint: function (e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Ut), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function (e) {
                    return ci.getNormal(this.a, this.b, this.c, e)
                },
                getPlane: function (e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Ut), e.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function (e, t) {
                    return ci.getBarycoord(e, this.a, this.b, this.c, t)
                },
                containsPoint: function (e) {
                    return ci.containsPoint(e, this.a, this.b, this.c)
                },
                intersectsBox: function (e) {
                    return e.intersectsTriangle(this)
                },
                closestPointToPoint: (Zr = new dn, $r = [new si, new si, new si], Qr = new Ut, Kr = new Ut, function (e, t) {
                    void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Ut);
                    var n = 1 / 0;
                    if (Zr.setFromCoplanarPoints(this.a, this.b, this.c), Zr.projectPoint(e, Qr), !0 === this.containsPoint(Qr)) t.copy(Qr);
                    else {
                        $r[0].set(this.a, this.b), $r[1].set(this.b, this.c), $r[2].set(this.c, this.a);
                        for (var r = 0; r < $r.length; r++) {
                            $r[r].closestPointToPoint(Qr, !0, Kr);
                            var i = Qr.distanceToSquared(Kr);
                            i < n && (n = i, t.copy(Kr))
                        }
                    }
                    return t
                }),
                equals: function (e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }), li.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: li,
                isMesh: !0,
                setDrawMode: function (e) {
                    this.drawMode = e
                },
                copy: function (e) {
                    return qn.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
                },
                updateMorphTargets: function () {
                    var e, t, n, r = this.geometry;
                    if (r.isBufferGeometry) {
                        var i = r.morphAttributes,
                            o = Object.keys(i);
                        if (0 < o.length) {
                            var a = i[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    } else {
                        var s = r.morphTargets;
                        if (void 0 !== s && 0 < s.length)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = s.length; e < t; e++) n = s[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                    }
                },
                raycast: function () {
                    var I = new Nt,
                        D = new ai,
                        j = new hn,
                        N = new Ut,
                        k = new Ut,
                        U = new Ut,
                        H = new Ut,
                        B = new Ut,
                        F = new Ut,
                        z = new jt,
                        G = new jt,
                        V = new jt,
                        s = new Ut,
                        q = new Ut,
                        l = new Ut;

                    function W(e, t, n, r, i, o, a) {
                        return ci.getBarycoord(e, t, n, r, s), i.multiplyScalar(s.x), o.multiplyScalar(s.y), a.multiplyScalar(s.z), i.add(o).add(a), i.clone()
                    }

                    function X(e, t, n, r, i, o, a, s) {
                        if (null === (t.side === J ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, t.side !== Z, s))) return null;
                        l.copy(s), l.applyMatrix4(e.matrixWorld);
                        var c = n.ray.origin.distanceTo(l);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: l.clone(),
                            object: e
                        }
                    }

                    function Y(e, t, n, r, i, o, a, s) {
                        N.fromBufferAttribute(r, o), k.fromBufferAttribute(r, a), U.fromBufferAttribute(r, s);
                        var c = X(e, e.material, t, n, N, k, U, q);
                        if (c) {
                            i && (z.fromBufferAttribute(i, o), G.fromBufferAttribute(i, a), V.fromBufferAttribute(i, s), c.uv = W(q, N, k, U, z, G, V));
                            var l = new Yn(o, a, s);
                            ci.getNormal(N, k, U, l.normal), c.face = l, c.faceIndex = o
                        }
                        return c
                    }
                    return function (e, t) {
                        var n, r = this.geometry,
                            i = this.material,
                            o = this.matrixWorld;
                        if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), j.copy(r.boundingSphere), j.applyMatrix4(o), !1 !== e.ray.intersectsSphere(j) && (I.getInverse(o), D.copy(e.ray).applyMatrix4(I), null === r.boundingBox || !1 !== D.intersectsBox(r.boundingBox))))
                            if (r.isBufferGeometry) {
                                var a, s, c, l, u, h = r.index,
                                    d = r.attributes.position,
                                    p = r.attributes.uv;
                                if (null !== h)
                                    for (l = 0, u = h.count; l < u; l += 3) a = h.getX(l), s = h.getX(l + 1), c = h.getX(l + 2), (n = Y(this, e, D, d, p, a, s, c)) && (n.faceIndex = Math.floor(l / 3), t.push(n));
                                else if (void 0 !== d)
                                    for (l = 0, u = d.count; l < u; l += 3)(n = Y(this, e, D, d, p, a = l, s = l + 1, c = l + 2)) && t.push(n)
                            } else if (r.isGeometry) {
                                var f, m, g, v, y = Array.isArray(i),
                                    _ = r.vertices,
                                    x = r.faces,
                                    b = r.faceVertexUvs[0];
                                0 < b.length && (v = b);
                                for (var w = 0, E = x.length; w < E; w++) {
                                    var T = x[w],
                                        S = y ? i[T.materialIndex] : i;
                                    if (void 0 !== S) {
                                        if (f = _[T.a], m = _[T.b], g = _[T.c], !0 === S.morphTargets) {
                                            var M = r.morphTargets,
                                                A = this.morphTargetInfluences;
                                            N.set(0, 0, 0), k.set(0, 0, 0), U.set(0, 0, 0);
                                            for (var C = 0, L = M.length; C < L; C++) {
                                                var R = A[C];
                                                if (0 !== R) {
                                                    var P = M[C].vertices;
                                                    N.addScaledVector(H.subVectors(P[T.a], f), R), k.addScaledVector(B.subVectors(P[T.b], m), R), U.addScaledVector(F.subVectors(P[T.c], g), R)
                                                }
                                            }
                                            N.add(f), k.add(m), U.add(g), f = N, m = k, g = U
                                        }
                                        if (n = X(this, S, e, D, f, m, g, q)) {
                                            if (v && v[w]) {
                                                var O = v[w];
                                                z.copy(O[0]), G.copy(O[1]), V.copy(O[2]), n.uv = W(q, f, m, g, z, G, V)
                                            }
                                            n.face = T, n.faceIndex = w, t.push(n)
                                        }
                                    }
                                }
                            }
                    }
                }(),
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), ((bi.prototype = Object.create(on.prototype)).constructor = bi).prototype.isCubeTexture = !0, Object.defineProperty(bi.prototype, "images", {
                get: function () {
                    return this.image
                },
                set: function (e) {
                    this.image = e
                }
            });
            var wi = new on,
                Ei = new bi;

            function Ti() {
                this.seq = [], this.map = {}
            }
            var Si = [],
                Mi = [],
                Ai = new Float32Array(16),
                Ci = new Float32Array(9);

            function Li(e, t, n) {
                var r = e[0];
                if (r <= 0 || 0 < r) return e;
                var i = t * n,
                    o = Si[i];
                if (void 0 === o && (o = new Float32Array(i), Si[i] = o), 0 !== t) {
                    r.toArray(o, 0);
                    for (var a = 1, s = 0; a !== t; ++a) s += n, e[a].toArray(o, s)
                }
                return o
            }

            function Ri(e, t) {
                var n = Mi[t];
                void 0 === n && (n = new Int32Array(t), Mi[t] = n);
                for (var r = 0; r !== t; ++r) n[r] = e.allocTextureUnit();
                return n
            }

            function Pi(e, t) {
                e.uniform1f(this.addr, t)
            }

            function Oi(e, t) {
                e.uniform1i(this.addr, t)
            }

            function Ii(e, t) {
                void 0 === t.x ? e.uniform2fv(this.addr, t) : e.uniform2f(this.addr, t.x, t.y)
            }

            function Di(e, t) {
                void 0 !== t.x ? e.uniform3f(this.addr, t.x, t.y, t.z) : void 0 !== t.r ? e.uniform3f(this.addr, t.r, t.g, t.b) : e.uniform3fv(this.addr, t)
            }

            function ji(e, t) {
                void 0 === t.x ? e.uniform4fv(this.addr, t) : e.uniform4f(this.addr, t.x, t.y, t.z, t.w)
            }

            function Ni(e, t) {
                e.uniformMatrix2fv(this.addr, !1, t.elements || t)
            }

            function ki(e, t) {
                void 0 === t.elements ? e.uniformMatrix3fv(this.addr, !1, t) : (Ci.set(t.elements), e.uniformMatrix3fv(this.addr, !1, Ci))
            }

            function Ui(e, t) {
                void 0 === t.elements ? e.uniformMatrix4fv(this.addr, !1, t) : (Ai.set(t.elements), e.uniformMatrix4fv(this.addr, !1, Ai))
            }

            function Hi(e, t, n) {
                var r = n.allocTextureUnit();
                e.uniform1i(this.addr, r), n.setTexture2D(t || wi, r)
            }

            function Bi(e, t, n) {
                var r = n.allocTextureUnit();
                e.uniform1i(this.addr, r), n.setTextureCube(t || Ei, r)
            }

            function Fi(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function zi(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function Gi(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function Vi(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function qi(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function Wi(e, t) {
                e.uniform2fv(this.addr, Li(t, this.size, 2))
            }

            function Xi(e, t) {
                e.uniform3fv(this.addr, Li(t, this.size, 3))
            }

            function Yi(e, t) {
                e.uniform4fv(this.addr, Li(t, this.size, 4))
            }

            function Ji(e, t) {
                e.uniformMatrix2fv(this.addr, !1, Li(t, this.size, 4))
            }

            function Zi(e, t) {
                e.uniformMatrix3fv(this.addr, !1, Li(t, this.size, 9))
            }

            function $i(e, t) {
                e.uniformMatrix4fv(this.addr, !1, Li(t, this.size, 16))
            }

            function Qi(e, t, n) {
                var r = t.length,
                    i = Ri(n, r);
                e.uniform1iv(this.addr, i);
                for (var o = 0; o !== r; ++o) n.setTexture2D(t[o] || wi, i[o])
            }

            function Ki(e, t, n) {
                var r = t.length,
                    i = Ri(n, r);
                e.uniform1iv(this.addr, i);
                for (var o = 0; o !== r; ++o) n.setTextureCube(t[o] || Ei, i[o])
            }

            function eo(e, t, n) {
                this.id = e, this.addr = n, this.setValue = function (e) {
                    switch (e) {
                        case 5126:
                            return Pi;
                        case 35664:
                            return Ii;
                        case 35665:
                            return Di;
                        case 35666:
                            return ji;
                        case 35674:
                            return Ni;
                        case 35675:
                            return ki;
                        case 35676:
                            return Ui;
                        case 35678:
                        case 36198:
                            return Hi;
                        case 35680:
                            return Bi;
                        case 5124:
                        case 35670:
                            return Oi;
                        case 35667:
                        case 35671:
                            return Fi;
                        case 35668:
                        case 35672:
                            return zi;
                        case 35669:
                        case 35673:
                            return Gi
                    }
                }(t.type)
            }

            function to(e, t, n) {
                this.id = e, this.addr = n, this.size = t.size, this.setValue = function (e) {
                    switch (e) {
                        case 5126:
                            return Vi;
                        case 35664:
                            return Wi;
                        case 35665:
                            return Xi;
                        case 35666:
                            return Yi;
                        case 35674:
                            return Ji;
                        case 35675:
                            return Zi;
                        case 35676:
                            return $i;
                        case 35678:
                            return Qi;
                        case 35680:
                            return Ki;
                        case 5124:
                        case 35670:
                            return qi;
                        case 35667:
                        case 35671:
                            return Fi;
                        case 35668:
                        case 35672:
                            return zi;
                        case 35669:
                        case 35673:
                            return Gi
                    }
                }(t.type)
            }

            function no(e) {
                this.id = e, Ti.call(this)
            }
            no.prototype.setValue = function (e, t) {
                for (var n = this.seq, r = 0, i = n.length; r !== i; ++r) {
                    var o = n[r];
                    o.setValue(e, t[o.id])
                }
            };
            var ro = /([\w\d_]+)(\])?(\[|\.)?/g;

            function io(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function oo(e, t, n) {
                var r = e.name,
                    i = r.length;
                for (ro.lastIndex = 0; ;) {
                    var o = ro.exec(r),
                        a = ro.lastIndex,
                        s = o[1],
                        c = "]" === o[2],
                        l = o[3];
                    if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === i) {
                        io(n, void 0 === l ? new eo(s, e, t) : new to(s, e, t));
                        break
                    }
                    var u = n.map[s];
                    void 0 === u && io(n, u = new no(s)), n = u
                }
            }

            function ao(e, t, n) {
                Ti.call(this), this.renderer = n;
                for (var r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), i = 0; i < r; ++i) {
                    var o = e.getActiveUniform(t, i);
                    oo(o, e.getUniformLocation(t, o.name), this)
                }
            }

            function so(e, t, n) {
                var r = e.createShader(t);
                return e.shaderSource(r, n), e.compileShader(r), !1 === e.getShaderParameter(r, e.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(r), function (e) {
                    for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                    return t.join("\n")
                }(n)), r
            }
            ao.prototype.setValue = function (e, t, n) {
                var r = this.map[t];
                void 0 !== r && r.setValue(e, n, this.renderer)
            }, ao.prototype.setOptional = function (e, t, n) {
                var r = t[n];
                void 0 !== r && this.setValue(e, n, r)
            }, ao.upload = function (e, t, n, r) {
                for (var i = 0, o = t.length; i !== o; ++i) {
                    var a = t[i],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(e, s.value, r)
                }
            }, ao.seqWithValue = function (e, t) {
                for (var n = [], r = 0, i = e.length; r !== i; ++r) {
                    var o = e[r];
                    o.id in t && n.push(o)
                }
                return n
            };
            var co = 0;

            function lo(e) {
                switch (e) {
                    case St:
                        return ["Linear", "( value )"];
                    case Mt:
                        return ["sRGB", "( value )"];
                    case Ct:
                        return ["RGBE", "( value )"];
                    case Lt:
                        return ["RGBM", "( value, 7.0 )"];
                    case Rt:
                        return ["RGBM", "( value, 16.0 )"];
                    case Pt:
                        return ["RGBD", "( value, 256.0 )"];
                    case At:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + e)
                }
            }

            function uo(e, t) {
                var n = lo(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function ho(e) {
                return "" !== e
            }

            function po(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
            }

            function fo(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }

            function mo(e) {
                return e.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function (e, t) {
                    var n = mn[t];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
                    return mo(n)
                })
            }

            function go(e) {
                return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (e, t, n, r) {
                    for (var i = "", o = parseInt(t); o < parseInt(n); o++) i += r.replace(/\[ i \]/g, "[ " + o + " ]");
                    return i
                })
            }

            function vo(e, t, n, r, i, o) {
                var a = e.context,
                    s = r.defines,
                    c = i.vertexShader,
                    l = i.fragmentShader,
                    u = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === k ? u = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === U && (u = "SHADOWMAP_TYPE_PCF_SOFT");
                var h = "ENVMAP_TYPE_CUBE",
                    d = "ENVMAP_MODE_REFLECTION",
                    p = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (r.envMap.mapping) {
                        case ve:
                        case ye:
                            h = "ENVMAP_TYPE_CUBE";
                            break;
                        case we:
                        case Ee:
                            h = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case _e:
                        case xe:
                            h = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case be:
                            h = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (r.envMap.mapping) {
                        case ye:
                        case xe:
                            d = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (r.combine) {
                        case ue:
                            p = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case he:
                            p = "ENVMAP_BLENDING_MIX";
                            break;
                        case de:
                            p = "ENVMAP_BLENDING_ADD"
                    }
                }
                var f, m, g, v, y, _, x, b, w = 0 < e.gammaFactor ? e.gammaFactor : 1,
                    E = (f = r.extensions, m = o, g = t, [(f = f || {}).derivatives || m.envMapCubeUV || m.bumpMap || m.normalMap || m.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (f.fragDepth || m.logarithmicDepthBuffer) && g.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", f.drawBuffers && g.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (f.shaderTextureLOD || m.envMap) && g.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ho).join("\n")),
                    T = function (e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(s),
                    S = a.createProgram();
                r.isRawShaderMaterial ? (0 < (v = [T].filter(ho).join("\n")).length && (v += "\n"), 0 < (y = [E, T].filter(ho).join("\n")).length && (y += "\n")) : (v = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, T, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + w, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ho).join("\n"), y = [E, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, T, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + w, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + h : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && t.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== pe ? "#define TONE_MAPPING" : "", o.toneMapping !== pe ? mn.tonemapping_pars_fragment : "", o.toneMapping !== pe ? function (e, t) {
                    var n;
                    switch (t) {
                        case Me:
                            n = "Linear";
                            break;
                        case fe:
                            n = "Reinhard";
                            break;
                        case me:
                            n = "Uncharted2";
                            break;
                        case ge:
                            n = "OptimizedCineon";
                            break;
                        default:
                            throw new Error("unsupported toneMapping: " + t)
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? mn.encodings_pars_fragment : "", o.mapEncoding ? uo("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? uo("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? uo("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? (_ = "linearToOutputTexel", x = o.outputEncoding, b = lo(x), "vec4 " + _ + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }") : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(ho).join("\n")), c = fo(c = po(c = mo(c), o), o), l = fo(l = po(l = mo(l), o), o);
                var M = v + (c = go(c)),
                    A = y + (l = go(l)),
                    C = so(a, a.VERTEX_SHADER, M),
                    L = so(a, a.FRAGMENT_SHADER, A);
                a.attachShader(S, C), a.attachShader(S, L), void 0 !== r.index0AttributeName ? a.bindAttribLocation(S, 0, r.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(S, 0, "position"), a.linkProgram(S);
                var R, P, O = a.getProgramInfoLog(S).trim(),
                    I = a.getShaderInfoLog(C).trim(),
                    D = a.getShaderInfoLog(L).trim(),
                    j = !0,
                    N = !0;
                return !1 === a.getProgramParameter(S, a.LINK_STATUS) ? (j = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(S, a.VALIDATE_STATUS), "gl.getProgramInfoLog", O, I, D)) : "" !== O ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", O) : "" !== I && "" !== D || (N = !1), N && (this.diagnostics = {
                    runnable: j,
                    material: r,
                    programLog: O,
                    vertexShader: {
                        log: I,
                        prefix: v
                    },
                    fragmentShader: {
                        log: D,
                        prefix: y
                    }
                }), a.deleteShader(C), a.deleteShader(L), this.getUniforms = function () {
                    return void 0 === R && (R = new ao(a, S, e)), R
                }, this.getAttributes = function () {
                    return void 0 === P && (P = function (e, t) {
                        for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                            var o = e.getActiveAttrib(t, i).name;
                            n[o] = e.getAttribLocation(t, o)
                        }
                        return n
                    }(a, S)), P
                }, this.destroy = function () {
                    a.deleteProgram(S), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function () {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function () {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.name = i.name, this.id = co++ , this.code = n, this.usedTimes = 1, this.program = S, this.vertexShader = C, this.fragmentShader = L, this
            }

            function yo(h, c, d) {
                var l = [],
                    p = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow"
                    },
                    o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function f(e, t) {
                    var n;
                    return e ? e.isTexture ? n = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = St, n === St && t && (n = At), n
                }
                this.getParameters = function (e, t, n, r, i, o, a) {
                    var s = p[e.type],
                        c = a.isSkinnedMesh ? function (e) {
                            var t = e.skeleton.bones;
                            if (d.floatVertexTextures) return 1024;
                            var n = d.maxVertexUniforms,
                                r = Math.floor((n - 20) / 4),
                                i = Math.min(r, t.length);
                            return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i
                        }(a) : 0,
                        l = d.precision;
                    null !== e.precision && (l = d.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", l, "instead.");
                    var u = h.getRenderTarget();
                    return {
                        shaderID: s,
                        precision: l,
                        supportsVertexTextures: d.vertexTextures,
                        outputEncoding: f(u ? u.texture : null, h.gammaOutput),
                        map: !!e.map,
                        mapEncoding: f(e.map, h.gammaInput),
                        envMap: !!e.envMap,
                        envMapMode: e.envMap && e.envMap.mapping,
                        envMapEncoding: f(e.envMap, h.gammaInput),
                        envMapCubeUV: !!e.envMap && (e.envMap.mapping === we || e.envMap.mapping === Ee),
                        lightMap: !!e.lightMap,
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: f(e.emissiveMap, h.gammaInput),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        combine: e.combine,
                        vertexColors: e.vertexColors,
                        fog: !!r,
                        useFog: e.fog,
                        fogExp: r && r.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: d.logarithmicDepthBuffer,
                        skinning: e.skinning && 0 < c,
                        maxBones: c,
                        useVertexTexture: d.floatVertexTextures,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: h.maxMorphTargets,
                        maxMorphNormals: h.maxMorphNormals,
                        numDirLights: t.directional.length,
                        numPointLights: t.point.length,
                        numSpotLights: t.spot.length,
                        numRectAreaLights: t.rectArea.length,
                        numHemiLights: t.hemi.length,
                        numClippingPlanes: i,
                        numClipIntersection: o,
                        dithering: e.dithering,
                        shadowMapEnabled: h.shadowMap.enabled && a.receiveShadow && 0 < n.length,
                        shadowMapType: h.shadowMap.type,
                        toneMapping: h.toneMapping,
                        physicallyCorrectLights: h.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === Z,
                        flipSided: e.side === J,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }, this.getProgramCode = function (e, t) {
                    var n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) n.push(r), n.push(e.defines[r]);
                    for (var i = 0; i < o.length; i++) n.push(t[o[i]]);
                    return n.push(e.onBeforeCompile.toString()), n.push(h.gammaOutput), n.join()
                }, this.acquireProgram = function (e, t, n, r) {
                    for (var i, o = 0, a = l.length; o < a; o++) {
                        var s = l[o];
                        if (s.code === r) {
                            ++(i = s).usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new vo(h, c, r, e, t, n), l.push(i)), i
                }, this.releaseProgram = function (e) {
                    if (0 == --e.usedTimes) {
                        var t = l.indexOf(e);
                        l[t] = l[l.length - 1], l.pop(), e.destroy()
                    }
                }, this.programs = l
            }

            function _o() {
                var r = new WeakMap;
                return {
                    get: function (e) {
                        var t = r.get(e);
                        return void 0 === t && (t = {}, r.set(e, t)), t
                    },
                    remove: function (e) {
                        r.delete(e)
                    },
                    update: function (e, t, n) {
                        r.get(e)[t] = n
                    },
                    dispose: function () {
                        r = new WeakMap
                    }
                }
            }

            function xo(e, t) {
                return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function bo(e, t) {
                return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function wo() {
                var a = [],
                    s = 0,
                    c = [],
                    l = [];
                return {
                    opaque: c,
                    transparent: l,
                    init: function () {
                        s = 0, c.length = 0, l.length = 0
                    },
                    push: function (e, t, n, r, i) {
                        var o = a[s];
                        void 0 === o ? (o = {
                            id: e.id,
                            object: e,
                            geometry: t,
                            material: n,
                            program: n.program,
                            renderOrder: e.renderOrder,
                            z: r,
                            group: i
                        }, a[s] = o) : (o.id = e.id, o.object = e, o.geometry = t, o.material = n, o.program = n.program, o.renderOrder = e.renderOrder, o.z = r, o.group = i), (!0 === n.transparent ? l : c).push(o), s++
                    },
                    sort: function () {
                        1 < c.length && c.sort(xo), 1 < l.length && l.sort(bo)
                    }
                }
            }

            function Eo() {
                var i = {};
                return {
                    get: function (e, t) {
                        var n = e.id + "," + t.id,
                            r = i[n];
                        return void 0 === r && (r = new wo, i[n] = r), r
                    },
                    dispose: function () {
                        i = {}
                    }
                }
            }

            function To() {
                var n = {};
                return {
                    get: function (e) {
                        if (void 0 !== n[e.id]) return n[e.id];
                        var t;
                        switch (e.type) {
                            case "DirectionalLight":
                                t = {
                                    direction: new Ut,
                                    color: new yn,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new jt
                                };
                                break;
                            case "SpotLight":
                                t = {
                                    position: new Ut,
                                    direction: new Ut,
                                    color: new yn,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new jt
                                };
                                break;
                            case "PointLight":
                                t = {
                                    position: new Ut,
                                    color: new yn,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new jt,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                t = {
                                    direction: new Ut,
                                    skyColor: new yn,
                                    groundColor: new yn
                                };
                                break;
                            case "RectAreaLight":
                                t = {
                                    color: new yn,
                                    position: new Ut,
                                    halfWidth: new Ut,
                                    halfHeight: new Ut
                                }
                        }
                        return n[e.id] = t
                    }
                }
            }
            var So, Mo, Ao, Co, Lo, Ro, Po, Oo, Io, Do, jo, No, ko, Uo, Ho, Bo, Fo, zo, Go = 0;

            function Vo() {
                var b = new To,
                    w = {
                        id: Go++,
                        hash: "",
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    E = new Ut,
                    T = new Nt,
                    S = new Nt;
                return {
                    setup: function (e, t, n) {
                        for (var r = 0, i = 0, o = 0, a = 0, s = 0, c = 0, l = 0, u = 0, h = n.matrixWorldInverse, d = 0, p = e.length; d < p; d++) {
                            var f = e[d],
                                m = f.color,
                                g = f.intensity,
                                v = f.distance,
                                y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
                            if (f.isAmbientLight) r += m.r * g, i += m.g * g, o += m.b * g;
                            else if (f.isDirectionalLight) {
                                if ((x = b.get(f)).color.copy(f.color).multiplyScalar(f.intensity), x.direction.setFromMatrixPosition(f.matrixWorld), E.setFromMatrixPosition(f.target.matrixWorld), x.direction.sub(E), x.direction.transformDirection(h), x.shadow = f.castShadow, f.castShadow) {
                                    var _ = f.shadow;
                                    x.shadowBias = _.bias, x.shadowRadius = _.radius, x.shadowMapSize = _.mapSize
                                }
                                w.directionalShadowMap[a] = y, w.directionalShadowMatrix[a] = f.shadow.matrix, w.directional[a] = x, a++
                            } else if (f.isSpotLight) (x = b.get(f)).position.setFromMatrixPosition(f.matrixWorld), x.position.applyMatrix4(h), x.color.copy(m).multiplyScalar(g), x.distance = v, x.direction.setFromMatrixPosition(f.matrixWorld), E.setFromMatrixPosition(f.target.matrixWorld), x.direction.sub(E), x.direction.transformDirection(h), x.coneCos = Math.cos(f.angle), x.penumbraCos = Math.cos(f.angle * (1 - f.penumbra)), x.decay = 0 === f.distance ? 0 : f.decay, x.shadow = f.castShadow, f.castShadow && (_ = f.shadow, x.shadowBias = _.bias, x.shadowRadius = _.radius, x.shadowMapSize = _.mapSize), w.spotShadowMap[c] = y, w.spotShadowMatrix[c] = f.shadow.matrix, w.spot[c] = x, c++;
                            else if (f.isRectAreaLight) (x = b.get(f)).color.copy(m).multiplyScalar(g), x.position.setFromMatrixPosition(f.matrixWorld), x.position.applyMatrix4(h), S.identity(), T.copy(f.matrixWorld), T.premultiply(h), S.extractRotation(T), x.halfWidth.set(.5 * f.width, 0, 0), x.halfHeight.set(0, .5 * f.height, 0), x.halfWidth.applyMatrix4(S), x.halfHeight.applyMatrix4(S), w.rectArea[l] = x, l++;
                            else if (f.isPointLight) (x = b.get(f)).position.setFromMatrixPosition(f.matrixWorld), x.position.applyMatrix4(h), x.color.copy(f.color).multiplyScalar(f.intensity), x.distance = f.distance, x.decay = 0 === f.distance ? 0 : f.decay, x.shadow = f.castShadow, f.castShadow && (_ = f.shadow, x.shadowBias = _.bias, x.shadowRadius = _.radius, x.shadowMapSize = _.mapSize, x.shadowCameraNear = _.camera.near, x.shadowCameraFar = _.camera.far), w.pointShadowMap[s] = y, w.pointShadowMatrix[s] = f.shadow.matrix, w.point[s] = x, s++;
                            else if (f.isHemisphereLight) {
                                var x;
                                (x = b.get(f)).direction.setFromMatrixPosition(f.matrixWorld), x.direction.transformDirection(h), x.direction.normalize(), x.skyColor.copy(f.color).multiplyScalar(g), x.groundColor.copy(f.groundColor).multiplyScalar(g), w.hemi[u] = x, u++
                            }
                        }
                        w.ambient[0] = r, w.ambient[1] = i, w.ambient[2] = o, w.directional.length = a, w.spot.length = c, w.rectArea.length = l, w.point.length = s, w.hemi.length = u, w.hash = w.id + "," + a + "," + s + "," + c + "," + l + "," + u + "," + t.length
                    },
                    state: w
                }
            }

            function qo() {
                var t = new Vo,
                    n = [],
                    r = [],
                    i = [];
                return {
                    init: function () {
                        n.length = 0, r.length = 0, i.length = 0
                    },
                    state: {
                        lightsArray: n,
                        shadowsArray: r,
                        spritesArray: i,
                        lights: t
                    },
                    setupLights: function (e) {
                        t.setup(n, r, e)
                    },
                    pushLight: function (e) {
                        n.push(e)
                    },
                    pushShadow: function (e) {
                        r.push(e)
                    },
                    pushSprite: function (e) {
                        i.push(e)
                    }
                }
            }

            function Wo() {
                var i = {};
                return {
                    get: function (e, t) {
                        var n = e.id + "," + t.id,
                            r = i[n];
                        return void 0 === r && (r = new qo, i[n] = r), r
                    },
                    dispose: function () {
                        i = {}
                    }
                }
            }

            function Xo(e) {
                ri.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Ot, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e)
            }

            function Yo(e) {
                ri.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ut, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e)
            }

            function Jo(_, m, e) {
                for (var x = new pn, b = new Nt, w = new jt, E = new jt(e, e), T = new Ut, S = new Ut, v = 1, y = 2, t = 1 + (v | y), M = new Array(t), A = new Array(t), C = {}, L = {
                    0: J,
                    1: j,
                    2: Z
                }, R = [new Ut(1, 0, 0), new Ut(-1, 0, 0), new Ut(0, 0, 1), new Ut(0, 0, -1), new Ut(0, 1, 0), new Ut(0, -1, 0)], P = [new Ut(0, 1, 0), new Ut(0, 1, 0), new Ut(0, 1, 0), new Ut(0, 1, 0), new Ut(0, 0, 1), new Ut(0, 0, -1)], O = [new an, new an, new an, new an, new an, new an], n = 0; n !== t; ++n) {
                    var r = 0 != (n & v),
                        i = 0 != (n & y),
                        o = new Xo({
                            depthPacking: It,
                            morphTargets: r,
                            skinning: i
                        });
                    M[n] = o;
                    var a = new Yo({
                        morphTargets: r,
                        skinning: i
                    });
                    A[n] = a
                }
                var I = this;

                function g(e, t, n, r, i, o) {
                    var a = e.geometry,
                        s = null,
                        c = M,
                        l = e.customDepthMaterial;
                    if (n && (c = A, l = e.customDistanceMaterial), l) s = l;
                    else {
                        var u = !1;
                        t.morphTargets && (a && a.isBufferGeometry ? u = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : a && a.isGeometry && (u = a.morphTargets && 0 < a.morphTargets.length)), e.isSkinnedMesh && !1 === t.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var h = e.isSkinnedMesh && t.skinning,
                            d = 0;
                        u && (d |= v), h && (d |= y), s = c[d]
                    }
                    if (_.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length) {
                        var p = s.uuid,
                            f = t.uuid,
                            m = C[p];
                        void 0 === m && (m = {}, C[p] = m);
                        var g = m[f];
                        void 0 === g && (g = s.clone(), m[f] = g), s = g
                    }
                    return s.visible = t.visible, s.wireframe = t.wireframe, s.side = null != t.shadowSide ? t.shadowSide : L[t.side], s.clipShadows = t.clipShadows, s.clippingPlanes = t.clippingPlanes, s.clipIntersection = t.clipIntersection, s.wireframeLinewidth = t.wireframeLinewidth, s.linewidth = t.linewidth, n && s.isMeshDistanceMaterial && (s.referencePosition.copy(r), s.nearDistance = i, s.farDistance = o), s
                }

                function D(e, t, n, r) {
                    if (!1 !== e.visible) {
                        if (e.layers.test(t.layers) && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || x.intersectsObject(e))) {
                            e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                            var i = m.update(e),
                                o = e.material;
                            if (Array.isArray(o))
                                for (var a = i.groups, s = 0, c = a.length; s < c; s++) {
                                    var l = a[s],
                                        u = o[l.materialIndex];
                                    if (u && u.visible) {
                                        var h = g(e, u, r, S, n.near, n.far);
                                        _.renderBufferDirect(n, null, i, h, e, l)
                                    }
                                } else if (o.visible) {
                                    h = g(e, o, r, S, n.near, n.far);
                                    _.renderBufferDirect(n, null, i, h, e, null)
                                }
                        }
                        for (var d = e.children, p = 0, f = d.length; p < f; p++) D(d[p], t, n, r)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = k, this.render = function (e, t, n) {
                    if (!1 !== I.enabled && (!1 !== I.autoUpdate || !1 !== I.needsUpdate) && 0 !== e.length) {
                        var r, i = _.context,
                            o = _.state;
                        o.disable(i.BLEND), o.buffers.color.setClear(1, 1, 1, 1), o.buffers.depth.setTest(!0), o.setScissorTest(!1);
                        for (var a = 0, s = e.length; a < s; a++) {
                            var c = e[a],
                                l = c.shadow,
                                u = c && c.isPointLight;
                            if (void 0 !== l) {
                                var h = l.camera;
                                if (w.copy(l.mapSize), w.min(E), u) {
                                    var d = w.x,
                                        p = w.y;
                                    O[0].set(2 * d, p, d, p), O[1].set(0, p, d, p), O[2].set(3 * d, p, d, p), O[3].set(d, p, d, p), O[4].set(3 * d, 0, d, p), O[5].set(d, 0, d, p), w.x *= 4, w.y *= 2
                                }
                                if (null === l.map) {
                                    var f = {
                                        minFilter: Le,
                                        magFilter: Le,
                                        format: Je
                                    };
                                    l.map = new sn(w.x, w.y, f), l.map.texture.name = c.name + ".shadowMap", h.updateProjectionMatrix()
                                }
                                l.isSpotLightShadow && l.update(c);
                                var m = l.map,
                                    g = l.matrix;
                                S.setFromMatrixPosition(c.matrixWorld), h.position.copy(S), u ? (r = 6, g.makeTranslation(-S.x, -S.y, -S.z)) : (r = 1, T.setFromMatrixPosition(c.target.matrixWorld), h.lookAt(T), h.updateMatrixWorld(), g.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), g.multiply(h.projectionMatrix), g.multiply(h.matrixWorldInverse)), _.setRenderTarget(m), _.clear();
                                for (var v = 0; v < r; v++) {
                                    if (u) {
                                        T.copy(h.position), T.add(R[v]), h.up.copy(P[v]), h.lookAt(T), h.updateMatrixWorld();
                                        var y = O[v];
                                        o.viewport(y)
                                    }
                                    b.multiplyMatrices(h.projectionMatrix, h.matrixWorldInverse), x.setFromMatrix(b), D(t, n, h, u)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", c, "has no shadow.")
                        }
                        I.needsUpdate = !1
                    }
                }
            }

            function Zo(e, t, n, r, i, o, a, s, c) {
                on.call(this, e, t, n, r, i, o, a, s, c), this.needsUpdate = !0
            }

            function $o(p, f, m, g, s) {
                var v, y, _, x, b, w, E = new Ut,
                    T = new kt,
                    S = new Ut;

                function M() {
                    var e, t, n, r = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        i = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    v = f.createBuffer(), y = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, v), f.bufferData(f.ARRAY_BUFFER, r, f.STATIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, y), f.bufferData(f.ELEMENT_ARRAY_BUFFER, i, f.STATIC_DRAW), e = f.createProgram(), t = f.createShader(f.VERTEX_SHADER), n = f.createShader(f.FRAGMENT_SHADER), f.shaderSource(t, ["precision " + s.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 center;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = ( position - center ) * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n")), f.shaderSource(n, ["precision " + s.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n")), f.compileShader(t), f.compileShader(n), f.attachShader(e, t), f.attachShader(e, n), f.linkProgram(e), _ = e, x = {
                        position: f.getAttribLocation(_, "position"),
                        uv: f.getAttribLocation(_, "uv")
                    }, b = {
                        uvOffset: f.getUniformLocation(_, "uvOffset"),
                        uvScale: f.getUniformLocation(_, "uvScale"),
                        rotation: f.getUniformLocation(_, "rotation"),
                        center: f.getUniformLocation(_, "center"),
                        scale: f.getUniformLocation(_, "scale"),
                        color: f.getUniformLocation(_, "color"),
                        map: f.getUniformLocation(_, "map"),
                        opacity: f.getUniformLocation(_, "opacity"),
                        modelViewMatrix: f.getUniformLocation(_, "modelViewMatrix"),
                        projectionMatrix: f.getUniformLocation(_, "projectionMatrix"),
                        fogType: f.getUniformLocation(_, "fogType"),
                        fogDensity: f.getUniformLocation(_, "fogDensity"),
                        fogNear: f.getUniformLocation(_, "fogNear"),
                        fogFar: f.getUniformLocation(_, "fogFar"),
                        fogColor: f.getUniformLocation(_, "fogColor"),
                        fogDepth: f.getUniformLocation(_, "fogDepth"),
                        alphaTest: f.getUniformLocation(_, "alphaTest")
                    };
                    var o = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    o.width = 8, o.height = 8;
                    var a = o.getContext("2d");
                    a.fillStyle = "white", a.fillRect(0, 0, 8, 8), w = new Zo(o)
                }

                function A(e, t) {
                    return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : t.id - e.id
                }
                this.render = function (e, t, n) {
                    if (0 !== e.length) {
                        void 0 === _ && M(), m.useProgram(_), m.initAttributes(), m.enableAttribute(x.position), m.enableAttribute(x.uv), m.disableUnusedAttributes(), m.disable(f.CULL_FACE), m.enable(f.BLEND), f.bindBuffer(f.ARRAY_BUFFER, v), f.vertexAttribPointer(x.position, 2, f.FLOAT, !1, 16, 0), f.vertexAttribPointer(x.uv, 2, f.FLOAT, !1, 16, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, y), f.uniformMatrix4fv(b.projectionMatrix, !1, n.projectionMatrix.elements), m.activeTexture(f.TEXTURE0), f.uniform1i(b.map, 0);
                        var r = 0,
                            i = 0,
                            o = t.fog;
                        o ? (f.uniform3f(b.fogColor, o.color.r, o.color.g, o.color.b), o.isFog ? (f.uniform1f(b.fogNear, o.near), f.uniform1f(b.fogFar, o.far), f.uniform1i(b.fogType, 1), i = r = 1) : o.isFogExp2 && (f.uniform1f(b.fogDensity, o.density), f.uniform1i(b.fogType, 2), i = r = 2)) : (f.uniform1i(b.fogType, 0), i = r = 0);
                        for (var a = 0, s = e.length; a < s; a++) {
                            (u = e[a]).modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, u.matrixWorld), u.z = -u.modelViewMatrix.elements[14]
                        }
                        e.sort(A);
                        var c = [],
                            l = [];
                        for (a = 0, s = e.length; a < s; a++) {
                            var u, h = (u = e[a]).material;
                            if (!1 !== h.visible) {
                                u.onBeforeRender(p, t, n, void 0, h, void 0), f.uniform1f(b.alphaTest, h.alphaTest), f.uniformMatrix4fv(b.modelViewMatrix, !1, u.modelViewMatrix.elements), u.matrixWorld.decompose(E, T, S), c[0] = S.x, c[1] = S.y, l[0] = u.center.x - .5, l[1] = u.center.y - .5;
                                var d = 0;
                                t.fog && h.fog && (d = i), r !== d && (f.uniform1i(b.fogType, d), r = d), null !== h.map ? (f.uniform2f(b.uvOffset, h.map.offset.x, h.map.offset.y), f.uniform2f(b.uvScale, h.map.repeat.x, h.map.repeat.y)) : (f.uniform2f(b.uvOffset, 0, 0), f.uniform2f(b.uvScale, 1, 1)), f.uniform1f(b.opacity, h.opacity), f.uniform3f(b.color, h.color.r, h.color.g, h.color.b), f.uniform1f(b.rotation, h.rotation), f.uniform2fv(b.center, l), f.uniform2fv(b.scale, c), m.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst, h.blendEquationAlpha, h.blendSrcAlpha, h.blendDstAlpha, h.premultipliedAlpha), m.buffers.depth.setTest(h.depthTest), m.buffers.depth.setMask(h.depthWrite), m.buffers.color.setMask(h.colorWrite), g.setTexture2D(h.map || w, 0), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), u.onAfterRender(p, t, n, void 0, h, void 0)
                            }
                        }
                        m.enable(f.CULL_FACE), m.reset()
                    }
                }
            }

            function Qo(u, n, c) {
                var r = new function () {
                    var t = !1,
                        o = new an,
                        n = null,
                        a = new an(0, 0, 0, 0);
                    return {
                        setMask: function (e) {
                            n === e || t || (u.colorMask(e, e, e, e), n = e)
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (e, t, n, r, i) {
                            !0 === i && (e *= r, t *= r, n *= r), o.set(e, t, n, r), !1 === a.equals(o) && (u.clearColor(e, t, n, r), a.copy(o))
                        },
                        reset: function () {
                            t = !1, n = null, a.set(-1, 0, 0, 0)
                        }
                    }
                },
                    i = new function () {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function (e) {
                                e ? N(u.DEPTH_TEST) : k(u.DEPTH_TEST)
                            },
                            setMask: function (e) {
                                n === e || t || (u.depthMask(e), n = e)
                            },
                            setFunc: function (e) {
                                if (r !== e) {
                                    if (e) switch (e) {
                                        case ne:
                                            u.depthFunc(u.NEVER);
                                            break;
                                        case re:
                                            u.depthFunc(u.ALWAYS);
                                            break;
                                        case ie:
                                            u.depthFunc(u.LESS);
                                            break;
                                        case oe:
                                            u.depthFunc(u.LEQUAL);
                                            break;
                                        case ae:
                                            u.depthFunc(u.EQUAL);
                                            break;
                                        case se:
                                            u.depthFunc(u.GEQUAL);
                                            break;
                                        case ce:
                                            u.depthFunc(u.GREATER);
                                            break;
                                        case le:
                                            u.depthFunc(u.NOTEQUAL);
                                            break;
                                        default:
                                            u.depthFunc(u.LEQUAL)
                                    } else u.depthFunc(u.LEQUAL);
                                    r = e
                                }
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (e) {
                                i !== e && (u.clearDepth(e), i = e)
                            },
                            reset: function () {
                                t = !1, i = r = n = null
                            }
                        }
                    },
                    t = new function () {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null,
                            o = null,
                            a = null,
                            s = null,
                            c = null,
                            l = null;
                        return {
                            setTest: function (e) {
                                e ? N(u.STENCIL_TEST) : k(u.STENCIL_TEST)
                            },
                            setMask: function (e) {
                                n === e || t || (u.stencilMask(e), n = e)
                            },
                            setFunc: function (e, t, n) {
                                r === e && i === t && o === n || (u.stencilFunc(e, t, n), r = e, i = t, o = n)
                            },
                            setOp: function (e, t, n) {
                                a === e && s === t && c === n || (u.stencilOp(e, t, n), a = e, s = t, c = n)
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (e) {
                                l !== e && (u.clearStencil(e), l = e)
                            },
                            reset: function () {
                                t = !1, l = c = s = a = o = i = r = n = null
                            }
                        }
                    },
                    e = u.getParameter(u.MAX_VERTEX_ATTRIBS),
                    o = new Uint8Array(e),
                    a = new Uint8Array(e),
                    s = new Uint8Array(e),
                    l = {},
                    h = null,
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    v = null,
                    y = null,
                    _ = null,
                    x = !1,
                    b = null,
                    w = null,
                    E = null,
                    T = null,
                    S = null,
                    M = u.getParameter(u.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    A = !1,
                    C = 0,
                    L = u.getParameter(u.VERSION); - 1 !== L.indexOf("WebGL") ? (C = parseFloat(/^WebGL\ ([0-9])/.exec(L)[1]), A = 1 <= C) : -1 !== L.indexOf("OpenGL ES") && (C = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(L)[1]), A = 2 <= C);
                var R = null,
                    P = {},
                    O = new an,
                    I = new an;

                function D(e, t, n) {
                    var r = new Uint8Array(4),
                        i = u.createTexture();
                    u.bindTexture(e, i), u.texParameteri(e, u.TEXTURE_MIN_FILTER, u.NEAREST), u.texParameteri(e, u.TEXTURE_MAG_FILTER, u.NEAREST);
                    for (var o = 0; o < n; o++) u.texImage2D(t + o, 0, u.RGBA, 1, 1, 0, u.RGBA, u.UNSIGNED_BYTE, r);
                    return i
                }
                var j = {};

                function N(e) {
                    !0 !== l[e] && (u.enable(e), l[e] = !0)
                }

                function k(e) {
                    !1 !== l[e] && (u.disable(e), l[e] = !1)
                }

                function U(e, t, n, r, i, o, a, s) {
                    if (e !== W ? N(u.BLEND) : k(u.BLEND), e !== K) {
                        if (e !== p || s !== x) switch (e) {
                            case Y:
                                s ? (u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD), u.blendFuncSeparate(u.ONE, u.ONE, u.ONE, u.ONE)) : (u.blendEquation(u.FUNC_ADD), u.blendFunc(u.SRC_ALPHA, u.ONE));
                                break;
                            case $:
                                s ? (u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD), u.blendFuncSeparate(u.ZERO, u.ZERO, u.ONE_MINUS_SRC_COLOR, u.ONE_MINUS_SRC_ALPHA)) : (u.blendEquation(u.FUNC_ADD), u.blendFunc(u.ZERO, u.ONE_MINUS_SRC_COLOR));
                                break;
                            case Q:
                                s ? (u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD), u.blendFuncSeparate(u.ZERO, u.SRC_COLOR, u.ZERO, u.SRC_ALPHA)) : (u.blendEquation(u.FUNC_ADD), u.blendFunc(u.ZERO, u.SRC_COLOR));
                                break;
                            default:
                                s ? (u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD), u.blendFuncSeparate(u.ONE, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA)) : (u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD), u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA))
                        }
                        _ = y = v = g = m = f = null
                    } else i = i || t, o = o || n, a = a || r, t === f && i === v || (u.blendEquationSeparate(c.convert(t), c.convert(i)), f = t, v = i), n === m && r === g && o === y && a === _ || (u.blendFuncSeparate(c.convert(n), c.convert(r), c.convert(o), c.convert(a)), m = n, g = r, y = o, _ = a);
                    p = e, x = s
                }

                function H(e) {
                    b !== e && (e ? u.frontFace(u.CW) : u.frontFace(u.CCW), b = e)
                }

                function B(e) {
                    e !== G ? (N(u.CULL_FACE), e !== w && (e === V ? u.cullFace(u.BACK) : e === q ? u.cullFace(u.FRONT) : u.cullFace(u.FRONT_AND_BACK))) : k(u.CULL_FACE), w = e
                }

                function F(e, t, n) {
                    e ? (N(u.POLYGON_OFFSET_FILL), T === t && S === n || (u.polygonOffset(t, n), T = t, S = n)) : k(u.POLYGON_OFFSET_FILL)
                }

                function z(e) {
                    void 0 === e && (e = u.TEXTURE0 + M - 1), R !== e && (u.activeTexture(e), R = e)
                }
                return j[u.TEXTURE_2D] = D(u.TEXTURE_2D, u.TEXTURE_2D, 1), j[u.TEXTURE_CUBE_MAP] = D(u.TEXTURE_CUBE_MAP, u.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r.setClear(0, 0, 0, 1), i.setClear(1), t.setClear(0), N(u.DEPTH_TEST), i.setFunc(oe), H(!1), B(V), N(u.CULL_FACE), N(u.BLEND), U(X), {
                    buffers: {
                        color: r,
                        depth: i,
                        stencil: t
                    },
                    initAttributes: function () {
                        for (var e = 0, t = o.length; e < t; e++) o[e] = 0
                    },
                    enableAttribute: function (e) {
                        o[e] = 1, 0 === a[e] && (u.enableVertexAttribArray(e), a[e] = 1), 0 !== s[e] && (n.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(e, 0), s[e] = 0)
                    },
                    enableAttributeAndDivisor: function (e, t) {
                        o[e] = 1, 0 === a[e] && (u.enableVertexAttribArray(e), a[e] = 1), s[e] !== t && (n.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(e, t), s[e] = t)
                    },
                    disableUnusedAttributes: function () {
                        for (var e = 0, t = a.length; e !== t; ++e) a[e] !== o[e] && (u.disableVertexAttribArray(e), a[e] = 0)
                    },
                    enable: N,
                    disable: k,
                    getCompressedTextureFormats: function () {
                        if (null === h && (h = [], n.get("WEBGL_compressed_texture_pvrtc") || n.get("WEBGL_compressed_texture_s3tc") || n.get("WEBGL_compressed_texture_etc1") || n.get("WEBGL_compressed_texture_astc")))
                            for (var e = u.getParameter(u.COMPRESSED_TEXTURE_FORMATS), t = 0; t < e.length; t++) h.push(e[t]);
                        return h
                    },
                    useProgram: function (e) {
                        return d !== e && (u.useProgram(e), d = e, !0)
                    },
                    setBlending: U,
                    setMaterial: function (e, t) {
                        e.side === Z ? k(u.CULL_FACE) : N(u.CULL_FACE);
                        var n = e.side === J;
                        t && (n = !n), H(n), !0 === e.transparent ? U(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : U(W), i.setFunc(e.depthFunc), i.setTest(e.depthTest), i.setMask(e.depthWrite), r.setMask(e.colorWrite), F(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                    },
                    setFlipSided: H,
                    setCullFace: B,
                    setLineWidth: function (e) {
                        e !== E && (A && u.lineWidth(e), E = e)
                    },
                    setPolygonOffset: F,
                    setScissorTest: function (e) {
                        e ? N(u.SCISSOR_TEST) : k(u.SCISSOR_TEST)
                    },
                    activeTexture: z,
                    bindTexture: function (e, t) {
                        null === R && z();
                        var n = P[R];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        }, P[R] = n), n.type === e && n.texture === t || (u.bindTexture(e, t || j[e]), n.type = e, n.texture = t)
                    },
                    compressedTexImage2D: function () {
                        try {
                            u.compressedTexImage2D.apply(u, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function () {
                        try {
                            u.texImage2D.apply(u, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function (e) {
                        !1 === O.equals(e) && (u.scissor(e.x, e.y, e.z, e.w), O.copy(e))
                    },
                    viewport: function (e) {
                        !1 === I.equals(e) && (u.viewport(e.x, e.y, e.z, e.w), I.copy(e))
                    },
                    reset: function () {
                        for (var e = 0; e < a.length; e++) 1 === a[e] && (u.disableVertexAttribArray(e), a[e] = 0);
                        l = {}, P = {}, w = b = p = d = R = h = null, r.reset(), i.reset(), t.reset()
                    }
                }
            }

            function Ko(m, i, g, v, y, _, x) {
                var f, b = "undefined" != typeof WebGL2RenderingContext && m instanceof WebGL2RenderingContext,
                    s = {};

                function w(e, t) {
                    if (e.width > t || e.height > t) {
                        if ("data" in e) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + e.width + "x" + e.height + ").");
                        var n = t / Math.max(e.width, e.height),
                            r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return r.width = Math.floor(e.width * n), r.height = Math.floor(e.height * n), r.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, r.width, r.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height, e), r
                    }
                    return e
                }

                function E(e) {
                    return Dt.isPowerOfTwo(e.width) && Dt.isPowerOfTwo(e.height)
                }

                function T(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== Le && e.minFilter !== Oe
                }

                function S(e, t, n, r) {
                    m.generateMipmap(e), v.get(t).__maxMipLevel = Math.log(Math.max(n, r)) * Math.LOG2E
                }

                function o(e) {
                    return e === Le || e === Re || e === Pe ? m.NEAREST : m.LINEAR
                }

                function M(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", M),
                        function (e) {
                            var t = v.get(e);
                            if (e.image && t.__image__webglTextureCube) m.deleteTexture(t.__image__webglTextureCube);
                            else {
                                if (void 0 === t.__webglInit) return;
                                m.deleteTexture(t.__webglTexture)
                            }
                            v.remove(e)
                        }(t), t.isVideoTexture && delete s[t.id], x.memory.textures--
                }

                function a(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", a),
                        function (e) {
                            var t = v.get(e),
                                n = v.get(e.texture);
                            if (!e) return;
                            void 0 !== n.__webglTexture && m.deleteTexture(n.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLRenderTargetCube)
                                for (var r = 0; r < 6; r++) m.deleteFramebuffer(t.__webglFramebuffer[r]), t.__webglDepthbuffer && m.deleteRenderbuffer(t.__webglDepthbuffer[r]);
                            else m.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && m.deleteRenderbuffer(t.__webglDepthbuffer);
                            v.remove(e.texture), v.remove(e)
                        }(t), x.memory.textures--
                }

                function c(e, t) {
                    var n, r, i, o = v.get(e);
                    if (e.isVideoTexture && (r = (n = e).id, i = x.render.frame, s[r] !== i && (s[r] = i, n.update())), 0 < e.version && o.__version !== e.version) {
                        var a = e.image;
                        if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                        else {
                            if (!1 !== a.complete) return void
                                function (e, t, n) {
                                    void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", M), e.__webglTexture = m.createTexture(), x.memory.textures++);
                                    g.activeTexture(m.TEXTURE0 + n), g.bindTexture(m.TEXTURE_2D, e.__webglTexture), m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, t.flipY), m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), m.pixelStorei(m.UNPACK_ALIGNMENT, t.unpackAlignment);
                                    var r = w(t.image, y.maxTextureSize);
                                    o = t, (o.wrapS !== Ae || o.wrapT !== Ae || o.minFilter !== Le && o.minFilter !== Oe) && !1 === E(r) && (r = (i = r) instanceof HTMLImageElement || i instanceof HTMLCanvasElement || i instanceof ImageBitmap ? (void 0 === f && (f = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), f.width = Dt.floorPowerOfTwo(i.width), f.height = Dt.floorPowerOfTwo(i.height), f.getContext("2d").drawImage(i, 0, 0, f.width, f.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + i.width + "x" + i.height + "). Resized to " + f.width + "x" + f.height, i), f) : i);
                                    var i;
                                    var o;
                                    var a = E(r),
                                        s = _.convert(t.format),
                                        c = _.convert(t.type);
                                    A(m.TEXTURE_2D, t, a);
                                    var l, u = t.mipmaps;
                                    if (t.isDepthTexture) {
                                        var h = m.DEPTH_COMPONENT;
                                        if (t.type === Fe) {
                                            if (!b) throw new Error("Float Depth Texture only supported in WebGL2.0");
                                            h = m.DEPTH_COMPONENT32F
                                        } else b && (h = m.DEPTH_COMPONENT16);
                                        t.format === Ke && h === m.DEPTH_COMPONENT && t.type !== Ue && t.type !== Be && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = Ue, c = _.convert(t.type)), t.format === et && (h = m.DEPTH_STENCIL, t.type !== We && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = We, c = _.convert(t.type))), g.texImage2D(m.TEXTURE_2D, 0, h, r.width, r.height, 0, s, c, null)
                                    } else if (t.isDataTexture)
                                        if (0 < u.length && a) {
                                            for (var d = 0, p = u.length; d < p; d++) l = u[d], g.texImage2D(m.TEXTURE_2D, d, s, l.width, l.height, 0, s, c, l.data);
                                            t.generateMipmaps = !1, e.__maxMipLevel = u.length - 1
                                        } else g.texImage2D(m.TEXTURE_2D, 0, s, r.width, r.height, 0, s, c, r.data), e.__maxMipLevel = 0;
                                    else if (t.isCompressedTexture) {
                                        for (var d = 0, p = u.length; d < p; d++) l = u[d], t.format !== Je && t.format !== Ye ? -1 < g.getCompressedTextureFormats().indexOf(s) ? g.compressedTexImage2D(m.TEXTURE_2D, d, s, l.width, l.height, 0, l.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : g.texImage2D(m.TEXTURE_2D, d, s, l.width, l.height, 0, s, c, l.data);
                                        e.__maxMipLevel = u.length - 1
                                    } else if (0 < u.length && a) {
                                        for (var d = 0, p = u.length; d < p; d++) l = u[d], g.texImage2D(m.TEXTURE_2D, d, s, s, c, l);
                                        t.generateMipmaps = !1, e.__maxMipLevel = u.length - 1
                                    } else g.texImage2D(m.TEXTURE_2D, 0, s, s, c, r), e.__maxMipLevel = 0;
                                    T(t, a) && S(m.TEXTURE_2D, t, r.width, r.height);
                                    e.__version = t.version, t.onUpdate && t.onUpdate(t)
                                }(o, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                        }
                    }
                    g.activeTexture(m.TEXTURE0 + t), g.bindTexture(m.TEXTURE_2D, o.__webglTexture)
                }

                function A(e, t, n) {
                    var r;
                    if (n ? (m.texParameteri(e, m.TEXTURE_WRAP_S, _.convert(t.wrapS)), m.texParameteri(e, m.TEXTURE_WRAP_T, _.convert(t.wrapT)), m.texParameteri(e, m.TEXTURE_MAG_FILTER, _.convert(t.magFilter)), m.texParameteri(e, m.TEXTURE_MIN_FILTER, _.convert(t.minFilter))) : (m.texParameteri(e, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(e, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), t.wrapS === Ae && t.wrapT === Ae || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", t), m.texParameteri(e, m.TEXTURE_MAG_FILTER, o(t.magFilter)), m.texParameteri(e, m.TEXTURE_MIN_FILTER, o(t.minFilter)), t.minFilter !== Le && t.minFilter !== Oe && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", t)), r = i.get("EXT_texture_filter_anisotropic")) {
                        if (t.type === Fe && null === i.get("OES_texture_float_linear")) return;
                        if (t.type === ze && null === i.get("OES_texture_half_float_linear")) return;
                        (1 < t.anisotropy || v.get(t).__currentAnisotropy) && (m.texParameterf(e, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, y.getMaxAnisotropy())), v.get(t).__currentAnisotropy = t.anisotropy)
                    }
                }

                function l(e, t, n, r) {
                    var i = _.convert(t.texture.format),
                        o = _.convert(t.texture.type);
                    g.texImage2D(r, 0, i, t.width, t.height, 0, i, o, null), m.bindFramebuffer(m.FRAMEBUFFER, e), m.framebufferTexture2D(m.FRAMEBUFFER, n, r, v.get(t.texture).__webglTexture, 0), m.bindFramebuffer(m.FRAMEBUFFER, null)
                }

                function u(e, t) {
                    m.bindRenderbuffer(m.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_COMPONENT16, t.width, t.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_STENCIL, t.width, t.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, e)) : m.renderbufferStorage(m.RENDERBUFFER, m.RGBA4, t.width, t.height), m.bindRenderbuffer(m.RENDERBUFFER, null)
                }

                function h(e) {
                    var t = v.get(e),
                        n = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (n) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function (e, t) {
                            if (t && t.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (m.bindFramebuffer(m.FRAMEBUFFER, e), !t.depthTexture || !t.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            v.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), c(t.depthTexture, 0);
                            var n = v.get(t.depthTexture).__webglTexture;
                            if (t.depthTexture.format === Ke) m.framebufferTexture2D(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.TEXTURE_2D, n, 0);
                            else {
                                if (t.depthTexture.format !== et) throw new Error("Unknown depthTexture format");
                                m.framebufferTexture2D(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.TEXTURE_2D, n, 0)
                            }
                        }(t.__webglFramebuffer, e)
                    } else if (n) {
                        t.__webglDepthbuffer = [];
                        for (var r = 0; r < 6; r++) m.bindFramebuffer(m.FRAMEBUFFER, t.__webglFramebuffer[r]), t.__webglDepthbuffer[r] = m.createRenderbuffer(), u(t.__webglDepthbuffer[r], e)
                    } else m.bindFramebuffer(m.FRAMEBUFFER, t.__webglFramebuffer), t.__webglDepthbuffer = m.createRenderbuffer(), u(t.__webglDepthbuffer, e);
                    m.bindFramebuffer(m.FRAMEBUFFER, null)
                }
                this.setTexture2D = c, this.setTextureCube = function (e, t) {
                    var n = v.get(e);
                    if (6 === e.image.length)
                        if (0 < e.version && n.__version !== e.version) {
                            n.__image__webglTextureCube || (e.addEventListener("dispose", M), n.__image__webglTextureCube = m.createTexture(), x.memory.textures++), g.activeTexture(m.TEXTURE0 + t), g.bindTexture(m.TEXTURE_CUBE_MAP, n.__image__webglTextureCube), m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, e.flipY);
                            for (var r = e && e.isCompressedTexture, i = e.image[0] && e.image[0].isDataTexture, o = [], a = 0; a < 6; a++) o[a] = r || i ? i ? e.image[a].image : e.image[a] : w(e.image[a], y.maxCubemapSize);
                            var s = o[0],
                                c = E(s),
                                l = _.convert(e.format),
                                u = _.convert(e.type);
                            for (A(m.TEXTURE_CUBE_MAP, e, c), a = 0; a < 6; a++)
                                if (r)
                                    for (var h, d = o[a].mipmaps, p = 0, f = d.length; p < f; p++) h = d[p], e.format !== Je && e.format !== Ye ? -1 < g.getCompressedTextureFormats().indexOf(l) ? g.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + a, p, l, h.width, h.height, 0, h.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + a, p, l, h.width, h.height, 0, l, u, h.data);
                                else i ? g.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, l, o[a].width, o[a].height, 0, l, u, o[a].data) : g.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, l, l, u, o[a]);
                            n.__maxMipLevel = r ? d.length - 1 : 0, T(e, c) && S(m.TEXTURE_CUBE_MAP, e, s.width, s.height), n.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else g.activeTexture(m.TEXTURE0 + t), g.bindTexture(m.TEXTURE_CUBE_MAP, n.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function (e, t) {
                    g.activeTexture(m.TEXTURE0 + t), g.bindTexture(m.TEXTURE_CUBE_MAP, v.get(e).__webglTexture)
                }, this.setupRenderTarget = function (e) {
                    var t = v.get(e),
                        n = v.get(e.texture);
                    e.addEventListener("dispose", a), n.__webglTexture = m.createTexture(), x.memory.textures++;
                    var r = !0 === e.isWebGLRenderTargetCube,
                        i = E(e);
                    if (r) {
                        t.__webglFramebuffer = [];
                        for (var o = 0; o < 6; o++) t.__webglFramebuffer[o] = m.createFramebuffer()
                    } else t.__webglFramebuffer = m.createFramebuffer();
                    if (r) {
                        for (g.bindTexture(m.TEXTURE_CUBE_MAP, n.__webglTexture), A(m.TEXTURE_CUBE_MAP, e.texture, i), o = 0; o < 6; o++) l(t.__webglFramebuffer[o], e, m.COLOR_ATTACHMENT0, m.TEXTURE_CUBE_MAP_POSITIVE_X + o);
                        T(e.texture, i) && S(m.TEXTURE_CUBE_MAP, e.texture, e.width, e.height), g.bindTexture(m.TEXTURE_CUBE_MAP, null)
                    } else g.bindTexture(m.TEXTURE_2D, n.__webglTexture), A(m.TEXTURE_2D, e.texture, i), l(t.__webglFramebuffer, e, m.COLOR_ATTACHMENT0, m.TEXTURE_2D), T(e.texture, i) && S(m.TEXTURE_2D, e.texture, e.width, e.height), g.bindTexture(m.TEXTURE_2D, null);
                    e.depthBuffer && h(e)
                }, this.updateRenderTargetMipmap = function (e) {
                    var t = e.texture;
                    if (T(t, E(e))) {
                        var n = e.isWebGLRenderTargetCube ? m.TEXTURE_CUBE_MAP : m.TEXTURE_2D,
                            r = v.get(t).__webglTexture;
                        g.bindTexture(n, r), S(n, t, e.width, e.height), g.bindTexture(n, null)
                    }
                }
            }

            function ea(n, r) {
                return {
                    convert: function (e) {
                        var t;
                        if (e === Te) return n.REPEAT;
                        if (e === Ae) return n.CLAMP_TO_EDGE;
                        if (e === Ce) return n.MIRRORED_REPEAT;
                        if (e === Le) return n.NEAREST;
                        if (e === Re) return n.NEAREST_MIPMAP_NEAREST;
                        if (e === Pe) return n.NEAREST_MIPMAP_LINEAR;
                        if (e === Oe) return n.LINEAR;
                        if (e === Ie) return n.LINEAR_MIPMAP_NEAREST;
                        if (e === De) return n.LINEAR_MIPMAP_LINEAR;
                        if (e === je) return n.UNSIGNED_BYTE;
                        if (e === Ge) return n.UNSIGNED_SHORT_4_4_4_4;
                        if (e === Ve) return n.UNSIGNED_SHORT_5_5_5_1;
                        if (e === qe) return n.UNSIGNED_SHORT_5_6_5;
                        if (e === Ne) return n.BYTE;
                        if (e === ke) return n.SHORT;
                        if (e === Ue) return n.UNSIGNED_SHORT;
                        if (e === He) return n.INT;
                        if (e === Be) return n.UNSIGNED_INT;
                        if (e === Fe) return n.FLOAT;
                        if (e === ze && null !== (t = r.get("OES_texture_half_float"))) return t.HALF_FLOAT_OES;
                        if (e === Xe) return n.ALPHA;
                        if (e === Ye) return n.RGB;
                        if (e === Je) return n.RGBA;
                        if (e === Ze) return n.LUMINANCE;
                        if (e === $e) return n.LUMINANCE_ALPHA;
                        if (e === Ke) return n.DEPTH_COMPONENT;
                        if (e === et) return n.DEPTH_STENCIL;
                        if (e === M) return n.FUNC_ADD;
                        if (e === A) return n.FUNC_SUBTRACT;
                        if (e === C) return n.FUNC_REVERSE_SUBTRACT;
                        if (e === P) return n.ZERO;
                        if (e === O) return n.ONE;
                        if (e === I) return n.SRC_COLOR;
                        if (e === D) return n.ONE_MINUS_SRC_COLOR;
                        if (e === N) return n.SRC_ALPHA;
                        if (e === H) return n.ONE_MINUS_SRC_ALPHA;
                        if (e === B) return n.DST_ALPHA;
                        if (e === F) return n.ONE_MINUS_DST_ALPHA;
                        if (e === z) return n.DST_COLOR;
                        if (e === ee) return n.ONE_MINUS_DST_COLOR;
                        if (e === te) return n.SRC_ALPHA_SATURATE;
                        if ((e === tt || e === nt || e === rt || e === it) && null !== (t = r.get("WEBGL_compressed_texture_s3tc"))) {
                            if (e === tt) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (e === nt) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (e === rt) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (e === it) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((e === ot || e === at || e === st || e === ct) && null !== (t = r.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (e === ot) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (e === at) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (e === st) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (e === ct) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (e === lt && null !== (t = r.get("WEBGL_compressed_texture_etc1"))) return t.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((e === ut || e === ht || e === dt || e === pt || e === ft || e === mt || e === gt || e === vt || e === yt || e === _t || e === xt || e === bt || e === wt || e === Et) && null !== (t = r.get("WEBGL_compressed_texture_astc"))) return e;
                        if ((e === L || e === R) && null !== (t = r.get("EXT_blend_minmax"))) {
                            if (e === L) return t.MIN_EXT;
                            if (e === R) return t.MAX_EXT
                        }
                        return e === We && null !== (t = r.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : 0
                    }
                }
            }

            function ta(e, t, n, r) {
                Wn.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function na(e) {
                ta.call(this), this.cameras = e || []
            }

            function ra(r) {
                var s = this,
                    c = null,
                    l = null,
                    u = null,
                    h = new Nt,
                    d = new Nt;
                "undefined" != typeof window && "VRFrameData" in window && (l = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", e, !1));
                var p = new Nt,
                    f = new kt,
                    m = new Ut,
                    g = new ta;
                g.bounds = new an(0, 0, .5, 1), g.layers.enable(1);
                var v = new ta;
                v.bounds = new an(.5, 0, .5, 1), v.layers.enable(2);
                var i, o, y = new na([g, v]);

                function a() {
                    return null !== c && !0 === c.isPresenting
                }

                function e() {
                    if (a()) {
                        var e = c.getEyeParameters("left"),
                            t = e.renderWidth,
                            n = e.renderHeight;
                        o = r.getPixelRatio(), i = r.getSize(), r.setDrawingBufferSize(2 * t, n, 1)
                    } else s.enabled && r.setDrawingBufferSize(i.width, i.height, o)
                }
                y.layers.enable(1), y.layers.enable(2), this.enabled = !1, this.userHeight = 1.6, this.getDevice = function () {
                    return c
                }, this.setDevice = function (e) {
                    void 0 !== e && (c = e)
                }, this.setPoseTarget = function (e) {
                    void 0 !== e && (u = e)
                }, this.getCamera = function (e) {
                    if (null === c) return e;
                    c.depthNear = e.near, c.depthFar = e.far, c.getFrameData(l);
                    var t = c.stageParameters;
                    t ? h.fromArray(t.sittingToStandingTransform) : h.makeTranslation(0, s.userHeight, 0);
                    var n = l.pose,
                        r = null !== u ? u : e;
                    if (r.matrix.copy(h), r.matrix.decompose(r.position, r.quaternion, r.scale), null !== n.orientation && (f.fromArray(n.orientation), r.quaternion.multiply(f)), null !== n.position && (f.setFromRotationMatrix(h), m.fromArray(n.position), m.applyQuaternion(f), r.position.add(m)), r.updateMatrixWorld(), !1 === c.isPresenting) return e;
                    g.near = e.near, v.near = e.near, g.far = e.far, v.far = e.far, y.matrixWorld.copy(e.matrixWorld), y.matrixWorldInverse.copy(e.matrixWorldInverse), g.matrixWorldInverse.fromArray(l.leftViewMatrix), v.matrixWorldInverse.fromArray(l.rightViewMatrix), d.getInverse(h), g.matrixWorldInverse.multiply(d), v.matrixWorldInverse.multiply(d);
                    var i = r.parent;
                    null !== i && (p.getInverse(i.matrixWorld), g.matrixWorldInverse.multiply(p), v.matrixWorldInverse.multiply(p)), g.matrixWorld.getInverse(g.matrixWorldInverse), v.matrixWorld.getInverse(v.matrixWorldInverse), g.projectionMatrix.fromArray(l.leftProjectionMatrix), v.projectionMatrix.fromArray(l.rightProjectionMatrix), y.projectionMatrix.copy(g.projectionMatrix);
                    var o = c.getLayers();
                    if (o.length) {
                        var a = o[0];
                        null !== a.leftBounds && 4 === a.leftBounds.length && g.bounds.fromArray(a.leftBounds), null !== a.rightBounds && 4 === a.rightBounds.length && v.bounds.fromArray(a.rightBounds)
                    }
                    return y
                }, this.getStandingMatrix = function () {
                    return h
                }, this.submitFrame = function () {
                    a() && c.submitFrame()
                }, this.dispose = function () {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", e)
                }
            }

            function ia(e) {
                console.log("THREE.WebGLRenderer", "92");
                var i = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    t = void 0 !== e.context ? e.context : null,
                    n = void 0 !== e.alpha && e.alpha,
                    r = void 0 === e.depth || e.depth,
                    o = void 0 === e.stencil || e.stencil,
                    a = void 0 !== e.antialias && e.antialias,
                    s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    l = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    p = null,
                    k = null;
                this.domElement = i, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Me, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var U, T, H, B, u, F, h, S, M, f, g, d, m, v, A, C, L, y, _, z = this,
                    x = !1,
                    b = null,
                    w = null,
                    G = -1,
                    R = "",
                    V = null,
                    q = null,
                    E = new an,
                    P = new an,
                    O = null,
                    W = 0,
                    I = i.width,
                    X = i.height,
                    Y = 1,
                    D = new an(0, 0, I, X),
                    j = new an(0, 0, I, X),
                    N = !1,
                    J = new pn,
                    Z = new pi,
                    $ = !1,
                    Q = !1,
                    K = new Nt,
                    ee = new Ut;

                function te() {
                    return null === b ? Y : 1
                }
                try {
                    var ne = {
                        alpha: n,
                        depth: r,
                        stencil: o,
                        antialias: a,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: c,
                        powerPreference: l
                    };
                    if (i.addEventListener("webglcontextlost", ae, !1), i.addEventListener("webglcontextrestored", se, !1), null === (U = t || i.getContext("webgl", ne) || i.getContext("experimental-webgl", ne))) throw null !== i.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === U.getShaderPrecisionFormat && (U.getShaderPrecisionFormat = function () {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (e) {
                    console.error("THREE.WebGLRenderer: " + e.message)
                }

                function re() {
                    (T = new fi(U)).get("WEBGL_depth_texture"), T.get("OES_texture_float"), T.get("OES_texture_float_linear"), T.get("OES_texture_half_float"), T.get("OES_texture_half_float_linear"), T.get("OES_standard_derivatives"), T.get("OES_element_index_uint"), T.get("ANGLE_instanced_arrays"), _ = new ea(U, T), H = new di(U, T, e), (B = new Qo(U, T, _)).scissor(P.copy(j).multiplyScalar(Y)), B.viewport(E.copy(D).multiplyScalar(Y)), u = new vi(U), F = new _o, h = new Ko(U, T, B, F, H, _, u), S = new En(U), M = new mi(U, S, u), f = new xi(M, u), A = new _i(U), g = new yo(z, T, H), d = new Eo, m = new Wo, v = new ui(z, B, M, s), C = new hi(U, T, u), L = new gi(U, T, u), y = new $o(z, U, B, h, H), u.programs = g.programs, z.context = U, z.capabilities = H, z.extensions = T, z.properties = F, z.renderLists = d, z.state = B, z.info = u
                }
                re();
                var ie = new ra(z);
                this.vr = ie;
                var oe = new Jo(z, f, H.maxTextureSize);

                function ae(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
                }

                function se() {
                    console.log("THREE.WebGLRenderer: Context Restored."), x = !1, re()
                }

                function ce(e) {
                    var t, n = e.target;
                    n.removeEventListener("dispose", ce), le(t = n), F.remove(t)
                }

                function le(e) {
                    var t = F.get(e).program;
                    (e.program = void 0) !== t && g.releaseProgram(t)
                }
                this.shadowMap = oe, this.getContext = function () {
                    return U
                }, this.getContextAttributes = function () {
                    return U.getContextAttributes()
                }, this.forceContextLoss = function () {
                    var e = T.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function () {
                    var e = T.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function () {
                    return Y
                }, this.setPixelRatio = function (e) {
                    void 0 !== e && (Y = e, this.setSize(I, X, !1))
                }, this.getSize = function () {
                    return {
                        width: I,
                        height: X
                    }
                }, this.setSize = function (e, t, n) {
                    var r = ie.getDevice();
                    r && r.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = e, X = t, i.width = e * Y, i.height = t * Y, !1 !== n && (i.style.width = e + "px", i.style.height = t + "px"), this.setViewport(0, 0, e, t))
                }, this.getDrawingBufferSize = function () {
                    return {
                        width: I * Y,
                        height: X * Y
                    }
                }, this.setDrawingBufferSize = function (e, t, n) {
                    I = e, X = t, Y = n, i.width = e * n, i.height = t * n, this.setViewport(0, 0, e, t)
                }, this.getCurrentViewport = function () {
                    return E
                }, this.setViewport = function (e, t, n, r) {
                    D.set(e, X - t - r, n, r), B.viewport(E.copy(D).multiplyScalar(Y))
                }, this.setScissor = function (e, t, n, r) {
                    j.set(e, X - t - r, n, r), B.scissor(P.copy(j).multiplyScalar(Y))
                }, this.setScissorTest = function (e) {
                    B.setScissorTest(N = e)
                }, this.getClearColor = function () {
                    return v.getClearColor()
                }, this.setClearColor = function () {
                    v.setClearColor.apply(v, arguments)
                }, this.getClearAlpha = function () {
                    return v.getClearAlpha()
                }, this.setClearAlpha = function () {
                    v.setClearAlpha.apply(v, arguments)
                }, this.clear = function (e, t, n) {
                    var r = 0;
                    (void 0 === e || e) && (r |= U.COLOR_BUFFER_BIT), (void 0 === t || t) && (r |= U.DEPTH_BUFFER_BIT), (void 0 === n || n) && (r |= U.STENCIL_BUFFER_BIT), U.clear(r)
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                }, this.clearTarget = function (e, t, n, r) {
                    this.setRenderTarget(e), this.clear(t, n, r)
                }, this.dispose = function () {
                    i.removeEventListener("webglcontextlost", ae, !1), i.removeEventListener("webglcontextrestored", se, !1), d.dispose(), m.dispose(), F.dispose(), f.dispose(), ie.dispose(), me()
                }, this.renderBufferImmediate = function (e, t, n) {
                    B.initAttributes();
                    var r = F.get(e);
                    e.hasPositions && !r.position && (r.position = U.createBuffer()), e.hasNormals && !r.normal && (r.normal = U.createBuffer()), e.hasUvs && !r.uv && (r.uv = U.createBuffer()), e.hasColors && !r.color && (r.color = U.createBuffer());
                    var i = t.getAttributes();
                    if (e.hasPositions && (U.bindBuffer(U.ARRAY_BUFFER, r.position), U.bufferData(U.ARRAY_BUFFER, e.positionArray, U.DYNAMIC_DRAW), B.enableAttribute(i.position), U.vertexAttribPointer(i.position, 3, U.FLOAT, !1, 0, 0)), e.hasNormals) {
                        if (U.bindBuffer(U.ARRAY_BUFFER, r.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && !0 === n.flatShading)
                            for (var o = 0, a = 3 * e.count; o < a; o += 9) {
                                var s = e.normalArray,
                                    c = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
                                    l = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
                                    u = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                                s[o + 0] = c, s[o + 1] = l, s[o + 2] = u, s[o + 3] = c, s[o + 4] = l, s[o + 5] = u, s[o + 6] = c, s[o + 7] = l, s[o + 8] = u
                            }
                        U.bufferData(U.ARRAY_BUFFER, e.normalArray, U.DYNAMIC_DRAW), B.enableAttribute(i.normal), U.vertexAttribPointer(i.normal, 3, U.FLOAT, !1, 0, 0)
                    }
                    e.hasUvs && n.map && (U.bindBuffer(U.ARRAY_BUFFER, r.uv), U.bufferData(U.ARRAY_BUFFER, e.uvArray, U.DYNAMIC_DRAW), B.enableAttribute(i.uv), U.vertexAttribPointer(i.uv, 2, U.FLOAT, !1, 0, 0)), e.hasColors && n.vertexColors !== Se && (U.bindBuffer(U.ARRAY_BUFFER, r.color), U.bufferData(U.ARRAY_BUFFER, e.colorArray, U.DYNAMIC_DRAW), B.enableAttribute(i.color), U.vertexAttribPointer(i.color, 3, U.FLOAT, !1, 0, 0)), B.disableUnusedAttributes(), U.drawArrays(U.TRIANGLES, 0, e.count), e.count = 0
                }, this.renderBufferDirect = function (e, t, n, r, i, o) {
                    var a = i.isMesh && i.matrixWorld.determinant() < 0;
                    B.setMaterial(r, a);
                    var s = be(e, t, r, i),
                        c = n.id + "_" + s.id + "_" + (!0 === r.wireframe),
                        l = !1;
                    c !== R && (R = c, l = !0), i.morphTargetInfluences && (A.update(i, n, r, s), l = !0);
                    var u, h = n.index,
                        d = n.attributes.position,
                        p = 1;
                    !0 === r.wireframe && (h = M.getWireframeAttribute(n), p = 2);
                    var f = C;
                    null !== h && (u = S.get(h), (f = L).setIndex(u)), l && (! function (e, t, n) {
                        if (n && n.isInstancedBufferGeometry && null === T.get("ANGLE_instanced_arrays")) return console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        B.initAttributes();
                        var r = n.attributes,
                            i = t.getAttributes(),
                            o = e.defaultAttributeValues;
                        for (var a in i) {
                            var s = i[a];
                            if (0 <= s) {
                                var c = r[a];
                                if (void 0 !== c) {
                                    var l = c.normalized,
                                        u = c.itemSize,
                                        h = S.get(c);
                                    if (void 0 === h) continue;
                                    var d = h.buffer,
                                        p = h.type,
                                        f = h.bytesPerElement;
                                    if (c.isInterleavedBufferAttribute) {
                                        var m = c.data,
                                            g = m.stride,
                                            v = c.offset;
                                        m && m.isInstancedInterleavedBuffer ? (B.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : B.enableAttribute(s), U.bindBuffer(U.ARRAY_BUFFER, d), U.vertexAttribPointer(s, u, p, l, g * f, v * f)
                                    } else c.isInstancedBufferAttribute ? (B.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : B.enableAttribute(s), U.bindBuffer(U.ARRAY_BUFFER, d), U.vertexAttribPointer(s, u, p, l, 0, 0)
                                } else if (void 0 !== o) {
                                    var y = o[a];
                                    if (void 0 !== y) switch (y.length) {
                                        case 2:
                                            U.vertexAttrib2fv(s, y);
                                            break;
                                        case 3:
                                            U.vertexAttrib3fv(s, y);
                                            break;
                                        case 4:
                                            U.vertexAttrib4fv(s, y);
                                            break;
                                        default:
                                            U.vertexAttrib1fv(s, y)
                                    }
                                }
                            }
                        }
                        B.disableUnusedAttributes()
                    }(r, s, n), null !== h && U.bindBuffer(U.ELEMENT_ARRAY_BUFFER, u.buffer));
                    var m = 1 / 0;
                    null !== h ? m = h.count : void 0 !== d && (m = d.count);
                    var g = n.drawRange.start * p,
                        v = n.drawRange.count * p,
                        y = null !== o ? o.start * p : 0,
                        _ = null !== o ? o.count * p : 1 / 0,
                        x = Math.max(g, y),
                        b = Math.min(m, g + v, y + _) - 1,
                        w = Math.max(0, b - x + 1);
                    if (0 !== w) {
                        if (i.isMesh)
                            if (!0 === r.wireframe) B.setLineWidth(r.wireframeLinewidth * te()), f.setMode(U.LINES);
                            else switch (i.drawMode) {
                                case Tt:
                                    f.setMode(U.TRIANGLES);
                                    break;
                                case 1:
                                    f.setMode(U.TRIANGLE_STRIP);
                                    break;
                                case 2:
                                    f.setMode(U.TRIANGLE_FAN)
                            } else if (i.isLine) {
                                var E = r.linewidth;
                                void 0 === E && (E = 1), B.setLineWidth(E * te()), i.isLineSegments ? f.setMode(U.LINES) : i.isLineLoop ? f.setMode(U.LINE_LOOP) : f.setMode(U.LINE_STRIP)
                            } else i.isPoints && f.setMode(U.POINTS);
                        n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && f.renderInstances(n, x, w) : f.render(x, w)
                    }
                };
                var ue, he, de, pe = !(this.compile = function (n, e) {
                    (k = m.get(n, e)).init(), n.traverse(function (e) {
                        e.isLight && (k.pushLight(e), e.castShadow && k.pushShadow(e))
                    }), k.setupLights(e), n.traverse(function (e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var t = 0; t < e.material.length; t++) xe(e.material[t], n.fog, e);
                            else xe(e.material, n.fog, e)
                    })
                }),
                    fe = null;

                function me() {
                    pe = !1
                }

                function ge() {
                    var e = ie.getDevice();
                    e && e.isPresenting ? e.requestAnimationFrame(ve) : window.requestAnimationFrame(ve)
                }

                function ve(e) {
                    !1 !== pe && (fe(e), ge())
                }

                function ye(e, t, n, r) {
                    for (var i = 0, o = e.length; i < o; i++) {
                        var a = e[i],
                            s = a.object,
                            c = a.geometry,
                            l = void 0 === r ? a.material : r,
                            u = a.group;
                        if (n.isArrayCamera)
                            for (var h = (q = n).cameras, d = 0, p = h.length; d < p; d++) {
                                var f = h[d];
                                if (s.layers.test(f.layers)) {
                                    var m = f.bounds,
                                        g = m.x * I,
                                        v = m.y * X,
                                        y = m.z * I,
                                        _ = m.w * X;
                                    B.viewport(E.set(g, v, y, _).multiplyScalar(Y)), _e(s, t, f, c, l, u)
                                }
                            } else q = null, _e(s, t, n, c, l, u)
                    }
                }

                function _e(e, t, n, r, i, o) {
                    if (e.onBeforeRender(z, t, n, r, i, o), k = m.get(t, q || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                        var a = e.isMesh && e.matrixWorld.determinant() < 0;
                        B.setMaterial(i, a);
                        var s = be(n, t.fog, i, e);
                        R = "", c = s, l = i, e.render(function (e) {
                            z.renderBufferImmediate(e, c, l)
                        })
                    } else z.renderBufferDirect(n, t.fog, r, i, e, o);
                    var c, l;
                    e.onAfterRender(z, t, n, r, i, o), k = m.get(t, q || n)
                }

                function xe(e, t, n) {
                    var r = F.get(e),
                        i = k.state.lights,
                        o = k.state.shadowsArray,
                        a = g.getParameters(e, i.state, o, t, Z.numPlanes, Z.numIntersection, n),
                        s = g.getProgramCode(e, a),
                        c = r.program,
                        l = !0;
                    if (void 0 === c) e.addEventListener("dispose", ce);
                    else if (c.code !== s) le(e);
                    else if (r.lightsHash !== i.state.hash) F.update(e, "lightsHash", i.state.hash), l = !1;
                    else {
                        if (void 0 !== a.shaderID) return;
                        l = !1
                    }
                    if (l) {
                        if (a.shaderID) {
                            var u = wn[a.shaderID];
                            r.shader = {
                                name: e.type,
                                uniforms: gn.clone(u.uniforms),
                                vertexShader: u.vertexShader,
                                fragmentShader: u.fragmentShader
                            }
                        } else r.shader = {
                            name: e.type,
                            uniforms: e.uniforms,
                            vertexShader: e.vertexShader,
                            fragmentShader: e.fragmentShader
                        };
                        e.onBeforeCompile(r.shader, z), c = g.acquireProgram(e, r.shader, a, s), r.program = c, e.program = c
                    }
                    var h = c.getAttributes();
                    if (e.morphTargets)
                        for (var d = e.numSupportedMorphTargets = 0; d < z.maxMorphTargets; d++) 0 <= h["morphTarget" + d] && e.numSupportedMorphTargets++;
                    if (e.morphNormals)
                        for (d = e.numSupportedMorphNormals = 0; d < z.maxMorphNormals; d++) 0 <= h["morphNormal" + d] && e.numSupportedMorphNormals++;
                    var p = r.shader.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = Z.numPlanes, r.numIntersection = Z.numIntersection, p.clippingPlanes = Z.uniform), r.fog = t, r.lightsHash = i.state.hash, e.lights && (p.ambientLightColor.value = i.state.ambient, p.directionalLights.value = i.state.directional, p.spotLights.value = i.state.spot, p.rectAreaLights.value = i.state.rectArea, p.pointLights.value = i.state.point, p.hemisphereLights.value = i.state.hemi, p.directionalShadowMap.value = i.state.directionalShadowMap, p.directionalShadowMatrix.value = i.state.directionalShadowMatrix, p.spotShadowMap.value = i.state.spotShadowMap, p.spotShadowMatrix.value = i.state.spotShadowMatrix, p.pointShadowMap.value = i.state.pointShadowMap, p.pointShadowMatrix.value = i.state.pointShadowMatrix);
                    var f = r.program.getUniforms(),
                        m = ao.seqWithValue(f.seq, p);
                    r.uniformsList = m
                }

                function be(e, t, n, r) {
                    W = 0;
                    var i = F.get(n),
                        o = k.state.lights;
                    if ($ && (Q || e !== V)) {
                        var a = e === V && n.id === G;
                        Z.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, i, a)
                    } !1 === n.needsUpdate && (void 0 === i.program ? n.needsUpdate = !0 : n.fog && i.fog !== t ? n.needsUpdate = !0 : n.lights && i.lightsHash !== o.state.hash ? n.needsUpdate = !0 : void 0 === i.numClippingPlanes || i.numClippingPlanes === Z.numPlanes && i.numIntersection === Z.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (xe(n, t, r), n.needsUpdate = !1);
                    var s, c, l, u, h, d, p, f, m, g, v, y, _, x, b, w, E, T, S = !1,
                        M = !1,
                        A = !1,
                        C = i.program,
                        L = C.getUniforms(),
                        R = i.shader.uniforms;
                    if (B.useProgram(C.program) && (A = M = S = !0), n.id !== G && (G = n.id, M = !0), S || e !== V) {
                        if (L.setValue(U, "projectionMatrix", e.projectionMatrix), H.logarithmicDepthBuffer && L.setValue(U, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), V !== (q || e) && (V = q || e, A = M = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var P = L.map.cameraPosition;
                            void 0 !== P && P.setValue(U, ee.setFromMatrixPosition(e.matrixWorld))
                        } (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && L.setValue(U, "viewMatrix", e.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        L.setOptional(U, r, "bindMatrix"), L.setOptional(U, r, "bindMatrixInverse");
                        var O = r.skeleton;
                        if (O) {
                            var I = O.bones;
                            if (H.floatVertexTextures) {
                                if (void 0 === O.boneTexture) {
                                    var D = Math.sqrt(4 * I.length);
                                    D = Dt.ceilPowerOfTwo(D), D = Math.max(D, 4);
                                    var j = new Float32Array(D * D * 4);
                                    j.set(O.boneMatrices);
                                    var N = new ln(j, D, D, Je, Fe);
                                    N.needsUpdate = !0, O.boneMatrices = j, O.boneTexture = N, O.boneTextureSize = D
                                }
                                L.setValue(U, "boneTexture", O.boneTexture), L.setValue(U, "boneTextureSize", O.boneTextureSize)
                            } else L.setOptional(U, O, "boneMatrices")
                        }
                    }
                    return M && (L.setValue(U, "toneMappingExposure", z.toneMappingExposure), L.setValue(U, "toneMappingWhitePoint", z.toneMappingWhitePoint), n.lights && (T = A, (E = R).ambientLightColor.needsUpdate = T, E.directionalLights.needsUpdate = T, E.pointLights.needsUpdate = T, E.spotLights.needsUpdate = T, E.rectAreaLights.needsUpdate = T, E.hemisphereLights.needsUpdate = T), t && n.fog && (w = t, (b = R).fogColor.value = w.color, w.isFog ? (b.fogNear.value = w.near, b.fogFar.value = w.far) : w.isFogExp2 && (b.fogDensity.value = w.density)), n.isMeshBasicMaterial ? we(R, n) : n.isMeshLambertMaterial ? (we(R, n), _ = R, (x = n).emissiveMap && (_.emissiveMap.value = x.emissiveMap)) : n.isMeshPhongMaterial ? (we(R, n), n.isMeshToonMaterial ? (Ee(v = R, y = n), y.gradientMap && (v.gradientMap.value = y.gradientMap)) : Ee(R, n)) : n.isMeshStandardMaterial ? (we(R, n), n.isMeshPhysicalMaterial ? (g = n, (m = R).clearCoat.value = g.clearCoat, m.clearCoatRoughness.value = g.clearCoatRoughness, Te(m, g)) : Te(R, n)) : n.isMeshDepthMaterial ? (we(R, n), p = R, (f = n).displacementMap && (p.displacementMap.value = f.displacementMap, p.displacementScale.value = f.displacementScale, p.displacementBias.value = f.displacementBias)) : n.isMeshDistanceMaterial ? (we(R, n), function (e, t) {
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                        e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                    }(R, n)) : n.isMeshNormalMaterial ? (we(R, n), function (e, t) {
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale);
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale));
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(R, n)) : n.isLineBasicMaterial ? (d = n, (h = R).diffuse.value = d.color, h.opacity.value = d.opacity, n.isLineDashedMaterial && (u = n, (l = R).dashSize.value = u.dashSize, l.totalSize.value = u.dashSize + u.gapSize, l.scale.value = u.scale)) : n.isPointsMaterial ? (c = n, (s = R).diffuse.value = c.color, s.opacity.value = c.opacity, s.size.value = c.size * Y, s.scale.value = .5 * X, s.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), s.uvTransform.value.copy(c.map.matrix))) : n.isShadowMaterial && (R.color.value = n.color, R.opacity.value = n.opacity), void 0 !== R.ltc_1 && (R.ltc_1.value = bn.LTC_1), void 0 !== R.ltc_2 && (R.ltc_2.value = bn.LTC_2), ao.upload(U, i.uniformsList, R, z)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ao.upload(U, i.uniformsList, R, z), n.uniformsNeedUpdate = !1), L.setValue(U, "modelViewMatrix", r.modelViewMatrix), L.setValue(U, "normalMatrix", r.normalMatrix), L.setValue(U, "modelMatrix", r.matrixWorld), C
                }

                function we(e, t) {
                    var n;
                    e.opacity.value = t.opacity, t.color && (e.diffuse.value = t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap && t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = F.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap && (n = t.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }

                function Ee(e, t) {
                    e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function Te(e, t) {
                    e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                }
                this.animate = function (e) {
                    null !== (fe = e) ? pe || (ge(), pe = !0) : me()
                }, this.render = function (e, t, n, r) {
                    if (t && t.isCamera) {
                        if (!x) {
                            R = "", G = -1, !(V = null) === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), ie.enabled && (t = ie.getCamera(t)), (k = m.get(e, t)).init(), e.onBeforeRender(z, e, t, n), K.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), J.setFromMatrix(K), Q = this.localClippingEnabled, $ = Z.init(this.clippingPlanes, Q, t), (p = d.get(e, t)).init(),
                                function e(t, n, r) {
                                    if (!1 === t.visible) return;
                                    var i = t.layers.test(n.layers);
                                    if (i)
                                        if (t.isLight) k.pushLight(t), t.castShadow && k.pushShadow(t);
                                        else if (t.isSprite) t.frustumCulled && !J.intersectsSprite(t) || k.pushSprite(t);
                                        else if (t.isImmediateRenderObject) r && ee.setFromMatrixPosition(t.matrixWorld).applyMatrix4(K), p.push(t, null, t.material, ee.z, null);
                                        else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || J.intersectsObject(t))) {
                                            r && ee.setFromMatrixPosition(t.matrixWorld).applyMatrix4(K);
                                            var o = f.update(t),
                                                a = t.material;
                                            if (Array.isArray(a))
                                                for (var s = o.groups, c = 0, l = s.length; c < l; c++) {
                                                    var u = s[c],
                                                        h = a[u.materialIndex];
                                                    h && h.visible && p.push(t, o, h, ee.z, u)
                                                } else a.visible && p.push(t, o, a, ee.z, null)
                                        }
                                    var d = t.children;
                                    for (var c = 0, l = d.length; c < l; c++) e(d[c], n, r)
                                }(e, t, z.sortObjects), !0 === z.sortObjects && p.sort(), $ && Z.beginShadows();
                            var i = k.state.shadowsArray;
                            oe.render(i, e, t), k.setupLights(t), $ && Z.endShadows(), this.info.autoReset && this.info.reset(), void 0 === n && (n = null), this.setRenderTarget(n), v.render(p, e, t, r);
                            var o = p.opaque,
                                a = p.transparent;
                            if (e.overrideMaterial) {
                                var s = e.overrideMaterial;
                                o.length && ye(o, e, t, s), a.length && ye(a, e, t, s)
                            } else o.length && ye(o, e, t), a.length && ye(a, e, t);
                            var c = k.state.spritesArray;
                            y.render(c, e, t), n && h.updateRenderTargetMipmap(n), B.buffers.depth.setTest(!0), B.buffers.depth.setMask(!0), B.buffers.color.setMask(!0), B.setPolygonOffset(!1), e.onAfterRender(z, e, t), ie.enabled && ie.submitFrame(), k = p = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.allocTextureUnit = function () {
                    var e = W;
                    return e >= H.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + H.maxTextures), W += 1, e
                }, this.setTexture2D = (ue = !1, function (e, t) {
                    e && e.isWebGLRenderTarget && (ue || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), ue = !0), e = e.texture), h.setTexture2D(e, t)
                }), this.setTexture = (he = !1, function (e, t) {
                    he || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), he = !0), h.setTexture2D(e, t)
                }), this.setTextureCube = (de = !1, function (e, t) {
                    e && e.isWebGLRenderTargetCube && (de || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), de = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? h.setTextureCube(e, t) : h.setTextureCubeDynamic(e, t)
                }), this.getRenderTarget = function () {
                    return b
                }, this.setRenderTarget = function (e) {
                    (b = e) && void 0 === F.get(e).__webglFramebuffer && h.setupRenderTarget(e);
                    var t = null,
                        n = !1;
                    if (e) {
                        var r = F.get(e).__webglFramebuffer;
                        e.isWebGLRenderTargetCube ? (t = r[e.activeCubeFace], n = !0) : t = r, E.copy(e.viewport), P.copy(e.scissor), O = e.scissorTest
                    } else E.copy(D).multiplyScalar(Y), P.copy(j).multiplyScalar(Y), O = N;
                    if (w !== t && (U.bindFramebuffer(U.FRAMEBUFFER, t), w = t), B.viewport(E), B.scissor(P), B.setScissorTest(O), n) {
                        var i = F.get(e.texture);
                        U.framebufferTexture2D(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, i.__webglTexture, e.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function (e, t, n, r, i, o) {
                    if (e && e.isWebGLRenderTarget) {
                        var a = F.get(e).__webglFramebuffer;
                        if (a) {
                            var s = !1;
                            a !== w && (U.bindFramebuffer(U.FRAMEBUFFER, a), s = !0);
                            try {
                                var c = e.texture,
                                    l = c.format,
                                    u = c.type;
                                if (l !== Je && _.convert(l) !== U.getParameter(U.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(u === je || _.convert(u) === U.getParameter(U.IMPLEMENTATION_COLOR_READ_TYPE) || u === Fe && (T.get("OES_texture_float") || T.get("WEBGL_color_buffer_float")) || u === ze && T.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                U.checkFramebufferStatus(U.FRAMEBUFFER) === U.FRAMEBUFFER_COMPLETE ? 0 <= t && t <= e.width - r && 0 <= n && n <= e.height - i && U.readPixels(t, n, r, i, _.convert(l), _.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                s && U.bindFramebuffer(U.FRAMEBUFFER, w)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function (e, t, n) {
                    var r = t.image.width,
                        i = t.image.height,
                        o = _.convert(t.format);
                    this.setTexture2D(t, 0), U.copyTexImage2D(U.TEXTURE_2D, n || 0, o, e.x, e.y, r, i, 0)
                }, this.copyTextureToTexture = function (e, t, n, r) {
                    var i = t.image.width,
                        o = t.image.height,
                        a = _.convert(n.format),
                        s = _.convert(n.type),
                        c = t.isDataTexture ? t.image.data : t.image;
                    this.setTexture2D(n, 0), U.texSubImage2D(U.TEXTURE_2D, r || 0, e.x, e.y, i, o, a, s, c)
                }
            }

            function oa(e, t) {
                this.name = "", this.color = new yn(e), this.density = void 0 !== t ? t : 25e-5
            }

            function aa(e, t, n) {
                this.name = "", this.color = new yn(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
            }

            function sa() {
                qn.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }

            function ca(e) {
                ri.call(this), this.type = "SpriteMaterial", this.color = new yn(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(e)
            }

            function la(e) {
                qn.call(this), this.type = "Sprite", this.material = void 0 !== e ? e : new ca, this.center = new jt(.5, .5)
            }

            function ua() {
                qn.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function ha(e, t) {
                if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.rootMotionBone = null, void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new Nt)
                }
            }

            function da() {
                qn.call(this), this.type = "Bone"
            }

            function pa(e, t) {
                li.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Nt, this.bindMatrixInverse = new Nt;
                var n = new ha(this.initBones());
                this.bind(n, this.matrixWorld), this.normalizeSkinWeights()
            }

            function fa(e) {
                ri.call(this), this.type = "LineBasicMaterial", this.color = new yn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e)
            }

            function ma(e, t, n) {
                if (1 === n) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new ga(e, t);
                qn.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Ar, this.material = void 0 !== t ? t : new fa({
                    color: 16777215 * Math.random()
                })
            }

            function ga(e, t) {
                ma.call(this, e, t), this.type = "LineSegments"
            }

            function va(e, t) {
                ma.call(this, e, t), this.type = "LineLoop"
            }

            function ya(e) {
                ri.call(this), this.type = "PointsMaterial", this.color = new yn(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(e)
            }

            function _a(e, t) {
                qn.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Ar, this.material = void 0 !== t ? t : new ya({
                    color: 16777215 * Math.random()
                })
            }

            function xa() {
                qn.call(this), this.type = "Group"
            }

            function ba(e, t, n, r, i, o, a, s, c) {
                on.call(this, e, t, n, r, i, o, a, s, c), this.generateMipmaps = !1
            }

            function wa(e, t, n, r, i, o, a, s, c, l, u, h) {
                on.call(this, null, o, a, s, c, l, r, i, u, h), this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }

            function Ea(e, t, n, r, i, o, a, s, c, l) {
                if ((l = void 0 !== l ? l : Ke) !== Ke && l !== et) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && l === Ke && (n = Ue), void 0 === n && l === et && (n = We), on.call(this, null, r, i, o, a, s, l, n, c), this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== a ? a : Le, this.minFilter = void 0 !== s ? s : Le, this.flipY = !1, this.generateMipmaps = !1
            }

            function Ta(e) {
                Ar.call(this), this.type = "WireframeGeometry";
                var t, n, r, i, o, a, s, c, l, u, h = [],
                    d = [0, 0],
                    p = {},
                    f = ["a", "b", "c"];
                if (e && e.isGeometry) {
                    var m = e.faces;
                    for (t = 0, r = m.length; t < r; t++) {
                        var g = m[t];
                        for (n = 0; n < 3; n++) s = g[f[n]], c = g[f[(n + 1) % 3]], d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                            index1: d[0],
                            index2: d[1]
                        })
                    }
                    for (l in p) a = p[l], u = e.vertices[a.index1], h.push(u.x, u.y, u.z), u = e.vertices[a.index2], h.push(u.x, u.y, u.z)
                } else if (e && e.isBufferGeometry) {
                    var v, y, _, x, b, w;
                    if (u = new Ut, null !== e.index) {
                        for (v = e.attributes.position, y = e.index, 0 === (_ = e.groups).length && (_ = [{
                            start: 0,
                            count: y.count,
                            materialIndex: 0
                        }]), i = 0, o = _.length; i < o; ++i)
                            for (r = (t = (x = _[i]).start) + x.count; t < r; t += 3)
                                for (n = 0; n < 3; n++) s = y.getX(t + n), c = y.getX(t + (n + 1) % 3), d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                                    index1: d[0],
                                    index2: d[1]
                                });
                        for (l in p) a = p[l], u.fromBufferAttribute(v, a.index1), h.push(u.x, u.y, u.z), u.fromBufferAttribute(v, a.index2), h.push(u.x, u.y, u.z)
                    } else
                        for (t = 0, r = (v = e.attributes.position).count / 3; t < r; t++)
                            for (n = 0; n < 3; n++) b = 3 * t + n, u.fromBufferAttribute(v, b), h.push(u.x, u.y, u.z), w = 3 * t + (n + 1) % 3, u.fromBufferAttribute(v, w), h.push(u.x, u.y, u.z)
                }
                this.addAttribute("position", new dr(h, 3))
            }

            function Sa(e, t, n) {
                rr.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                }, this.fromBufferGeometry(new Ma(e, t, n)), this.mergeVertices()
            }

            function Ma(e, t, n) {
                Ar.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                };
                var r, i, o = [],
                    a = [],
                    s = [],
                    c = [],
                    l = new Ut,
                    u = new Ut,
                    h = new Ut,
                    d = new Ut,
                    p = new Ut,
                    f = t + 1;
                for (r = 0; r <= n; r++) {
                    var m = r / n;
                    for (i = 0; i <= t; i++) {
                        var g = i / t;
                        e(g, m, u), a.push(u.x, u.y, u.z), 0 <= g - 1e-5 ? (e(g - 1e-5, m, h), d.subVectors(u, h)) : (e(g + 1e-5, m, h), d.subVectors(h, u)), 0 <= m - 1e-5 ? (e(g, m - 1e-5, h), p.subVectors(u, h)) : (e(g, m + 1e-5, h), p.subVectors(h, u)), l.crossVectors(d, p).normalize(), s.push(l.x, l.y, l.z), c.push(g, m)
                    }
                }
                for (r = 0; r < n; r++)
                    for (i = 0; i < t; i++) {
                        var v = r * f + i,
                            y = r * f + i + 1,
                            _ = (r + 1) * f + i + 1,
                            x = (r + 1) * f + i;
                        o.push(v, y, x), o.push(y, _, x)
                    }
                this.setIndex(o), this.addAttribute("position", new dr(a, 3)), this.addAttribute("normal", new dr(s, 3)), this.addAttribute("uv", new dr(c, 2))
            }

            function Aa(e, t, n, r) {
                rr.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: r
                }, this.fromBufferGeometry(new Ca(e, t, n, r)), this.mergeVertices()
            }

            function Ca(r, o, e, t) {
                Ar.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: r,
                    indices: o,
                    radius: e,
                    detail: t
                }, e = e || 1;
                var u = [],
                    h = [];

                function a(e, t, n, r) {
                    var i, o, a = Math.pow(2, r),
                        s = [];
                    for (i = 0; i <= a; i++) {
                        s[i] = [];
                        var c = e.clone().lerp(n, i / a),
                            l = t.clone().lerp(n, i / a),
                            u = a - i;
                        for (o = 0; o <= u; o++) s[i][o] = 0 === o && i === a ? c : c.clone().lerp(l, o / u)
                    }
                    for (i = 0; i < a; i++)
                        for (o = 0; o < 2 * (a - i) - 1; o++) {
                            var h = Math.floor(o / 2);
                            o % 2 == 0 ? (d(s[i][h + 1]), d(s[i + 1][h]), d(s[i][h])) : (d(s[i][h + 1]), d(s[i + 1][h + 1]), d(s[i + 1][h]))
                        }
                }

                function d(e) {
                    u.push(e.x, e.y, e.z)
                }

                function s(e, t) {
                    var n = 3 * e;
                    t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2]
                }

                function p(e, t, n, r) {
                    r < 0 && 1 === e.x && (h[t] = e.x - 1), 0 === n.x && 0 === n.z && (h[t] = r / 2 / Math.PI + .5)
                }

                function f(e) {
                    return Math.atan2(e.z, -e.x)
                } ! function (e) {
                    for (var t = new Ut, n = new Ut, r = new Ut, i = 0; i < o.length; i += 3) s(o[i + 0], t), s(o[i + 1], n), s(o[i + 2], r), a(t, n, r, e)
                }(t = t || 0),
                    function (e) {
                        for (var t = new Ut, n = 0; n < u.length; n += 3) t.x = u[n + 0], t.y = u[n + 1], t.z = u[n + 2], t.normalize().multiplyScalar(e), u[n + 0] = t.x, u[n + 1] = t.y, u[n + 2] = t.z
                    }(e),
                    function () {
                        for (var e = new Ut, t = 0; t < u.length; t += 3) {
                            e.x = u[t + 0], e.y = u[t + 1], e.z = u[t + 2];
                            var n = f(e) / 2 / Math.PI + .5,
                                r = (i = e, Math.atan2(-i.y, Math.sqrt(i.x * i.x + i.z * i.z)) / Math.PI + .5);
                            h.push(n, 1 - r)
                        }
                        var i;
                        (function () {
                            for (var e = new Ut, t = new Ut, n = new Ut, r = new Ut, i = new jt, o = new jt, a = new jt, s = 0, c = 0; s < u.length; s += 9, c += 6) {
                                e.set(u[s + 0], u[s + 1], u[s + 2]), t.set(u[s + 3], u[s + 4], u[s + 5]), n.set(u[s + 6], u[s + 7], u[s + 8]), i.set(h[c + 0], h[c + 1]), o.set(h[c + 2], h[c + 3]), a.set(h[c + 4], h[c + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                                var l = f(r);
                                p(i, c + 0, e, l), p(o, c + 2, t, l), p(a, c + 4, n, l)
                            }
                        })(),
                            function () {
                                for (var e = 0; e < h.length; e += 6) {
                                    var t = h[e + 0],
                                        n = h[e + 2],
                                        r = h[e + 4],
                                        i = Math.max(t, n, r),
                                        o = Math.min(t, n, r);
                                    .9 < i && o < .1 && (t < .2 && (h[e + 0] += 1), n < .2 && (h[e + 2] += 1), r < .2 && (h[e + 4] += 1))
                                }
                            }()
                    }(), this.addAttribute("position", new dr(u, 3)), this.addAttribute("normal", new dr(u.slice(), 3)), this.addAttribute("uv", new dr(h, 2)), 0 === t ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function La(e, t) {
                rr.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new Ra(e, t)), this.mergeVertices()
            }

            function Ra(e, t) {
                Ca.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function Pa(e, t) {
                rr.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new Oa(e, t)), this.mergeVertices()
            }

            function Oa(e, t) {
                Ca.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function Ia(e, t) {
                rr.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new Da(e, t)), this.mergeVertices()
            }

            function Da(e, t) {
                var n = (1 + Math.sqrt(5)) / 2;
                Ca.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function ja(e, t) {
                rr.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new Na(e, t)), this.mergeVertices()
            }

            function Na(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n;
                Ca.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function ka(e, t, n, r, i, o) {
                rr.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: r,
                    closed: i
                }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Ua(e, t, n, r, i);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Ua(a, s, c, l, e) {
                Ar.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: a,
                    tubularSegments: s,
                    radius: c,
                    radialSegments: l,
                    closed: e
                }, s = s || 64, c = c || 1, l = l || 8, e = e || !1;
                var u = a.computeFrenetFrames(s, e);
                this.tangents = u.tangents, this.normals = u.normals, this.binormals = u.binormals;
                var i, h, d = new Ut,
                    p = new Ut,
                    t = new jt,
                    f = new Ut,
                    m = [],
                    g = [],
                    n = [],
                    o = [];

                function r(e) {
                    f = a.getPointAt(e / s, f);
                    var t = u.normals[e],
                        n = u.binormals[e];
                    for (h = 0; h <= l; h++) {
                        var r = h / l * Math.PI * 2,
                            i = Math.sin(r),
                            o = -Math.cos(r);
                        p.x = o * t.x + i * n.x, p.y = o * t.y + i * n.y, p.z = o * t.z + i * n.z, p.normalize(), g.push(p.x, p.y, p.z), d.x = f.x + c * p.x, d.y = f.y + c * p.y, d.z = f.z + c * p.z, m.push(d.x, d.y, d.z)
                    }
                } ! function () {
                    for (i = 0; i < s; i++) r(i);
                    r(!1 === e ? s : 0),
                        function () {
                            for (i = 0; i <= s; i++)
                                for (h = 0; h <= l; h++) t.x = i / s, t.y = h / l, n.push(t.x, t.y)
                        }(),
                        function () {
                            for (h = 1; h <= s; h++)
                                for (i = 1; i <= l; i++) {
                                    var e = (l + 1) * (h - 1) + (i - 1),
                                        t = (l + 1) * h + (i - 1),
                                        n = (l + 1) * h + i,
                                        r = (l + 1) * (h - 1) + i;
                                    o.push(e, t, r), o.push(t, n, r)
                                }
                        }()
                }(), this.setIndex(o), this.addAttribute("position", new dr(m, 3)), this.addAttribute("normal", new dr(g, 3)), this.addAttribute("uv", new dr(n, 2))
            }

            function Ha(e, t, n, r, i, o, a) {
                rr.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Ba(e, t, n, r, i, o)), this.mergeVertices()
            }

            function Ba(e, t, n, r, i, o) {
                Ar.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
                var a, s, c = [],
                    l = [],
                    u = [],
                    h = [],
                    d = new Ut,
                    p = new Ut,
                    f = new Ut,
                    m = new Ut,
                    g = new Ut,
                    v = new Ut,
                    y = new Ut;
                for (a = 0; a <= n; ++a) {
                    var _ = a / n * i * Math.PI * 2;
                    for (A(_, i, o, e, f), A(_ + .01, i, o, e, m), v.subVectors(m, f), y.addVectors(m, f), g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <= r; ++s) {
                        var x = s / r * Math.PI * 2,
                            b = -t * Math.cos(x),
                            w = t * Math.sin(x);
                        d.x = f.x + (b * y.x + w * g.x), d.y = f.y + (b * y.y + w * g.y), d.z = f.z + (b * y.z + w * g.z), l.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), u.push(p.x, p.y, p.z), h.push(a / n), h.push(s / r)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (a = 1; a <= r; a++) {
                        var E = (r + 1) * (s - 1) + (a - 1),
                            T = (r + 1) * s + (a - 1),
                            S = (r + 1) * s + a,
                            M = (r + 1) * (s - 1) + a;
                        c.push(E, T, M), c.push(T, S, M)
                    }

                function A(e, t, n, r, i) {
                    var o = Math.cos(e),
                        a = Math.sin(e),
                        s = n / t * e,
                        c = Math.cos(s);
                    i.x = r * (2 + c) * .5 * o, i.y = r * (2 + c) * a * .5, i.z = r * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new dr(l, 3)), this.addAttribute("normal", new dr(u, 3)), this.addAttribute("uv", new dr(h, 2))
            }

            function Fa(e, t, n, r, i) {
                rr.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, this.fromBufferGeometry(new za(e, t, n, r, i)), this.mergeVertices()
            }

            function za(e, t, n, r, i) {
                Ar.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
                var o, a, s = [],
                    c = [],
                    l = [],
                    u = [],
                    h = new Ut,
                    d = new Ut,
                    p = new Ut;
                for (o = 0; o <= n; o++)
                    for (a = 0; a <= r; a++) {
                        var f = a / r * i,
                            m = o / n * Math.PI * 2;
                        d.x = (e + t * Math.cos(m)) * Math.cos(f), d.y = (e + t * Math.cos(m)) * Math.sin(f), d.z = t * Math.sin(m), c.push(d.x, d.y, d.z), h.x = e * Math.cos(f), h.y = e * Math.sin(f), p.subVectors(d, h).normalize(), l.push(p.x, p.y, p.z), u.push(a / r), u.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (a = 1; a <= r; a++) {
                        var g = (r + 1) * o + a - 1,
                            v = (r + 1) * (o - 1) + a - 1,
                            y = (r + 1) * (o - 1) + a,
                            _ = (r + 1) * o + a;
                        s.push(g, v, _), s.push(v, y, _)
                    }
                this.setIndex(s), this.addAttribute("position", new dr(c, 3)), this.addAttribute("normal", new dr(l, 3)), this.addAttribute("uv", new dr(u, 2))
            } ((Xo.prototype = Object.create(ri.prototype)).constructor = Xo).prototype.isMeshDepthMaterial = !0, Xo.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }, ((Yo.prototype = Object.create(ri.prototype)).constructor = Yo).prototype.isMeshDistanceMaterial = !0, Yo.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }, (Zo.prototype = Object.create(on.prototype)).constructor = Zo, ta.prototype = Object.assign(Object.create(Wn.prototype), {
                constructor: ta,
                isPerspectiveCamera: !0,
                copy: function (e, t) {
                    return Wn.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                },
                setFocalLength: function (e) {
                    var t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Dt.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
                },
                getFocalLength: function () {
                    var e = Math.tan(.5 * Dt.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / e
                },
                getEffectiveFOV: function () {
                    return 2 * Dt.RAD2DEG * Math.atan(Math.tan(.5 * Dt.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function () {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function () {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function (e, t, n, r, i, o) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function () {
                    var e = this.near,
                        t = e * Math.tan(.5 * Dt.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * t,
                        r = this.aspect * n,
                        i = -.5 * r,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        i += o.offsetX * r / a, t -= o.offsetY * n / s, r *= o.width / a, n *= o.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (i += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far)
                },
                toJSON: function (e) {
                    var t = qn.prototype.toJSON.call(this, e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }), na.prototype = Object.assign(Object.create(ta.prototype), {
                constructor: na,
                isArrayCamera: !0
            }), oa.prototype.isFogExp2 = !0, oa.prototype.clone = function () {
                return new oa(this.color.getHex(), this.density)
            }, oa.prototype.toJSON = function () {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }, aa.prototype.isFog = !0, aa.prototype.clone = function () {
                return new aa(this.color.getHex(), this.near, this.far)
            }, aa.prototype.toJSON = function () {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, sa.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: sa,
                copy: function (e, t) {
                    return qn.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                },
                toJSON: function (e) {
                    var t = qn.prototype.toJSON.call(this, e);
                    return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                }
            }), ((ca.prototype = Object.create(ri.prototype)).constructor = ca).prototype.isSpriteMaterial = !0, ca.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this
            }, la.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: la,
                isSprite: !0,
                raycast: (So = new Ut, Mo = new Ut, Ao = new Ut, function (e, t) {
                    Mo.setFromMatrixPosition(this.matrixWorld), e.ray.closestPointToPoint(Mo, So), Ao.setFromMatrixScale(this.matrixWorld);
                    var n = Ao.x * Ao.y / 4;
                    if (!(Mo.distanceToSquared(So) > n)) {
                        var r = e.ray.origin.distanceTo(So);
                        r < e.near || r > e.far || t.push({
                            distance: r,
                            point: So.clone(),
                            face: null,
                            object: this
                        })
                    }
                }),
                clone: function () {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function (e) {
                    return qn.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
                }
            }), ua.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: ua,
                copy: function (e) {
                    qn.prototype.copy.call(this, e, !1);
                    for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        this.addLevel(i.object.clone(), i.distance)
                    }
                    return this
                },
                addLevel: function (e, t) {
                    void 0 === t && (t = 0), t = Math.abs(t);
                    for (var n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
                    n.splice(r, 0, {
                        distance: t,
                        object: e
                    }), this.add(e)
                },
                getObjectForDistance: function (e) {
                    for (var t = this.levels, n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
                    return t[n - 1].object
                },
                raycast: (Ro = new Ut, function (e, t) {
                    Ro.setFromMatrixPosition(this.matrixWorld);
                    var n = e.ray.origin.distanceTo(Ro);
                    this.getObjectForDistance(n).raycast(e, t)
                }),
                update: (Co = new Ut, Lo = new Ut, function (e) {
                    var t = this.levels;
                    if (1 < t.length) {
                        Co.setFromMatrixPosition(e.matrixWorld), Lo.setFromMatrixPosition(this.matrixWorld);
                        var n = Co.distanceTo(Lo);
                        t[0].object.visible = !0;
                        for (var r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                        for (; r < i; r++) t[r].object.visible = !1
                    }
                }),
                toJSON: function (e) {
                    var t = qn.prototype.toJSON.call(this, e);
                    t.object.levels = [];
                    for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                        var o = n[r];
                        t.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return t
                }
            }), Object.assign(ha.prototype, {
                calculateInverses: function () {
                    this.boneInverses = [];
                    for (var e = 0, t = this.bones.length; e < t; e++) {
                        var n = new Nt;
                        this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function () {
                    var e, t, n;
                    for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
                    for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                },
                update: (Po = new Nt, Oo = new Nt, function () {
                    for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, o = e.length; i < o; i++) {
                        var a = e[i] ? e[i].matrixWorld : Oo;
                        Po.multiplyMatrices(a, t[i]), Po.toArray(n, 16 * i)
                    }
                    void 0 !== r && (r.needsUpdate = !0)
                }),
                clone: function () {
                    return new ha(this.bones, this.boneInverses)
                },
                setRootMotionBone: function (e) {
                    if ("object" == (void 0 === e ? "undefined" : r(e))) "Bone" == e.type && (this.rootMotionBone = e);
                    else if ("string" == typeof e)
                        for (var t = 0; t < this.bones.length; ++t)
                            if (0 <= this.bones[t].name.indexOf(e)) {
                                this.rootMotionBone = this.bones[t];
                                break
                            }
                    this.rootMotionBone && (this.rootMotionBoneInitialMatrixInverse = this.rootMotionBone.matrixWorld.clone(), this.rootMotionBoneInitialMatrixInverse.getInverse(this.rootMotionBoneInitialMatrixInverse))
                },
                getBoneByName: function (e) {
                    for (var t = 0, n = this.bones.length; t < n; t++) {
                        var r = this.bones[t];
                        if (r.name === e) return r
                    }
                }
            }), da.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: da,
                isBone: !0
            }), pa.prototype = Object.assign(Object.create(li.prototype), {
                constructor: pa,
                isSkinnedMesh: !0,
                initBones: function () {
                    var e, t, n, r, i = [];
                    if (this.geometry && void 0 !== this.geometry.bones) {
                        for (n = 0, r = this.geometry.bones.length; n < r; n++) t = this.geometry.bones[n], e = new da, i.push(e), e.name = t.name, e.position.fromArray(t.pos), e.quaternion.fromArray(t.rotq), void 0 !== t.scl && e.scale.fromArray(t.scl);
                        for (n = 0, r = this.geometry.bones.length; n < r; n++) - 1 !== (t = this.geometry.bones[n]).parent && null !== t.parent && void 0 !== i[t.parent] ? i[t.parent].add(i[n]) : this.add(i[n])
                    }
                    return this.updateMatrixWorld(!0), i
                },
                bind: function (e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
                },
                pose: function () {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function () {
                    var e, t;
                    if (this.geometry && this.geometry.isGeometry)
                        for (t = 0; t < this.geometry.skinWeights.length; t++) {
                            var n = this.geometry.skinWeights[t];
                            (e = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0)
                        } else if (this.geometry && this.geometry.isBufferGeometry) {
                            var r = new an,
                                i = this.geometry.attributes.skinWeight;
                            for (t = 0; t < i.count; t++) r.x = i.getX(t), r.y = i.getY(t), r.z = i.getZ(t), r.w = i.getW(t), (e = 1 / r.manhattanLength()) !== 1 / 0 ? r.multiplyScalar(e) : r.set(1, 0, 0, 0), i.setXYZW(t, r.x, r.y, r.z, r.w)
                        }
                },
                updateMatrixWorld: function (e) {
                    li.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), ((fa.prototype = Object.create(ri.prototype)).constructor = fa).prototype.isLineBasicMaterial = !0, fa.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
            }, ma.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: ma,
                isLine: !0,
                computeLineDistances: (No = new Ut, ko = new Ut, function () {
                    var e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) No.fromBufferAttribute(t, r - 1), ko.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += No.distanceTo(ko);
                            e.addAttribute("lineDistance", new dr(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry) {
                        var o = e.vertices;
                        for ((n = e.lineDistances)[0] = 0, r = 1, i = o.length; r < i; r++) n[r] = n[r - 1], n[r] += o[r - 1].distanceTo(o[r])
                    }
                    return this
                }),
                raycast: (Io = new Nt, Do = new ai, jo = new hn, function (e, t) {
                    var n = e.linePrecision,
                        r = n * n,
                        i = this.geometry,
                        o = this.matrixWorld;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), jo.copy(i.boundingSphere), jo.applyMatrix4(o), !1 !== e.ray.intersectsSphere(jo)) {
                        Io.getInverse(o), Do.copy(e.ray).applyMatrix4(Io);
                        var a = new Ut,
                            s = new Ut,
                            c = new Ut,
                            l = new Ut,
                            u = this && this.isLineSegments ? 2 : 1;
                        if (i.isBufferGeometry) {
                            var h = i.index,
                                d = i.attributes.position.array;
                            if (null !== h)
                                for (var p = h.array, f = 0, m = p.length - 1; f < m; f += u) {
                                    var g = p[f],
                                        v = p[f + 1];
                                    a.fromArray(d, 3 * g), s.fromArray(d, 3 * v), r < Do.distanceSqToSegment(a, s, l, c) || (l.applyMatrix4(this.matrixWorld), (x = e.ray.origin.distanceTo(l)) < e.near || x > e.far || t.push({
                                        distance: x,
                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                        index: f,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                                } else
                                for (f = 0, m = d.length / 3 - 1; f < m; f += u) a.fromArray(d, 3 * f), s.fromArray(d, 3 * f + 3), r < Do.distanceSqToSegment(a, s, l, c) || (l.applyMatrix4(this.matrixWorld), (x = e.ray.origin.distanceTo(l)) < e.near || x > e.far || t.push({
                                    distance: x,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: f,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                        } else if (i.isGeometry) {
                            var y = i.vertices,
                                _ = y.length;
                            for (f = 0; f < _ - 1; f += u) {
                                var x;
                                r < Do.distanceSqToSegment(y[f], y[f + 1], l, c) || (l.applyMatrix4(this.matrixWorld), (x = e.ray.origin.distanceTo(l)) < e.near || x > e.far || t.push({
                                    distance: x,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: f,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        }
                    }
                }),
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), ga.prototype = Object.assign(Object.create(ma.prototype), {
                constructor: ga,
                isLineSegments: !0,
                computeLineDistances: (Uo = new Ut, Ho = new Ut, function () {
                    var e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) Uo.fromBufferAttribute(t, r), Ho.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Uo.distanceTo(Ho);
                            e.addAttribute("lineDistance", new dr(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry) {
                        var o = e.vertices;
                        for (n = e.lineDistances, r = 0, i = o.length; r < i; r += 2) Uo.copy(o[r]), Ho.copy(o[r + 1]), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Uo.distanceTo(Ho)
                    }
                    return this
                })
            }), va.prototype = Object.assign(Object.create(ma.prototype), {
                constructor: va,
                isLineLoop: !0
            }), ((ya.prototype = Object.create(ri.prototype)).constructor = ya).prototype.isPointsMaterial = !0, ya.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
            }, _a.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: _a,
                isPoints: !0,
                raycast: (Bo = new Nt, Fo = new ai, zo = new hn, function (i, o) {
                    var a = this,
                        e = this.geometry,
                        s = this.matrixWorld,
                        t = i.params.Points.threshold;
                    if (null === e.boundingSphere && e.computeBoundingSphere(), zo.copy(e.boundingSphere), zo.applyMatrix4(s), zo.radius += t, !1 !== i.ray.intersectsSphere(zo)) {
                        Bo.getInverse(s), Fo.copy(i.ray).applyMatrix4(Bo);
                        var n = t / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            c = n * n,
                            r = new Ut,
                            l = new Ut;
                        if (e.isBufferGeometry) {
                            var u = e.index,
                                h = e.attributes.position.array;
                            if (null !== u)
                                for (var d = u.array, p = 0, f = d.length; p < f; p++) {
                                    var m = d[p];
                                    r.fromArray(h, 3 * m), y(r, m)
                                } else {
                                p = 0;
                                for (var g = h.length / 3; p < g; p++) r.fromArray(h, 3 * p), y(r, p)
                            }
                        } else {
                            var v = e.vertices;
                            for (p = 0, g = v.length; p < g; p++) y(v[p], p)
                        }
                    }

                    function y(e, t) {
                        var n = Fo.distanceSqToPoint(e);
                        if (n < c) {
                            Fo.closestPointToPoint(e, l), l.applyMatrix4(s);
                            var r = i.ray.origin.distanceTo(l);
                            if (r < i.near || r > i.far) return;
                            o.push({
                                distance: r,
                                distanceToRay: Math.sqrt(n),
                                point: l.clone(),
                                index: t,
                                face: null,
                                object: a
                            })
                        }
                    }
                }),
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), xa.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: xa,
                isGroup: !0
            }), ba.prototype = Object.assign(Object.create(on.prototype), {
                constructor: ba,
                isVideoTexture: !0,
                update: function () {
                    var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), ((wa.prototype = Object.create(on.prototype)).constructor = wa).prototype.isCompressedTexture = !0, ((Ea.prototype = Object.create(on.prototype)).constructor = Ea).prototype.isDepthTexture = !0, (Ta.prototype = Object.create(Ar.prototype)).constructor = Ta, (Sa.prototype = Object.create(rr.prototype)).constructor = Sa, (Ma.prototype = Object.create(Ar.prototype)).constructor = Ma, (Aa.prototype = Object.create(rr.prototype)).constructor = Aa, (Ca.prototype = Object.create(Ar.prototype)).constructor = Ca, (La.prototype = Object.create(rr.prototype)).constructor = La, (Ra.prototype = Object.create(Ca.prototype)).constructor = Ra, (Pa.prototype = Object.create(rr.prototype)).constructor = Pa, (Oa.prototype = Object.create(Ca.prototype)).constructor = Oa, (Ia.prototype = Object.create(rr.prototype)).constructor = Ia, (Da.prototype = Object.create(Ca.prototype)).constructor = Da, (ja.prototype = Object.create(rr.prototype)).constructor = ja, (Na.prototype = Object.create(Ca.prototype)).constructor = Na, (ka.prototype = Object.create(rr.prototype)).constructor = ka, (Ua.prototype = Object.create(Ar.prototype)).constructor = Ua, (Ha.prototype = Object.create(rr.prototype)).constructor = Ha, (Ba.prototype = Object.create(Ar.prototype)).constructor = Ba, (Fa.prototype = Object.create(rr.prototype)).constructor = Fa, (za.prototype = Object.create(Ar.prototype)).constructor = za;
            var Ga = function (e, t, n) {
                n = n || 2;
                var r, i, o, a, s, c, l, u = t && t.length,
                    h = u ? t[0] * n : e.length,
                    d = Va(e, 0, h, n, !0),
                    p = [];
                if (!d) return p;
                if (u && (d = function (e, t, n, r) {
                    var i, o, a, s, c, l = [];
                    for (i = 0, o = t.length; i < o; i++) a = t[i] * r, s = i < o - 1 ? t[i + 1] * r : e.length, (c = Va(e, a, s, r, !1)) === c.next && (c.steiner = !0), l.push(es(c));
                    for (l.sort($a), i = 0; i < l.length; i++) Qa(l[i], n), n = qa(n, n.next);
                    return n
                }(e, t, d, n)), e.length > 80 * n) {
                    r = o = e[0], i = a = e[1];
                    for (var f = n; f < h; f += n)(s = e[f]) < r && (r = s), (c = e[f + 1]) < i && (i = c), o < s && (o = s), a < c && (a = c);
                    l = 0 !== (l = Math.max(o - r, a - i)) ? 1 / l : 0
                }
                return Wa(d, p, n, r, i, l), p
            };

            function Va(e, t, n, r, i) {
                var o, a;
                if (i === 0 < function (e, t, n, r) {
                    for (var i = 0, o = t, a = n - r; o < n; o += r) i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
                    return i
                }(e, t, n, r))
                    for (o = t; o < n; o += r) a = ss(o, e[o], e[o + 1], a);
                else
                    for (o = n - r; t <= o; o -= r) a = ss(o, e[o], e[o + 1], a);
                return a && rs(a, a.next) && (cs(a), a = a.next), a
            }

            function qa(e, t) {
                if (!e) return e;
                t || (t = e);
                var n, r = e;
                do {
                    if (n = !1, r.steiner || !rs(r, r.next) && 0 !== ns(r.prev, r, r.next)) r = r.next;
                    else {
                        if (cs(r), (r = t = r.prev) === r.next) break;
                        n = !0
                    }
                } while (n || r !== t);
                return t
            }

            function Wa(e, t, n, r, i, o, a) {
                if (e) {
                    !a && o && function (e, t, n, r) {
                        var i = e;
                        for (; null === i.z && (i.z = Ka(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next, i !== e;);
                        i.prevZ.nextZ = null, i.prevZ = null,
                            function (e) {
                                var t, n, r, i, o, a, s, c, l = 1;
                                do {
                                    for (n = e, o = e = null, a = 0; n;) {
                                        for (a++ , r = n, t = s = 0; t < l && (s++ , r = r.nextZ); t++);
                                        for (c = l; 0 < s || 0 < c && r;) 0 !== s && (0 === c || !r || n.z <= r.z) ? (n = (i = n).nextZ, s--) : (r = (i = r).nextZ, c--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i;
                                        n = r
                                    }
                                    o.nextZ = null, l *= 2
                                } while (1 < a)
                            }(i)
                    }(e, r, i, o);
                    for (var s, c, l = e; e.prev !== e.next;)
                        if (s = e.prev, c = e.next, o ? Ya(e, r, i, o) : Xa(e)) t.push(s.i / n), t.push(e.i / n), t.push(c.i / n), cs(e), e = c.next, l = c.next;
                        else if ((e = c) === l) {
                            a ? 1 === a ? Wa(e = Ja(e, t, n), t, n, r, i, o, 2) : 2 === a && Za(e, t, n, r, i, o) : Wa(qa(e), t, n, r, i, o, 1);
                            break
                        }
                }
            }

            function Xa(e) {
                var t = e.prev,
                    n = e,
                    r = e.next;
                if (0 <= ns(t, n, r)) return !1;
                for (var i = e.next.next; i !== e.prev;) {
                    if (ts(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= ns(i.prev, i, i.next)) return !1;
                    i = i.next
                }
                return !0
            }

            function Ya(e, t, n, r) {
                var i = e.prev,
                    o = e,
                    a = e.next;
                if (0 <= ns(i, o, a)) return !1;
                for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, l = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, u = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, h = Ka(s, c, t, n, r), d = Ka(l, u, t, n, r), p = e.nextZ; p && p.z <= d;) {
                    if (p !== e.prev && p !== e.next && ts(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && 0 <= ns(p.prev, p, p.next)) return !1;
                    p = p.nextZ
                }
                for (p = e.prevZ; p && p.z >= h;) {
                    if (p !== e.prev && p !== e.next && ts(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && 0 <= ns(p.prev, p, p.next)) return !1;
                    p = p.prevZ
                }
                return !0
            }

            function Ja(e, t, n) {
                var r = e;
                do {
                    var i = r.prev,
                        o = r.next.next;
                    !rs(i, o) && is(i, r, r.next, o) && os(i, o) && os(o, i) && (t.push(i.i / n), t.push(r.i / n), t.push(o.i / n), cs(r), cs(r.next), r = e = o), r = r.next
                } while (r !== e);
                return r
            }

            function Za(e, t, n, r, i, o) {
                var a, s, c = e;
                do {
                    for (var l = c.next.next; l !== c.prev;) {
                        if (c.i !== l.i && (s = l, (a = c).next.i !== s.i && a.prev.i !== s.i && ! function (e, t) {
                            var n = e;
                            do {
                                if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && is(n, n.next, e, t)) return !0;
                                n = n.next
                            } while (n !== e);
                            return !1
                        }(a, s) && os(a, s) && os(s, a) && function (e, t) {
                            var n = e,
                                r = !1,
                                i = (e.x + t.x) / 2,
                                o = (e.y + t.y) / 2;
                            for (; n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next, n !== e;);
                            return r
                        }(a, s))) {
                            var u = as(c, l);
                            return c = qa(c, c.next), u = qa(u, u.next), Wa(c, t, n, r, i, o), void Wa(u, t, n, r, i, o)
                        }
                        l = l.next
                    }
                    c = c.next
                } while (c !== e)
            }

            function $a(e, t) {
                return e.x - t.x
            }

            function Qa(e, t) {
                if (t = function (e, t) {
                    var n, r = t,
                        i = e.x,
                        o = e.y,
                        a = -1 / 0;
                    do {
                        if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                            var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                            if (s <= i && a < s) {
                                if ((a = s) === i) {
                                    if (o === r.y) return r;
                                    if (o === r.next.y) return r.next
                                }
                                n = r.x < r.next.x ? r : r.next
                            }
                        }
                        r = r.next
                    } while (r !== t);
                    if (!n) return null;
                    if (i === a) return n.prev;
                    var c, l = n,
                        u = n.x,
                        h = n.y,
                        d = 1 / 0;
                    r = n.next;
                    for (; r !== l;) i >= r.x && r.x >= u && i !== r.x && ts(o < h ? i : a, o, u, h, o < h ? a : i, o, r.x, r.y) && ((c = Math.abs(o - r.y) / (i - r.x)) < d || c === d && r.x > n.x) && os(r, e) && (n = r, d = c), r = r.next;
                    return n
                }(e, t)) {
                    var n = as(t, e);
                    qa(n, n.next)
                }
            }

            function Ka(e, t, n, r, i) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function es(e) {
                for (var t = e, n = e; t.x < n.x && (n = t), (t = t.next) !== e;);
                return n
            }

            function ts(e, t, n, r, i, o, a, s) {
                return 0 <= (i - a) * (t - s) - (e - a) * (o - s) && 0 <= (e - a) * (r - s) - (n - a) * (t - s) && 0 <= (n - a) * (o - s) - (i - a) * (r - s)
            }

            function ns(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function rs(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function is(e, t, n, r) {
                return !!(rs(e, t) && rs(n, r) || rs(e, r) && rs(n, t)) || 0 < ns(e, t, n) != 0 < ns(e, t, r) && 0 < ns(n, r, e) != 0 < ns(n, r, t)
            }

            function os(e, t) {
                return ns(e.prev, e, e.next) < 0 ? 0 <= ns(e, t, e.next) && 0 <= ns(e, e.prev, t) : ns(e, t, e.prev) < 0 || ns(e, e.next, t) < 0
            }

            function as(e, t) {
                var n = new ls(e.i, e.x, e.y),
                    r = new ls(t.i, t.x, t.y),
                    i = e.next,
                    o = t.prev;
                return (e.next = t).prev = e, (n.next = i).prev = n, (r.next = n).prev = r, (o.next = r).prev = o, r
            }

            function ss(e, t, n, r) {
                var i = new ls(e, t, n);
                return r ? (i.next = r.next, (i.prev = r).next.prev = i, r.next = i) : (i.prev = i).next = i, i
            }

            function cs(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function ls(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var us = {
                area: function (e) {
                    for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                    return .5 * n
                },
                isClockWise: function (e) {
                    return us.area(e) < 0
                },
                triangulateShape: function (e, t) {
                    var n = [],
                        r = [],
                        i = [];
                    hs(e), ds(n, e);
                    var o = e.length;
                    t.forEach(hs);
                    for (var a = 0; a < t.length; a++) r.push(o), o += t[a].length, ds(n, t[a]);
                    var s = Ga(n, r);
                    for (a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
                    return i
                }
            };

            function hs(e) {
                var t = e.length;
                2 < t && e[t - 1].equals(e[0]) && e.pop()
            }

            function ds(e, t) {
                for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }

            function ps(e, t) {
                rr.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, this.fromBufferGeometry(new fs(e, t)), this.mergeVertices()
            }

            function fs(e, Z) {
                Ar.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: e,
                    options: Z
                }, e = Array.isArray(e) ? e : [e];
                for (var $ = this, Q = [], K = [], t = 0, n = e.length; t < n; t++) {
                    r(e[t])
                }

                function r(e) {
                    var t, n, r, i, o, a, s, c, l = [],
                        u = void 0 !== Z.curveSegments ? Z.curveSegments : 12,
                        h = void 0 !== Z.steps ? Z.steps : 1,
                        d = void 0 !== Z.amount ? Z.amount : 100,
                        p = void 0 === Z.bevelEnabled || Z.bevelEnabled,
                        f = void 0 !== Z.bevelThickness ? Z.bevelThickness : 6,
                        m = void 0 !== Z.bevelSize ? Z.bevelSize : f - 2,
                        g = void 0 !== Z.bevelSegments ? Z.bevelSegments : 3,
                        v = Z.extrudePath,
                        y = void 0 !== Z.UVGenerator ? Z.UVGenerator : ms,
                        _ = !1;
                    v && (t = v.getSpacedPoints(h), p = !(_ = !0), n = v.computeFrenetFrames(h, !1), r = new Ut, i = new Ut, o = new Ut), p || (m = f = g = 0);
                    var x = e.extractPoints(u),
                        b = x.shape,
                        w = x.holes;
                    if (!us.isClockWise(b))
                        for (b = b.reverse(), s = 0, c = w.length; s < c; s++) a = w[s], us.isClockWise(a) && (w[s] = a.reverse());
                    var E = us.triangulateShape(b, w),
                        T = b;
                    for (s = 0, c = w.length; s < c; s++) a = w[s], b = b.concat(a);

                    function S(e, t, n) {
                        return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                    }
                    var M, A, C, L, R, P, O = b.length,
                        I = E.length;

                    function D(e, t, n) {
                        var r, i, o, a = e.x - t.x,
                            s = e.y - t.y,
                            c = n.x - e.x,
                            l = n.y - e.y,
                            u = a * a + s * s,
                            h = a * l - s * c;
                        if (Math.abs(h) > Number.EPSILON) {
                            var d = Math.sqrt(u),
                                p = Math.sqrt(c * c + l * l),
                                f = t.x - s / d,
                                m = t.y + a / d,
                                g = ((n.x - l / p - f) * l - (n.y + c / p - m) * c) / (a * l - s * c),
                                v = (r = f + a * g - e.x) * r + (i = m + s * g - e.y) * i;
                            if (v <= 2) return new jt(r, i);
                            o = Math.sqrt(v / 2)
                        } else {
                            var y = !1;
                            a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0), y ? (r = -s, i = a, o = Math.sqrt(u)) : (r = a, i = s, o = Math.sqrt(u / 2))
                        }
                        return new jt(r / o, i / o)
                    }
                    for (var j = [], N = 0, k = T.length, U = k - 1, H = N + 1; N < k; N++ , U++ , H++) U === k && (U = 0), H === k && (H = 0), j[N] = D(T[N], T[U], T[H]);
                    var B, F, z = [],
                        G = j.concat();
                    for (s = 0, c = w.length; s < c; s++) {
                        for (a = w[s], B = [], N = 0, U = (k = a.length) - 1, H = N + 1; N < k; N++ , U++ , H++) U === k && (U = 0), H === k && (H = 0), B[N] = D(a[N], a[U], a[H]);
                        z.push(B), G = G.concat(B)
                    }
                    for (M = 0; M < g; M++) {
                        for (C = M / g, L = f * Math.cos(C * Math.PI / 2), A = m * Math.sin(C * Math.PI / 2), N = 0, k = T.length; N < k; N++) q((R = S(T[N], j[N], A)).x, R.y, -L);
                        for (s = 0, c = w.length; s < c; s++)
                            for (a = w[s], B = z[s], N = 0, k = a.length; N < k; N++) q((R = S(a[N], B[N], A)).x, R.y, -L)
                    }
                    for (A = m, N = 0; N < O; N++) R = p ? S(b[N], G[N], A) : b[N], _ ? (i.copy(n.normals[0]).multiplyScalar(R.x), r.copy(n.binormals[0]).multiplyScalar(R.y), o.copy(t[0]).add(i).add(r), q(o.x, o.y, o.z)) : q(R.x, R.y, 0);
                    for (F = 1; F <= h; F++)
                        for (N = 0; N < O; N++) R = p ? S(b[N], G[N], A) : b[N], _ ? (i.copy(n.normals[F]).multiplyScalar(R.x), r.copy(n.binormals[F]).multiplyScalar(R.y), o.copy(t[F]).add(i).add(r), q(o.x, o.y, o.z)) : q(R.x, R.y, d / h * F);
                    for (M = g - 1; 0 <= M; M--) {
                        for (C = M / g, L = f * Math.cos(C * Math.PI / 2), A = m * Math.sin(C * Math.PI / 2), N = 0, k = T.length; N < k; N++) q((R = S(T[N], j[N], A)).x, R.y, d + L);
                        for (s = 0, c = w.length; s < c; s++)
                            for (a = w[s], B = z[s], N = 0, k = a.length; N < k; N++) R = S(a[N], B[N], A), _ ? q(R.x, R.y + t[h - 1].y, t[h - 1].x + L) : q(R.x, R.y, d + L)
                    }

                    function V(e, t) {
                        var n, r;
                        for (N = e.length; 0 <= --N;) {
                            (r = (n = N) - 1) < 0 && (r = e.length - 1);
                            var i = 0,
                                o = h + 2 * g;
                            for (i = 0; i < o; i++) {
                                var a = O * i,
                                    s = O * (i + 1);
                                X(t + n + a, t + r + a, t + r + s, t + n + s)
                            }
                        }
                    }

                    function q(e, t, n) {
                        l.push(e), l.push(t), l.push(n)
                    }

                    function W(e, t, n) {
                        Y(e), Y(t), Y(n);
                        var r = Q.length / 3,
                            i = y.generateTopUV($, Q, r - 3, r - 2, r - 1);
                        J(i[0]), J(i[1]), J(i[2])
                    }

                    function X(e, t, n, r) {
                        Y(e), Y(t), Y(r), Y(t), Y(n), Y(r);
                        var i = Q.length / 3,
                            o = y.generateSideWallUV($, Q, i - 6, i - 3, i - 2, i - 1);
                        J(o[0]), J(o[1]), J(o[3]), J(o[1]), J(o[2]), J(o[3])
                    }

                    function Y(e) {
                        Q.push(l[3 * e + 0]), Q.push(l[3 * e + 1]), Q.push(l[3 * e + 2])
                    }

                    function J(e) {
                        K.push(e.x), K.push(e.y)
                    } ! function () {
                        var e = Q.length / 3;
                        if (p) {
                            var t = 0,
                                n = O * t;
                            for (N = 0; N < I; N++) W((P = E[N])[2] + n, P[1] + n, P[0] + n);
                            for (n = O * (t = h + 2 * g), N = 0; N < I; N++) W((P = E[N])[0] + n, P[1] + n, P[2] + n)
                        } else {
                            for (N = 0; N < I; N++) W((P = E[N])[2], P[1], P[0]);
                            for (N = 0; N < I; N++) W((P = E[N])[0] + O * h, P[1] + O * h, P[2] + O * h)
                        }
                        $.addGroup(e, Q.length / 3 - e, 0)
                    }(),
                        function () {
                            var e = Q.length / 3,
                                t = 0;
                            for (V(T, t), t += T.length, s = 0, c = w.length; s < c; s++) V(a = w[s], t), t += a.length;
                            $.addGroup(e, Q.length / 3 - e, 1)
                        }()
                }
                this.addAttribute("position", new dr(Q, 3)), this.addAttribute("uv", new dr(K, 2)), this.computeVertexNormals()
            } (ps.prototype = Object.create(rr.prototype)).constructor = ps, (fs.prototype = Object.create(Ar.prototype)).constructor = fs;
            var ms = {
                generateTopUV: function (e, t, n, r, i) {
                    var o = t[3 * n],
                        a = t[3 * n + 1],
                        s = t[3 * r],
                        c = t[3 * r + 1],
                        l = t[3 * i],
                        u = t[3 * i + 1];
                    return [new jt(o, a), new jt(s, c), new jt(l, u)]
                },
                generateSideWallUV: function (e, t, n, r, i, o) {
                    var a = t[3 * n],
                        s = t[3 * n + 1],
                        c = t[3 * n + 2],
                        l = t[3 * r],
                        u = t[3 * r + 1],
                        h = t[3 * r + 2],
                        d = t[3 * i],
                        p = t[3 * i + 1],
                        f = t[3 * i + 2],
                        m = t[3 * o],
                        g = t[3 * o + 1],
                        v = t[3 * o + 2];
                    return Math.abs(s - u) < .01 ? [new jt(a, 1 - c), new jt(l, 1 - h), new jt(d, 1 - f), new jt(m, 1 - v)] : [new jt(s, 1 - c), new jt(u, 1 - h), new jt(p, 1 - f), new jt(g, 1 - v)]
                }
            };

            function gs(e, t) {
                rr.call(this), this.type = "TextGeometry", this.parameters = {
                    text: e,
                    parameters: t
                }, this.fromBufferGeometry(new vs(e, t)), this.mergeVertices()
            }

            function vs(e, t) {
                var n = (t = t || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new rr;
                var r = n.generateShapes(e, t.size, t.curveSegments);
                t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), fs.call(this, r, t), this.type = "TextBufferGeometry"
            }

            function ys(e, t, n, r, i, o, a) {
                rr.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new _s(e, t, n, r, i, o, a)), this.mergeVertices()
            }

            function _s(e, t, n, r, i, o, a) {
                Ar.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI;
                var s, c, l = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI),
                    u = 0,
                    h = [],
                    d = new Ut,
                    p = new Ut,
                    f = [],
                    m = [],
                    g = [],
                    v = [];
                for (c = 0; c <= n; c++) {
                    var y = [],
                        _ = c / n;
                    for (s = 0; s <= t; s++) {
                        var x = s / t;
                        d.x = -e * Math.cos(r + x * i) * Math.sin(o + _ * a), d.y = e * Math.cos(o + _ * a), d.z = e * Math.sin(r + x * i) * Math.sin(o + _ * a), m.push(d.x, d.y, d.z), p.set(d.x, d.y, d.z).normalize(), g.push(p.x, p.y, p.z), v.push(x, 1 - _), y.push(u++)
                    }
                    h.push(y)
                }
                for (c = 0; c < n; c++)
                    for (s = 0; s < t; s++) {
                        var b = h[c][s + 1],
                            w = h[c][s],
                            E = h[c + 1][s],
                            T = h[c + 1][s + 1];
                        (0 !== c || 0 < o) && f.push(b, w, T), (c !== n - 1 || l < Math.PI) && f.push(w, E, T)
                    }
                this.setIndex(f), this.addAttribute("position", new dr(m, 3)), this.addAttribute("normal", new dr(g, 3)), this.addAttribute("uv", new dr(v, 2))
            }

            function xs(e, t, n, r, i, o) {
                rr.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                }, this.fromBufferGeometry(new bs(e, t, n, r, i, o)), this.mergeVertices()
            }

            function bs(e, t, n, r, i, o) {
                Ar.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                }, e = e || .5, t = t || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
                var a, s, c, l = [],
                    u = [],
                    h = [],
                    d = [],
                    p = e,
                    f = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
                    m = new Ut,
                    g = new jt;
                for (s = 0; s <= r; s++) {
                    for (c = 0; c <= n; c++) a = i + c / n * o, m.x = p * Math.cos(a), m.y = p * Math.sin(a), u.push(m.x, m.y, m.z), h.push(0, 0, 1), g.x = (m.x / t + 1) / 2, g.y = (m.y / t + 1) / 2, d.push(g.x, g.y);
                    p += f
                }
                for (s = 0; s < r; s++) {
                    var v = s * (n + 1);
                    for (c = 0; c < n; c++) {
                        var y = a = c + v,
                            _ = a + n + 1,
                            x = a + n + 2,
                            b = a + 1;
                        l.push(y, _, b), l.push(_, x, b)
                    }
                }
                this.setIndex(l), this.addAttribute("position", new dr(u, 3)), this.addAttribute("normal", new dr(h, 3)), this.addAttribute("uv", new dr(d, 2))
            }

            function ws(e, t, n, r) {
                rr.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                }, this.fromBufferGeometry(new Es(e, t, n, r)), this.mergeVertices()
            }

            function Es(e, t, n, r) {
                Ar.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = Dt.clamp(r, 0, 2 * Math.PI);
                var i, o, a, s = [],
                    c = [],
                    l = [],
                    u = 1 / t,
                    h = new Ut,
                    d = new jt;
                for (o = 0; o <= t; o++) {
                    var p = n + o * u * r,
                        f = Math.sin(p),
                        m = Math.cos(p);
                    for (a = 0; a <= e.length - 1; a++) h.x = e[a].x * f, h.y = e[a].y, h.z = e[a].x * m, c.push(h.x, h.y, h.z), d.x = o / t, d.y = a / (e.length - 1), l.push(d.x, d.y)
                }
                for (o = 0; o < t; o++)
                    for (a = 0; a < e.length - 1; a++) {
                        var g = i = a + o * e.length,
                            v = i + e.length,
                            y = i + e.length + 1,
                            _ = i + 1;
                        s.push(g, v, _), s.push(v, y, _)
                    }
                if (this.setIndex(s), this.addAttribute("position", new dr(c, 3)), this.addAttribute("uv", new dr(l, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                    var x = this.attributes.normal.array,
                        b = new Ut,
                        w = new Ut,
                        E = new Ut;
                    for (i = t * e.length * 3, a = o = 0; o < e.length; o++ , a += 3) b.x = x[a + 0], b.y = x[a + 1], b.z = x[a + 2], w.x = x[i + a + 0], w.y = x[i + a + 1], w.z = x[i + a + 2], E.addVectors(b, w).normalize(), x[a + 0] = x[i + a + 0] = E.x, x[a + 1] = x[i + a + 1] = E.y, x[a + 2] = x[i + a + 2] = E.z
                }
            }

            function Ts(e, t) {
                rr.call(this), this.type = "ShapeGeometry", "object" === (void 0 === t ? "undefined" : r(t)) && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
                    shapes: e,
                    curveSegments: t
                }, this.fromBufferGeometry(new Ss(e, t)), this.mergeVertices()
            }

            function Ss(e, f) {
                Ar.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: e,
                    curveSegments: f
                }, f = f || 12;
                var m = [],
                    g = [],
                    v = [],
                    y = [],
                    t = 0,
                    _ = 0;
                if (!1 === Array.isArray(e)) r(e);
                else
                    for (var n = 0; n < e.length; n++) r(e[n]), this.addGroup(t, _, n), t += _, _ = 0;

                function r(e) {
                    var t, n, r, i = g.length / 3,
                        o = e.extractPoints(f),
                        a = o.shape,
                        s = o.holes;
                    if (!1 === us.isClockWise(a))
                        for (a = a.reverse(), t = 0, n = s.length; t < n; t++) r = s[t], !0 === us.isClockWise(r) && (s[t] = r.reverse());
                    var c = us.triangulateShape(a, s);
                    for (t = 0, n = s.length; t < n; t++) r = s[t], a = a.concat(r);
                    for (t = 0, n = a.length; t < n; t++) {
                        var l = a[t];
                        g.push(l.x, l.y, 0), v.push(0, 0, 1), y.push(l.x, l.y)
                    }
                    for (t = 0, n = c.length; t < n; t++) {
                        var u = c[t],
                            h = u[0] + i,
                            d = u[1] + i,
                            p = u[2] + i;
                        m.push(h, d, p), _ += 3
                    }
                }
                this.setIndex(m), this.addAttribute("position", new dr(g, 3)), this.addAttribute("normal", new dr(v, 3)), this.addAttribute("uv", new dr(y, 2))
            }

            function Ms(e, t) {
                if (t.shapes = [], Array.isArray(e))
                    for (var n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.shapes.push(i.uuid)
                    } else t.shapes.push(e.uuid);
                return t
            }

            function As(e, t) {
                Ar.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: t
                }, t = void 0 !== t ? t : 1;
                var n, r, i, o, a = [],
                    s = Math.cos(Dt.DEG2RAD * t),
                    c = [0, 0],
                    l = {},
                    u = ["a", "b", "c"];
                e.isBufferGeometry ? (o = new rr).fromBufferGeometry(e) : o = e.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var h = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], g = 0; g < 3; g++) n = m[u[g]], r = m[u[(g + 1) % 3]], c[0] = Math.min(n, r), c[1] = Math.max(n, r), void 0 === l[i = c[0] + "," + c[1]] ? l[i] = {
                        index1: c[0],
                        index2: c[1],
                        face1: p,
                        face2: void 0
                    } : l[i].face2 = p;
                for (i in l) {
                    var v = l[i];
                    if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) {
                        var y = h[v.index1];
                        a.push(y.x, y.y, y.z), y = h[v.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new dr(a, 3))
            }

            function Cs(e, t, n, r, i, o, a, s) {
                rr.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new Ls(e, t, n, r, i, o, a, s)), this.mergeVertices()
            }

            function Ls(v, y, _, x, b, e, w, E) {
                Ar.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: v,
                    radiusBottom: y,
                    height: _,
                    radialSegments: x,
                    heightSegments: b,
                    openEnded: e,
                    thetaStart: w,
                    thetaLength: E
                };
                var T = this;
                v = void 0 !== v ? v : 1, y = void 0 !== y ? y : 1, _ = _ || 1, x = Math.floor(x) || 8, b = Math.floor(b) || 1, e = void 0 !== e && e, w = void 0 !== w ? w : 0, E = void 0 !== E ? E : 2 * Math.PI;
                var S = [],
                    M = [],
                    A = [],
                    C = [],
                    L = 0,
                    R = [],
                    P = _ / 2,
                    O = 0;

                function t(e) {
                    var t, n, r, i = new jt,
                        o = new Ut,
                        a = 0,
                        s = !0 === e ? v : y,
                        c = !0 === e ? 1 : -1;
                    for (n = L, t = 1; t <= x; t++) M.push(0, P * c, 0), A.push(0, c, 0), C.push(.5, .5), L++;
                    for (r = L, t = 0; t <= x; t++) {
                        var l = t / x * E + w,
                            u = Math.cos(l),
                            h = Math.sin(l);
                        o.x = s * h, o.y = P * c, o.z = s * u, M.push(o.x, o.y, o.z), A.push(0, c, 0), i.x = .5 * u + .5, i.y = .5 * h * c + .5, C.push(i.x, i.y), L++
                    }
                    for (t = 0; t < x; t++) {
                        var d = n + t,
                            p = r + t;
                        !0 === e ? S.push(p, p + 1, d) : S.push(p + 1, p, d), a += 3
                    }
                    T.addGroup(O, a, !0 === e ? 1 : 2), O += a
                } ! function () {
                    var e, t, n = new Ut,
                        r = new Ut,
                        i = 0,
                        o = (y - v) / _;
                    for (t = 0; t <= b; t++) {
                        var a = [],
                            s = t / b,
                            c = s * (y - v) + v;
                        for (e = 0; e <= x; e++) {
                            var l = e / x,
                                u = l * E + w,
                                h = Math.sin(u),
                                d = Math.cos(u);
                            r.x = c * h, r.y = -s * _ + P, r.z = c * d, M.push(r.x, r.y, r.z), n.set(h, o, d).normalize(), A.push(n.x, n.y, n.z), C.push(l, 1 - s), a.push(L++)
                        }
                        R.push(a)
                    }
                    for (e = 0; e < x; e++)
                        for (t = 0; t < b; t++) {
                            var p = R[t][e],
                                f = R[t + 1][e],
                                m = R[t + 1][e + 1],
                                g = R[t][e + 1];
                            S.push(p, f, g), S.push(f, m, g), i += 6
                        }
                    T.addGroup(O, i, 0), O += i
                }(), !1 === e && (0 < v && t(!0), 0 < y && t(!1)), this.setIndex(S), this.addAttribute("position", new dr(M, 3)), this.addAttribute("normal", new dr(A, 3)), this.addAttribute("uv", new dr(C, 2))
            }

            function Rs(e, t, n, r, i, o, a) {
                Cs.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Ps(e, t, n, r, i, o, a) {
                Ls.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Os(e, t, n, r) {
                rr.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                }, this.fromBufferGeometry(new Is(e, t, n, r)), this.mergeVertices()
            }

            function Is(e, t, n, r) {
                Ar.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var i, o, a = [],
                    s = [],
                    c = [],
                    l = [],
                    u = new Ut,
                    h = new jt;
                for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5), o = 0, i = 3; o <= t; o++ , i += 3) {
                    var d = n + o / t * r;
                    u.x = e * Math.cos(d), u.y = e * Math.sin(d), s.push(u.x, u.y, u.z), c.push(0, 0, 1), h.x = (s[i] / e + 1) / 2, h.y = (s[i + 1] / e + 1) / 2, l.push(h.x, h.y)
                }
                for (i = 1; i <= t; i++) a.push(i, i + 1, 0);
                this.setIndex(a), this.addAttribute("position", new dr(s, 3)), this.addAttribute("normal", new dr(c, 3)), this.addAttribute("uv", new dr(l, 2))
            } (gs.prototype = Object.create(rr.prototype)).constructor = gs, (vs.prototype = Object.create(fs.prototype)).constructor = vs, (ys.prototype = Object.create(rr.prototype)).constructor = ys, (_s.prototype = Object.create(Ar.prototype)).constructor = _s, (xs.prototype = Object.create(rr.prototype)).constructor = xs, (bs.prototype = Object.create(Ar.prototype)).constructor = bs, (ws.prototype = Object.create(rr.prototype)).constructor = ws, (Es.prototype = Object.create(Ar.prototype)).constructor = Es, ((Ts.prototype = Object.create(rr.prototype)).constructor = Ts).prototype.toJSON = function () {
                var e = rr.prototype.toJSON.call(this);
                return Ms(this.parameters.shapes, e)
            }, ((Ss.prototype = Object.create(Ar.prototype)).constructor = Ss).prototype.toJSON = function () {
                var e = Ar.prototype.toJSON.call(this);
                return Ms(this.parameters.shapes, e)
            }, (As.prototype = Object.create(Ar.prototype)).constructor = As, (Cs.prototype = Object.create(rr.prototype)).constructor = Cs, (Ls.prototype = Object.create(Ar.prototype)).constructor = Ls, (Rs.prototype = Object.create(Cs.prototype)).constructor = Rs, (Ps.prototype = Object.create(Ls.prototype)).constructor = Ps, (Os.prototype = Object.create(rr.prototype)).constructor = Os, (Is.prototype = Object.create(Ar.prototype)).constructor = Is;
            var Ds = Object.freeze({
                WireframeGeometry: Ta,
                ParametricGeometry: Sa,
                ParametricBufferGeometry: Ma,
                TetrahedronGeometry: La,
                TetrahedronBufferGeometry: Ra,
                OctahedronGeometry: Pa,
                OctahedronBufferGeometry: Oa,
                IcosahedronGeometry: Ia,
                IcosahedronBufferGeometry: Da,
                DodecahedronGeometry: ja,
                DodecahedronBufferGeometry: Na,
                PolyhedronGeometry: Aa,
                PolyhedronBufferGeometry: Ca,
                TubeGeometry: ka,
                TubeBufferGeometry: Ua,
                TorusKnotGeometry: Ha,
                TorusKnotBufferGeometry: Ba,
                TorusGeometry: Fa,
                TorusBufferGeometry: za,
                TextGeometry: gs,
                TextBufferGeometry: vs,
                SphereGeometry: ys,
                SphereBufferGeometry: _s,
                RingGeometry: xs,
                RingBufferGeometry: bs,
                PlaneGeometry: Rr,
                PlaneBufferGeometry: Pr,
                LatheGeometry: ws,
                LatheBufferGeometry: Es,
                ShapeGeometry: Ts,
                ShapeBufferGeometry: Ss,
                ExtrudeGeometry: ps,
                ExtrudeBufferGeometry: fs,
                EdgesGeometry: As,
                ConeGeometry: Rs,
                ConeBufferGeometry: Ps,
                CylinderGeometry: Cs,
                CylinderBufferGeometry: Ls,
                CircleGeometry: Os,
                CircleBufferGeometry: Is,
                BoxGeometry: Cr,
                BoxBufferGeometry: Lr
            });

            function js(e) {
                ri.call(this), this.type = "ShadowMaterial", this.color = new yn(0), this.transparent = !0, this.setValues(e)
            }

            function Ns(e) {
                oi.call(this, e), this.type = "RawShaderMaterial"
            }

            function ks(e) {
                ri.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new yn(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new yn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Us(e) {
                ks.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e)
            }

            function Hs(e) {
                ri.call(this), this.type = "MeshPhongMaterial", this.color = new yn(16777215), this.specular = new yn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new yn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ue, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Bs(e) {
                Hs.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
            }

            function Fs(e) {
                ri.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function zs(e) {
                ri.call(this), this.type = "MeshLambertMaterial", this.color = new yn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new yn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ue, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Gs(e) {
                fa.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            } ((js.prototype = Object.create(ri.prototype)).constructor = js).prototype.isShadowMaterial = !0, js.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.color.copy(e.color), this
            }, ((Ns.prototype = Object.create(oi.prototype)).constructor = Ns).prototype.isRawShaderMaterial = !0, ((ks.prototype = Object.create(ri.prototype)).constructor = ks).prototype.isMeshStandardMaterial = !0, ks.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((Us.prototype = Object.create(ks.prototype)).constructor = Us).prototype.isMeshPhysicalMaterial = !0, Us.prototype.copy = function (e) {
                return ks.prototype.copy.call(this, e), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
            }, ((Hs.prototype = Object.create(ri.prototype)).constructor = Hs).prototype.isMeshPhongMaterial = !0, Hs.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((Bs.prototype = Object.create(Hs.prototype)).constructor = Bs).prototype.isMeshToonMaterial = !0, Bs.prototype.copy = function (e) {
                return Hs.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
            }, ((Fs.prototype = Object.create(ri.prototype)).constructor = Fs).prototype.isMeshNormalMaterial = !0, Fs.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((zs.prototype = Object.create(ri.prototype)).constructor = zs).prototype.isMeshLambertMaterial = !0, zs.prototype.copy = function (e) {
                return ri.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((Gs.prototype = Object.create(fa.prototype)).constructor = Gs).prototype.isLineDashedMaterial = !0, Gs.prototype.copy = function (e) {
                return fa.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            };
            var Vs = Object.freeze({
                ShadowMaterial: js,
                SpriteMaterial: ca,
                RawShaderMaterial: Ns,
                ShaderMaterial: oi,
                PointsMaterial: ya,
                MeshPhysicalMaterial: Us,
                MeshStandardMaterial: ks,
                MeshPhongMaterial: Hs,
                MeshToonMaterial: Bs,
                MeshNormalMaterial: Fs,
                MeshLambertMaterial: zs,
                MeshDepthMaterial: Xo,
                MeshDistanceMaterial: Yo,
                MeshBasicMaterial: ii,
                LineDashedMaterial: Gs,
                LineBasicMaterial: fa,
                Material: ri
            }),
                qs = {
                    enabled: !1,
                    files: {},
                    add: function (e, t) {
                        !1 !== this.enabled && (this.files[e] = t)
                    },
                    get: function (e) {
                        if (!1 !== this.enabled) return this.files[e]
                    },
                    remove: function (e) {
                        delete this.files[e]
                    },
                    clear: function () {
                        this.files = {}
                    }
                };

            function Ws(e, t, n) {
                var r = this,
                    i = !1,
                    o = 0,
                    a = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
                    a++ , !1 === i && void 0 !== r.onStart && r.onStart(e, o, a), i = !0
                }, this.itemEnd = function (e) {
                    o++ , void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function (e) {
                    void 0 !== r.onError && r.onError(e)
                }, this.resolveURL = function (e) {
                    return s ? s(e) : e
                }, this.setURLModifier = function (e) {
                    return s = e, this
                }
            }
            var Xs = new Ws,
                Ys = {};

            function Js(e) {
                this.manager = void 0 !== e ? e : Xs
            }

            function Zs(e) {
                this.manager = void 0 !== e ? e : Xs, this._parser = null
            }

            function $s(e) {
                this.manager = void 0 !== e ? e : Xs, this._parser = null
            }

            function Qs(e) {
                this.manager = void 0 !== e ? e : Xs
            }

            function Ks(e) {
                this.manager = void 0 !== e ? e : Xs
            }

            function ec(e) {
                this.manager = void 0 !== e ? e : Xs
            }

            function tc() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function nc(e, t, n, r, i, o, a, s) {
                tc.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function rc(e, t, n, r, i, o) {
                nc.call(this, e, t, n, n, r, i, o), this.type = "ArcCurve"
            }

            function ic() {
                var i = 0,
                    o = 0,
                    a = 0,
                    s = 0;

                function l(e, t, n, r) {
                    a = -3 * (i = e) + 3 * t - 2 * (o = n) - r, s = 2 * e - 2 * t + n + r
                }
                return {
                    initCatmullRom: function (e, t, n, r, i) {
                        l(t, n, i * (n - e), i * (r - t))
                    },
                    initNonuniformCatmullRom: function (e, t, n, r, i, o, a) {
                        var s = (t - e) / i - (n - e) / (i + o) + (n - t) / o,
                            c = (n - t) / o - (r - t) / (o + a) + (r - n) / a;
                        l(t, n, s *= o, c *= o)
                    },
                    calc: function (e) {
                        var t = e * e;
                        return i + o * e + a * t + s * (t * e)
                    }
                }
            }
            Object.assign(Js.prototype, {
                load: function (a, e, t, n) {
                    void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
                    var s = this,
                        r = qs.get(a);
                    if (void 0 !== r) return s.manager.itemStart(a), setTimeout(function () {
                        e && e(r), s.manager.itemEnd(a)
                    }, 0), r;
                    if (void 0 === Ys[a]) {
                        var i = a.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (i) {
                            var o = i[1],
                                c = !!i[2],
                                l = i[3];
                            l = window.decodeURIComponent(l), c && (l = window.atob(l));
                            try {
                                var u, h = (this.responseType || "").toLowerCase();
                                switch (h) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var d = new Uint8Array(l.length), p = 0; p < l.length; p++) d[p] = l.charCodeAt(p);
                                        u = "blob" === h ? new Blob([d.buffer], {
                                            type: o
                                        }) : d.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        u = f.parseFromString(l, o);
                                        break;
                                    case "json":
                                        u = JSON.parse(l);
                                        break;
                                    default:
                                        u = l
                                }
                                window.setTimeout(function () {
                                    e && e(u), s.manager.itemEnd(a)
                                }, 0)
                            } catch (e) {
                                window.setTimeout(function () {
                                    n && n(e), s.manager.itemEnd(a), s.manager.itemError(a)
                                }, 0)
                            }
                        } else {
                            Ys[a] = [], Ys[a].push({
                                onLoad: e,
                                onProgress: t,
                                onError: n
                            });
                            var m = new XMLHttpRequest;
                            for (var g in m.open("GET", a, !0), m.addEventListener("load", function (e) {
                                var t = this.response;
                                qs.add(a, t);
                                var n = Ys[a];
                                if (delete Ys[a], 200 === this.status) {
                                    for (var r = 0, i = n.length; r < i; r++) {
                                        (o = n[r]).onLoad && o.onLoad(t)
                                    }
                                    s.manager.itemEnd(a)
                                } else if (0 === this.status) {
                                    console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                    for (r = 0, i = n.length; r < i; r++) {
                                        (o = n[r]).onLoad && o.onLoad(t)
                                    }
                                    s.manager.itemEnd(a)
                                } else {
                                    for (r = 0, i = n.length; r < i; r++) {
                                        var o;
                                        (o = n[r]).onError && o.onError(e)
                                    }
                                    s.manager.itemEnd(a), s.manager.itemError(a)
                                }
                            }, !1), m.addEventListener("progress", function (e) {
                                for (var t = Ys[a], n = 0, r = t.length; n < r; n++) {
                                    var i = t[n];
                                    i.onProgress && i.onProgress(e)
                                }
                            }, !1), m.addEventListener("error", function (e) {
                                var t = Ys[a];
                                delete Ys[a];
                                for (var n = 0, r = t.length; n < r; n++) {
                                    var i = t[n];
                                    i.onError && i.onError(e)
                                }
                                s.manager.itemEnd(a), s.manager.itemError(a)
                            }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
                            m.send(null)
                        }
                        return s.manager.itemStart(a), m
                    }
                    Ys[a].push({
                        onLoad: e,
                        onProgress: t,
                        onError: n
                    })
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setResponseType: function (e) {
                    return this.responseType = e, this
                },
                setWithCredentials: function (e) {
                    return this.withCredentials = e, this
                },
                setMimeType: function (e) {
                    return this.mimeType = e, this
                },
                setRequestHeader: function (e) {
                    return this.requestHeader = e, this
                }
            }), Object.assign(Zs.prototype, {
                load: function (e, o, t, r) {
                    var a = this,
                        s = [],
                        c = new wa;
                    c.image = s;
                    var i = new Js(this.manager);

                    function n(n) {
                        i.load(e[n], function (e) {
                            var t = a._parser(e, !0);
                            s[n] = {
                                width: t.width,
                                height: t.height,
                                format: t.format,
                                mipmaps: t.mipmaps
                            }, 6 === (l += 1) && (1 === t.mipmapCount && (c.minFilter = Oe), c.format = t.format, c.needsUpdate = !0, o && o(c))
                        }, t, r)
                    }
                    if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var l = 0, u = 0, h = e.length; u < h; ++u) n(u);
                    else i.load(e, function (e) {
                        var t = a._parser(e, !0);
                        if (t.isCubemap)
                            for (var n = t.mipmaps.length / t.mipmapCount, r = 0; r < n; r++) {
                                s[r] = {
                                    mipmaps: []
                                };
                                for (var i = 0; i < t.mipmapCount; i++) s[r].mipmaps.push(t.mipmaps[r * t.mipmapCount + i]), s[r].format = t.format, s[r].width = t.width, s[r].height = t.height
                            } else c.image.width = t.width, c.image.height = t.height, c.mipmaps = t.mipmaps;
                        1 === t.mipmapCount && (c.minFilter = Oe), c.format = t.format, c.needsUpdate = !0, o && o(c)
                    }, t, r);
                    return c
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign($s.prototype, {
                load: function (e, n, t, r) {
                    var i = this,
                        o = new ln,
                        a = new Js(this.manager);
                    return a.setResponseType("arraybuffer"), a.load(e, function (e) {
                        var t = i._parser(e);
                        t && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width, o.image.height = t.height, o.image.data = t.data), o.wrapS = void 0 !== t.wrapS ? t.wrapS : Ae, o.wrapT = void 0 !== t.wrapT ? t.wrapT : Ae, o.magFilter = void 0 !== t.magFilter ? t.magFilter : Oe, o.minFilter = void 0 !== t.minFilter ? t.minFilter : De, o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (o.format = t.format), void 0 !== t.type && (o.type = t.type), void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps), 1 === t.mipmapCount && (o.minFilter = Oe), o.needsUpdate = !0, n && n(o, t))
                    }, t, r), o
                }
            }), Object.assign(Qs.prototype, {
                crossOrigin: "Anonymous",
                load: function (t, e, n, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var i = this,
                        o = qs.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function () {
                        e && e(o), i.manager.itemEnd(t)
                    }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    return a.addEventListener("load", function () {
                        qs.add(t, this), e && e(this), i.manager.itemEnd(t)
                    }, !1), a.addEventListener("error", function (e) {
                        r && r(e), i.manager.itemEnd(t), i.manager.itemError(t)
                    }, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Ks.prototype, {
                crossOrigin: "Anonymous",
                load: function (e, n, t, r) {
                    var i = new bi,
                        o = new Qs(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(t) {
                        o.load(e[t], function (e) {
                            i.images[t] = e, 6 === ++a && (i.needsUpdate = !0, n && n(i))
                        }, void 0, r)
                    }
                    for (var c = 0; c < e.length; ++c) s(c);
                    return i
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(ec.prototype, {
                crossOrigin: "Anonymous",
                load: function (n, r, e, t) {
                    var i = new on,
                        o = new Qs(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(n, function (e) {
                        i.image = e;
                        var t = 0 < n.search(/\.(jpg|jpeg)$/) || 0 === n.search(/^data\:image\/jpeg/);
                        i.format = t ? Ye : Je, i.needsUpdate = !0, void 0 !== r && r(i)
                    }, e, t), i
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(tc.prototype, {
                getPoint: function () {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function (e, t) {
                    var n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                },
                getPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                },
                getSpacedPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                },
                getLength: function () {
                    var e = this.getLengths();
                    return e[e.length - 1]
                },
                getLengths: function (e) {
                    if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t, n, r = [],
                        i = this.getPoint(0),
                        o = 0;
                    for (r.push(0), n = 1; n <= e; n++) o += (t = this.getPoint(n / e)).distanceTo(i), r.push(o), i = t;
                    return this.cacheArcLengths = r
                },
                updateArcLengths: function () {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function (e, t) {
                    var n, r = this.getLengths(),
                        i = 0,
                        o = r.length;
                    n = t || e * r[o - 1];
                    for (var a, s = 0, c = o - 1; s <= c;)
                        if ((a = r[i = Math.floor(s + (c - s) / 2)] - n) < 0) s = i + 1;
                        else {
                            if (!(0 < a)) {
                                c = i;
                                break
                            }
                            c = i - 1
                        }
                    if (r[i = c] === n) return i / (o - 1);
                    var l = r[i];
                    return (i + (n - l) / (r[i + 1] - l)) / (o - 1)
                },
                getTangent: function (e) {
                    var t = e - 1e-4,
                        n = e + 1e-4;
                    t < 0 && (t = 0), 1 < n && (n = 1);
                    var r = this.getPoint(t);
                    return this.getPoint(n).clone().sub(r).normalize()
                },
                getTangentAt: function (e) {
                    var t = this.getUtoTmapping(e);
                    return this.getTangent(t)
                },
                computeFrenetFrames: function (e, t) {
                    var n, r, i, o = new Ut,
                        a = [],
                        s = [],
                        c = [],
                        l = new Ut,
                        u = new Nt;
                    for (n = 0; n <= e; n++) r = n / e, a[n] = this.getTangentAt(r), a[n].normalize();
                    s[0] = new Ut, c[0] = new Ut;
                    var h = Number.MAX_VALUE,
                        d = Math.abs(a[0].x),
                        p = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (d <= h && (h = d, o.set(1, 0, 0)), p <= h && (h = p, o.set(0, 1, 0)), f <= h && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), l.crossVectors(a[n - 1], a[n]), l.length() > Number.EPSILON && (l.normalize(), i = Math.acos(Dt.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(u.makeRotationAxis(l, i))), c[n].crossVectors(a[n], s[n]);
                    if (!0 === t)
                        for (i = Math.acos(Dt.clamp(s[0].dot(s[e]), -1, 1)), i /= e, 0 < a[0].dot(l.crossVectors(s[0], s[e])) && (i = -i), n = 1; n <= e; n++) s[n].applyMatrix4(u.makeRotationAxis(a[n], i * n)), c[n].crossVectors(a[n], s[n]);
                    return {
                        tangents: a,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                },
                toJSON: function () {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                },
                fromJSON: function (e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }), ((nc.prototype = Object.create(tc.prototype)).constructor = nc).prototype.isEllipseCurve = !0, nc.prototype.getPoint = function (e, t) {
                for (var n = t || new jt, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
                for (; r < i;) i -= r;
                i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                var a = this.aStartAngle + e * i,
                    s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                        u = Math.sin(this.aRotation),
                        h = s - this.aX,
                        d = c - this.aY;
                    s = h * l - d * u + this.aX, c = h * u + d * l + this.aY
                }
                return n.set(s, c)
            }, nc.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, nc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }, nc.prototype.fromJSON = function (e) {
                return tc.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, ((rc.prototype = Object.create(nc.prototype)).constructor = rc).prototype.isArcCurve = !0;
            var oc = new Ut,
                ac = new ic,
                sc = new ic,
                cc = new ic;

            function lc(e, t, n, r) {
                tc.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = r || .5
            }

            function uc(e, t, n, r, i) {
                var o = .5 * (r - t),
                    a = .5 * (i - n),
                    s = e * e;
                return (2 * n - 2 * r + o + a) * (e * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
            }

            function hc(e, t, n, r) {
                return (a = 1 - e) * a * t + 2 * (1 - (o = e)) * o * n + (i = e) * i * r;
                var i, o, a
            }

            function dc(e, t, n, r, i) {
                return (l = 1 - e) * l * l * t + 3 * (c = 1 - (s = e)) * c * s * n + 3 * (1 - (a = e)) * a * a * r + (o = e) * o * o * i;
                var o, a, s, c, l
            }

            function pc(e, t, n, r) {
                tc.call(this), this.type = "CubicBezierCurve", this.v0 = e || new jt, this.v1 = t || new jt, this.v2 = n || new jt, this.v3 = r || new jt
            }

            function fc(e, t, n, r) {
                tc.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Ut, this.v1 = t || new Ut, this.v2 = n || new Ut, this.v3 = r || new Ut
            }

            function mc(e, t) {
                tc.call(this), this.type = "LineCurve", this.v1 = e || new jt, this.v2 = t || new jt
            }

            function gc(e, t) {
                tc.call(this), this.type = "LineCurve3", this.v1 = e || new Ut, this.v2 = t || new Ut
            }

            function vc(e, t, n) {
                tc.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new jt, this.v1 = t || new jt, this.v2 = n || new jt
            }

            function yc(e, t, n) {
                tc.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Ut, this.v1 = t || new Ut, this.v2 = n || new Ut
            }

            function _c(e) {
                tc.call(this), this.type = "SplineCurve", this.points = e || []
            } ((lc.prototype = Object.create(tc.prototype)).constructor = lc).prototype.isCatmullRomCurve3 = !0, lc.prototype.getPoint = function (e, t) {
                var n, r, i, o, a = t || new Ut,
                    s = this.points,
                    c = s.length,
                    l = (c - (this.closed ? 0 : 1)) * e,
                    u = Math.floor(l),
                    h = l - u;
                if (this.closed ? u += 0 < u ? 0 : (Math.floor(Math.abs(u) / c) + 1) * c : 0 === h && u === c - 1 && (u = c - 2, h = 1), this.closed || 0 < u ? n = s[(u - 1) % c] : (oc.subVectors(s[0], s[1]).add(s[0]), n = oc), r = s[u % c], i = s[(u + 1) % c], this.closed || u + 2 < c ? o = s[(u + 2) % c] : (oc.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = oc), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var d = "chordal" === this.curveType ? .5 : .25,
                        p = Math.pow(n.distanceToSquared(r), d),
                        f = Math.pow(r.distanceToSquared(i), d),
                        m = Math.pow(i.distanceToSquared(o), d);
                    f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), ac.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, p, f, m), sc.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, p, f, m), cc.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, p, f, m)
                } else "catmullrom" === this.curveType && (ac.initCatmullRom(n.x, r.x, i.x, o.x, this.tension), sc.initCatmullRom(n.y, r.y, i.y, o.y, this.tension), cc.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
                return a.set(ac.calc(h), sc.calc(h), cc.calc(h)), a
            }, lc.prototype.copy = function (e) {
                tc.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push(r.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, lc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var r = this.points[t];
                    e.points.push(r.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }, lc.prototype.fromJSON = function (e) {
                tc.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push((new Ut).fromArray(r))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, ((pc.prototype = Object.create(tc.prototype)).constructor = pc).prototype.isCubicBezierCurve = !0, pc.prototype.getPoint = function (e, t) {
                var n = t || new jt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(dc(e, r.x, i.x, o.x, a.x), dc(e, r.y, i.y, o.y, a.y)), n
            }, pc.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, pc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, pc.prototype.fromJSON = function (e) {
                return tc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, ((fc.prototype = Object.create(tc.prototype)).constructor = fc).prototype.isCubicBezierCurve3 = !0, fc.prototype.getPoint = function (e, t) {
                var n = t || new Ut,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(dc(e, r.x, i.x, o.x, a.x), dc(e, r.y, i.y, o.y, a.y), dc(e, r.z, i.z, o.z, a.z)), n
            }, fc.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, fc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, fc.prototype.fromJSON = function (e) {
                return tc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, ((mc.prototype = Object.create(tc.prototype)).constructor = mc).prototype.isLineCurve = !0, mc.prototype.getPoint = function (e, t) {
                var n = t || new jt;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, mc.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t)
            }, mc.prototype.getTangent = function () {
                return this.v2.clone().sub(this.v1).normalize()
            }, mc.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, mc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, mc.prototype.fromJSON = function (e) {
                return tc.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((gc.prototype = Object.create(tc.prototype)).constructor = gc).prototype.isLineCurve3 = !0, gc.prototype.getPoint = function (e, t) {
                var n = t || new Ut;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, gc.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t)
            }, gc.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, gc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, gc.prototype.fromJSON = function (e) {
                return tc.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((vc.prototype = Object.create(tc.prototype)).constructor = vc).prototype.isQuadraticBezierCurve = !0, vc.prototype.getPoint = function (e, t) {
                var n = t || new jt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(hc(e, r.x, i.x, o.x), hc(e, r.y, i.y, o.y)), n
            }, vc.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, vc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, vc.prototype.fromJSON = function (e) {
                return tc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((yc.prototype = Object.create(tc.prototype)).constructor = yc).prototype.isQuadraticBezierCurve3 = !0, yc.prototype.getPoint = function (e, t) {
                var n = t || new Ut,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(hc(e, r.x, i.x, o.x), hc(e, r.y, i.y, o.y), hc(e, r.z, i.z, o.z)), n
            }, yc.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, yc.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, yc.prototype.fromJSON = function (e) {
                return tc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((_c.prototype = Object.create(tc.prototype)).constructor = _c).prototype.isSplineCurve = !0, _c.prototype.getPoint = function (e, t) {
                var n = t || new jt,
                    r = this.points,
                    i = (r.length - 1) * e,
                    o = Math.floor(i),
                    a = i - o,
                    s = r[0 === o ? o : o - 1],
                    c = r[o],
                    l = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    u = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return n.set(uc(a, s.x, c.x, l.x, u.x), uc(a, s.y, c.y, l.y, u.y)), n
            }, _c.prototype.copy = function (e) {
                tc.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push(r.clone())
                }
                return this
            }, _c.prototype.toJSON = function () {
                var e = tc.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var r = this.points[t];
                    e.points.push(r.toArray())
                }
                return e
            }, _c.prototype.fromJSON = function (e) {
                tc.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push((new jt).fromArray(r))
                }
                return this
            };
            var xc = Object.freeze({
                ArcCurve: rc,
                CatmullRomCurve3: lc,
                CubicBezierCurve: pc,
                CubicBezierCurve3: fc,
                EllipseCurve: nc,
                LineCurve: mc,
                LineCurve3: gc,
                QuadraticBezierCurve: vc,
                QuadraticBezierCurve3: yc,
                SplineCurve: _c
            });

            function bc() {
                tc.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function wc(e) {
                bc.call(this), this.type = "Path", this.currentPoint = new jt, e && this.setFromPoints(e)
            }

            function Ec(e) {
                wc.call(this, e), this.uuid = Dt.generateUUID(), this.type = "Shape", this.holes = []
            }

            function Tc(e, t) {
                qn.call(this), this.type = "Light", this.color = new yn(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
            }

            function Sc(e, t, n) {
                Tc.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(qn.DefaultUp), this.updateMatrix(), this.groundColor = new yn(t)
            }

            function Mc(e) {
                this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new jt(512, 512), this.map = null, this.matrix = new Nt
            }

            function Ac() {
                Mc.call(this, new ta(50, 1, .5, 500))
            }

            function Cc(e, t, n, r, i, o) {
                Tc.call(this, e, t), this.type = "SpotLight", this.position.copy(qn.DefaultUp), this.updateMatrix(), this.target = new qn, Object.defineProperty(this, "power", {
                    get: function () {
                        return this.intensity * Math.PI
                    },
                    set: function (e) {
                        this.intensity = e / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Ac
            }

            function Lc(e, t, n, r) {
                Tc.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function () {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function (e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Mc(new ta(90, 1, .5, 500))
            }

            function Rc() {
                Mc.call(this, new Xn(-5, 5, 5, -5, .5, 500))
            }

            function Pc(e, t) {
                Tc.call(this, e, t), this.type = "DirectionalLight", this.position.copy(qn.DefaultUp), this.updateMatrix(), this.target = new qn, this.shadow = new Rc
            }

            function Oc(e, t) {
                Tc.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
            }

            function Ic(e, t, n, r) {
                Tc.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
            }

            function Dc(e, t, n, r) {
                qc.call(this, e, t, n, r)
            }

            function jc(e, t, n) {
                qc.call(this, e, t, n)
            }

            function Nc(e, t, n, r) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n
            }

            function kc(e, t, n, r) {
                Nc.call(this, e, t, n, r)
            }

            function Uc(e, t, n, r) {
                qc.call(this, e, t, n, r)
            }

            function Hc(e, t, n, r) {
                qc.call(this, e, t, n, r)
            }

            function Bc(e, t, n, r) {
                qc.call(this, e, t, n, r)
            }

            function Fc(e, t, n, r) {
                Nc.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function zc(e, t, n, r) {
                Nc.call(this, e, t, n, r)
            }

            function Gc(e, t, n, r) {
                Nc.call(this, e, t, n, r)
            }
            bc.prototype = Object.assign(Object.create(tc.prototype), {
                constructor: bc,
                add: function (e) {
                    this.curves.push(e)
                },
                closePath: function () {
                    var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new mc(t, e))
                },
                getPoint: function (e) {
                    for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                        if (n[r] >= t) {
                            var i = n[r] - t,
                                o = this.curves[r],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - i / a;
                            return o.getPointAt(s)
                        }
                        r++
                    }
                    return null
                },
                getLength: function () {
                    var e = this.getCurveLengths();
                    return e[e.length - 1]
                },
                updateArcLengths: function () {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function () {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
                    return this.cacheLengths = e
                },
                getSpacedPoints: function (e) {
                    void 0 === e && (e = 40);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                },
                getPoints: function (e) {
                    e = e || 12;
                    for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
                        for (var o = i[r], a = o && o.isEllipseCurve ? 2 * e : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), c = 0; c < s.length; c++) {
                            var l = s[c];
                            t && t.equals(l) || (n.push(l), t = l)
                        }
                    return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function (e) {
                    tc.prototype.copy.call(this, e), this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var r = e.curves[t];
                        this.curves.push(r.clone())
                    }
                    return this.autoClose = e.autoClose, this
                },
                toJSON: function () {
                    var e = tc.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = [];
                    for (var t = 0, n = this.curves.length; t < n; t++) {
                        var r = this.curves[t];
                        e.curves.push(r.toJSON())
                    }
                    return e
                },
                fromJSON: function (e) {
                    tc.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var r = e.curves[t];
                        this.curves.push((new xc[r.type]).fromJSON(r))
                    }
                    return this
                }
            }), wc.prototype = Object.assign(Object.create(bc.prototype), {
                constructor: wc,
                setFromPoints: function (e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
                },
                moveTo: function (e, t) {
                    this.currentPoint.set(e, t)
                },
                lineTo: function (e, t) {
                    var n = new mc(this.currentPoint.clone(), new jt(e, t));
                    this.curves.push(n), this.currentPoint.set(e, t)
                },
                quadraticCurveTo: function (e, t, n, r) {
                    var i = new vc(this.currentPoint.clone(), new jt(e, t), new jt(n, r));
                    this.curves.push(i), this.currentPoint.set(n, r)
                },
                bezierCurveTo: function (e, t, n, r, i, o) {
                    var a = new pc(this.currentPoint.clone(), new jt(e, t), new jt(n, r), new jt(i, o));
                    this.curves.push(a), this.currentPoint.set(i, o)
                },
                splineThru: function (e) {
                    var t = new _c([this.currentPoint.clone()].concat(e));
                    this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
                },
                arc: function (e, t, n, r, i, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(e + a, t + s, n, r, i, o)
                },
                absarc: function (e, t, n, r, i, o) {
                    this.absellipse(e, t, n, n, r, i, o)
                },
                ellipse: function (e, t, n, r, i, o, a, s) {
                    var c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    this.absellipse(e + c, t + l, n, r, i, o, a, s)
                },
                absellipse: function (e, t, n, r, i, o, a, s) {
                    var c = new nc(e, t, n, r, i, o, a, s);
                    if (0 < this.curves.length) {
                        var l = c.getPoint(0);
                        l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                    }
                    this.curves.push(c);
                    var u = c.getPoint(1);
                    this.currentPoint.copy(u)
                },
                copy: function (e) {
                    return bc.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
                },
                toJSON: function () {
                    var e = bc.prototype.toJSON.call(this);
                    return e.currentPoint = this.currentPoint.toArray(), e
                },
                fromJSON: function (e) {
                    return bc.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }), Ec.prototype = Object.assign(Object.create(wc.prototype), {
                constructor: Ec,
                getPointsHoles: function (e) {
                    for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                },
                extractPoints: function (e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                },
                copy: function (e) {
                    wc.prototype.copy.call(this, e), this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var r = e.holes[t];
                        this.holes.push(r.clone())
                    }
                    return this
                },
                toJSON: function () {
                    var e = wc.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = [];
                    for (var t = 0, n = this.holes.length; t < n; t++) {
                        var r = this.holes[t];
                        e.holes.push(r.toJSON())
                    }
                    return e
                },
                fromJSON: function (e) {
                    wc.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var r = e.holes[t];
                        this.holes.push((new wc).fromJSON(r))
                    }
                    return this
                }
            }), Tc.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: Tc,
                isLight: !0,
                copy: function (e) {
                    return qn.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
                },
                toJSON: function (e) {
                    var t = qn.prototype.toJSON.call(this, e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }), Sc.prototype = Object.assign(Object.create(Tc.prototype), {
                constructor: Sc,
                isHemisphereLight: !0,
                copy: function (e) {
                    return Tc.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                }
            }), Object.assign(Mc.prototype, {
                copy: function (e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                toJSON: function () {
                    var e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }), Ac.prototype = Object.assign(Object.create(Mc.prototype), {
                constructor: Ac,
                isSpotLightShadow: !0,
                update: function (e) {
                    var t = this.camera,
                        n = 2 * Dt.RAD2DEG * e.angle,
                        r = this.mapSize.width / this.mapSize.height,
                        i = e.distance || t.far;
                    n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix())
                }
            }), Cc.prototype = Object.assign(Object.create(Tc.prototype), {
                constructor: Cc,
                isSpotLight: !0,
                copy: function (e) {
                    return Tc.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), Lc.prototype = Object.assign(Object.create(Tc.prototype), {
                constructor: Lc,
                isPointLight: !0,
                copy: function (e) {
                    return Tc.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }), Rc.prototype = Object.assign(Object.create(Mc.prototype), {
                constructor: Rc
            }), Pc.prototype = Object.assign(Object.create(Tc.prototype), {
                constructor: Pc,
                isDirectionalLight: !0,
                copy: function (e) {
                    return Tc.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), Oc.prototype = Object.assign(Object.create(Tc.prototype), {
                constructor: Oc,
                isAmbientLight: !0
            }), Ic.prototype = Object.assign(Object.create(Tc.prototype), {
                constructor: Ic,
                isRectAreaLight: !0,
                copy: function (e) {
                    return Tc.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
                },
                toJSON: function (e) {
                    var t = Tc.prototype.toJSON.call(this, e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }), Dc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Dc,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), jc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: jc,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Object.assign(Nc.prototype, {
                evaluate: function (e) {
                    var t = this.parameterPositions,
                        n = this._cachedIndex,
                        r = t[n],
                        i = t[n - 1];
                    e: {
                        t: {
                            var o; n: {
                                r: if (!(e < r)) {
                                    for (var a = n + 2; ;) {
                                        if (void 0 === r) {
                                            if (e < i) break r;
                                            return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i)
                                        }
                                        if (n === a) break;
                                        if (i = r, e < (r = t[++n])) break t
                                    }
                                    o = t.length;
                                    break n
                                } if (i <= e) break e;
                                var s = t[1]; e < s && (n = 2, i = s);
                                for (a = n - 2; ;) {
                                    if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                                    if (n === a) break;
                                    if (r = i, (i = t[--n - 1]) <= e) break t
                                }
                                o = n,
                                    n = 0
                            }
                            for (; n < o;) {
                                var c = n + o >>> 1;
                                e < t[c] ? o = c : n = c + 1
                            }
                            if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                            if (void 0 === r) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, e)
                        }
                        this._cachedIndex = n,
                            this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, e, r)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function () {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function (e) {
                    for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, o = 0; o !== r; ++o) t[o] = n[i + o];
                    return t
                },
                interpolate_: function () {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function () { }
            }), Object.assign(Nc.prototype, {
                beforeStart_: Nc.prototype.copySampleValue_,
                afterEnd_: Nc.prototype.copySampleValue_
            }), kc.prototype = Object.assign(Object.create(Nc.prototype), {
                constructor: kc,
                interpolate_: function (e, t, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = (n - t) / (r - t), l = s + a; s !== l; s += 4) kt.slerpFlat(i, 0, o, s - a, o, s, c);
                    return i
                }
            }), Uc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Uc,
                ValueTypeName: "quaternion",
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodLinear: function (e) {
                    return new kc(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), Hc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Hc,
                ValueTypeName: "color"
            }), Bc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Bc,
                ValueTypeName: "number"
            }), Fc.prototype = Object.assign(Object.create(Nc.prototype), {
                constructor: Fc,
                DefaultSettings_: {
                    endingStart: 2400,
                    endingEnd: 2400
                },
                intervalChanged_: function (e, t, n) {
                    var r = this.parameterPositions,
                        i = e - 2,
                        o = e + 1,
                        a = r[i],
                        s = r[o];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case 2401:
                            i = e, a = 2 * t - n;
                            break;
                        case 2402:
                            a = t + r[i = r.length - 2] - r[i + 1];
                            break;
                        default:
                            i = e, a = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            o = e, s = 2 * n - t;
                            break;
                        case 2402:
                            s = n + r[o = 1] - r[0];
                            break;
                        default:
                            o = e - 1, s = t
                    }
                    var c = .5 * (n - t),
                        l = this.valueSize;
                    this._weightPrev = c / (t - a), this._weightNext = c / (s - n), this._offsetPrev = i * l, this._offsetNext = o * l
                },
                interpolate_: function (e, t, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (r - t), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== a; ++x) i[x] = g * o[l + x] + v * o[c + x] + y * o[s + x] + _ * o[u + x];
                    return i
                }
            }), zc.prototype = Object.assign(Object.create(Nc.prototype), {
                constructor: zc,
                interpolate_: function (e, t, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = (n - t) / (r - t), u = 1 - l, h = 0; h !== a; ++h) i[h] = o[c + h] * u + o[s + h] * l;
                    return i
                }
            }), Gc.prototype = Object.assign(Object.create(Nc.prototype), {
                constructor: Gc,
                interpolate_: function (e) {
                    return this.copySampleValue_(e - 1)
                }
            });
            var Vc = {
                arraySlice: function (e, t, n) {
                    return Vc.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                },
                convertArray: function (e, t, n) {
                    return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                },
                isTypedArray: function (e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                },
                getKeyframeOrder: function (n) {
                    for (var e = n.length, t = new Array(e), r = 0; r !== e; ++r) t[r] = r;
                    return t.sort(function (e, t) {
                        return n[e] - n[t]
                    }), t
                },
                sortedArray: function (e, t, n) {
                    for (var r = e.length, i = new e.constructor(r), o = 0, a = 0; a !== r; ++o)
                        for (var s = n[o] * t, c = 0; c !== t; ++c) i[a++] = e[s + c];
                    return i
                },
                flattenJSON: function (e, t, n, r) {
                    for (var i = 1, o = e[0]; void 0 !== o && void 0 === o[r];) o = e[i++];
                    if (void 0 !== o) {
                        var a = o[r];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                for (; void 0 !== (a = o[r]) && (t.push(o.time), n.push.apply(n, a)), void 0 !== (o = e[i++]););
                            else if (void 0 !== a.toArray)
                                for (; void 0 !== (a = o[r]) && (t.push(o.time), a.toArray(n, n.length)), void 0 !== (o = e[i++]););
                            else
                                for (; void 0 !== (a = o[r]) && (t.push(o.time), n.push(a)), void 0 !== (o = e[i++]););
                    }
                }
            };

            function qc(e, t, n, r) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Vc.convertArray(t, this.TimeBufferType), this.values = Vc.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation), this.validate(), this.optimize()
            }

            function Wc(e, t, n, r) {
                qc.call(this, e, t, n, r)
            }

            function Xc(e, t, n) {
                this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = Dt.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
            }

            function Yc(e) {
                this.manager = void 0 !== e ? e : Xs, this.textures = {}
            }

            function Jc(e) {
                this.manager = void 0 !== e ? e : Xs
            }
            Object.assign(qc, {
                parse: function (e) {
                    if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    var t = qc._getTrackTypeForValueTypeName(e.type);
                    if (void 0 === e.times) {
                        var n = [],
                            r = [];
                        Vc.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
                    }
                    return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
                },
                toJSON: function (e) {
                    var t, n = e.constructor;
                    if (void 0 !== n.toJSON) t = n.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: Vc.convertArray(e.times, Array),
                            values: Vc.convertArray(e.values, Array)
                        };
                        var r = e.getInterpolation();
                        r !== e.DefaultInterpolation && (t.interpolation = r)
                    }
                    return t.type = e.ValueTypeName, t
                },
                _getTrackTypeForValueTypeName: function (e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Bc;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Wc;
                        case "color":
                            return Hc;
                        case "quaternion":
                            return Uc;
                        case "bool":
                        case "boolean":
                            return jc;
                        case "string":
                            return Dc
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }
            }), Object.assign(qc.prototype, {
                constructor: qc,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodDiscrete: function (e) {
                    return new Gc(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodLinear: function (e) {
                    return new zc(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: function (e) {
                    return new Fc(this.times, this.values, this.getValueSize(), e)
                },
                setInterpolation: function (e) {
                    var t;
                    switch (e) {
                        case 2300:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case 2301:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 !== t) this.createInterpolant = t;
                    else {
                        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(n);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        console.warn("THREE.KeyframeTrack:", n)
                    }
                },
                getInterpolation: function () {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return 2300;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                },
                getValueSize: function () {
                    return this.values.length / this.times.length
                },
                shift: function (e) {
                    if (0 !== e)
                        for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
                    return this
                },
                scale: function (e) {
                    if (1 !== e)
                        for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
                    return this
                },
                trim: function (e, t) {
                    for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < e;)++i;
                    for (; - 1 !== o && n[o] > t;)--o;
                    if (++o, 0 !== i || o !== r) {
                        o <= i && (i = (o = Math.max(o, 1)) - 1);
                        var a = this.getValueSize();
                        this.times = Vc.arraySlice(n, i, o), this.values = Vc.arraySlice(this.values, i * a, o * a)
                    }
                    return this
                },
                validate: function () {
                    var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    var n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    for (var o = null, a = 0; a !== i; a++) {
                        var s = n[a];
                        if ("number" == typeof s && isNaN(s)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), e = !1;
                            break
                        }
                        if (null !== o && s < o) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), e = !1;
                            break
                        }
                        o = s
                    }
                    if (void 0 !== r && Vc.isTypedArray(r)) {
                        a = 0;
                        for (var c = r.length; a !== c; ++a) {
                            var l = r[a];
                            if (isNaN(l)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), e = !1;
                                break
                            }
                        }
                    }
                    return e
                },
                optimize: function () {
                    for (var e = this.times, t = this.values, n = this.getValueSize(), r = 2302 === this.getInterpolation(), i = 1, o = e.length - 1, a = 1; a < o; ++a) {
                        var s = !1,
                            c = e[a];
                        if (c !== e[a + 1] && (1 !== a || c !== c[0]))
                            if (r) s = !0;
                            else
                                for (var l = a * n, u = l - n, h = l + n, d = 0; d !== n; ++d) {
                                    var p = t[l + d];
                                    if (p !== t[u + d] || p !== t[h + d]) {
                                        s = !0;
                                        break
                                    }
                                }
                        if (s) {
                            if (a !== i) {
                                e[i] = e[a];
                                var f = a * n,
                                    m = i * n;
                                for (d = 0; d !== n; ++d) t[m + d] = t[f + d]
                            } ++i
                        }
                    }
                    if (0 < o) {
                        e[i] = e[o];
                        for (f = o * n, m = i * n, d = 0; d !== n; ++d) t[m + d] = t[f + d];
                        ++i
                    }
                    return i !== e.length && (this.times = Vc.arraySlice(e, 0, i), this.values = Vc.arraySlice(t, 0, i * n)), this
                }
            }), Wc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Wc,
                ValueTypeName: "vector"
            }), Object.assign(Xc, {
                parse: function (e) {
                    for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, o = n.length; i !== o; ++i) t.push(qc.parse(n[i]).scale(r));
                    return new Xc(e.name, e.duration, t)
                },
                toJSON: function (e) {
                    for (var t = [], n = e.tracks, r = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t
                    }, i = 0, o = n.length; i !== o; ++i) t.push(qc.toJSON(n[i]));
                    return r
                },
                CreateFromMorphTargetSequence: function (e, t, n, r) {
                    for (var i = t.length, o = [], a = 0; a < i; a++) {
                        var s = [],
                            c = [];
                        s.push((a + i - 1) % i, a, (a + 1) % i), c.push(0, 1, 0);
                        var l = Vc.getKeyframeOrder(s);
                        s = Vc.sortedArray(s, 1, l), c = Vc.sortedArray(c, 1, l), r || 0 !== s[0] || (s.push(i), c.push(c[0])), o.push(new Bc(".morphTargetInfluences[" + t[a].name + "]", s, c).scale(1 / n))
                    }
                    return new Xc(e, -1, o)
                },
                findByName: function (e, t) {
                    var n = e;
                    if (!Array.isArray(e)) {
                        var r = e;
                        n = r.geometry && r.geometry.animations || r.animations
                    }
                    for (var i = 0; i < n.length; i++)
                        if (n[i].name === t) return n[i];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function (e, t, n) {
                    for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                        var s = e[o],
                            c = s.name.match(i);
                        if (c && 1 < c.length) {
                            var l = r[h = c[1]];
                            l || (r[h] = l = []), l.push(s)
                        }
                    }
                    var u = [];
                    for (var h in r) u.push(Xc.CreateFromMorphTargetSequence(h, r[h], t, n));
                    return u
                },
                parseAnimation: function (e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (var n = function (e, t, n, r, i) {
                        if (0 !== n.length) {
                            var o = [],
                                a = [];
                            Vc.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new e(t, o, a))
                        }
                    }, r = [], i = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], c = 0; c < s.length; c++) {
                        var l = s[c].keys;
                        if (l && 0 !== l.length)
                            if (l[0].morphTargets) {
                                for (var u = {}, h = 0; h < l.length; h++)
                                    if (l[h].morphTargets)
                                        for (var d = 0; d < l[h].morphTargets.length; d++) u[l[h].morphTargets[d]] = -1;
                                for (var p in u) {
                                    var f = [],
                                        m = [];
                                    for (d = 0; d !== l[h].morphTargets.length; ++d) {
                                        var g = l[h];
                                        f.push(g.time), m.push(g.morphTarget === p ? 1 : 0)
                                    }
                                    r.push(new Bc(".morphTargetInfluence[" + p + "]", f, m))
                                }
                                o = u.length * (a || 1)
                            } else {
                                var v = ".bones[" + t[c].name + "]";
                                n(Wc, v + ".position", l, "pos", r), n(Uc, v + ".quaternion", l, "rot", r), n(Wc, v + ".scale", l, "scl", r)
                            }
                    }
                    return 0 === r.length ? null : new Xc(i, o, r)
                }
            }), Object.assign(Xc.prototype, {
                resetDuration: function () {
                    for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                        var r = this.tracks[t];
                        e = Math.max(e, r.times[r.times.length - 1])
                    }
                    this.duration = e
                },
                trim: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                },
                optimize: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
            }), Object.assign(Yc.prototype, {
                load: function (e, t, n, r) {
                    var i = this;
                    new Js(i.manager).load(e, function (e) {
                        t(i.parse(JSON.parse(e)))
                    }, n, r)
                },
                setTextures: function (e) {
                    this.textures = e
                },
                parse: function (e) {
                    var t = this.textures;

                    function n(e) {
                        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                    }
                    var r = new Vs[e.type];
                    if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearCoat && (r.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (r.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.uniforms && (r.uniforms = e.uniforms), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalScale) {
                        var i = e.normalScale;
                        !1 === Array.isArray(i) && (i = [i, i]), r.normalScale = (new jt).fromArray(i)
                    }
                    return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), r
                }
            }), Object.assign(Jc.prototype, {
                load: function (e, t, n, r) {
                    var i = this;
                    new Js(i.manager).load(e, function (e) {
                        t(i.parse(JSON.parse(e)))
                    }, n, r)
                },
                parse: function (e) {
                    var t = new Ar,
                        n = e.data.index;
                    if (void 0 !== n) {
                        var r = new el[n.type](n.array);
                        t.setIndex(new ir(r, 1))
                    }
                    var i = e.data.attributes;
                    for (var o in i) {
                        var a = i[o];
                        r = new el[a.type](a.array);
                        t.addAttribute(o, new ir(r, a.itemSize, a.normalized))
                    }
                    var s = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== s)
                        for (var c = 0, l = s.length; c !== l; ++c) {
                            var u = s[c];
                            t.addGroup(u.start, u.count, u.materialIndex)
                        }
                    var h = e.data.boundingSphere;
                    if (void 0 !== h) {
                        var d = new Ut;
                        void 0 !== h.center && d.fromArray(h.center), t.boundingSphere = new hn(d, h.radius)
                    }
                    return t
                }
            });
            var Zc, $c, Qc, Kc, el = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function tl() { }
            tl.Handlers = {
                handlers: [],
                add: function (e, t) {
                    this.handlers.push(e, t)
                },
                get: function (e) {
                    for (var t = this.handlers, n = 0, r = t.length; n < r; n += 2) {
                        var i = t[n],
                            o = t[n + 1];
                        if (i.test(e)) return o
                    }
                    return null
                }
            }, Object.assign(tl.prototype, {
                crossOrigin: void 0,
                onLoadStart: function () { },
                onLoadProgress: function () { },
                onLoadComplete: function () { },
                initMaterials: function (e, t, n) {
                    for (var r = [], i = 0; i < e.length; ++i) r[i] = this.createMaterial(e[i], t, n);
                    return r
                },
                createMaterial: (Zc = {
                    NoBlending: W,
                    NormalBlending: X,
                    AdditiveBlending: Y,
                    SubtractiveBlending: $,
                    MultiplyBlending: Q,
                    CustomBlending: K
                }, $c = new yn, Qc = new ec, Kc = new Yc, function (e, l, u) {
                    var h = {};

                    function t(e, t, n, r, i) {
                        var o, a = l + e,
                            s = tl.Handlers.get(a);
                        null !== s ? o = s.load(a) : (Qc.setCrossOrigin(u), o = Qc.load(a)), void 0 !== t && (o.repeat.fromArray(t), 1 !== t[0] && (o.wrapS = Te), 1 !== t[1] && (o.wrapT = Te)), void 0 !== n && o.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (o.wrapS = Te), "mirror" === r[0] && (o.wrapS = Ce), "repeat" === r[1] && (o.wrapT = Te), "mirror" === r[1] && (o.wrapT = Ce)), void 0 !== i && (o.anisotropy = i);
                        var c = Dt.generateUUID();
                        return h[c] = o, c
                    }
                    var n = {
                        uuid: Dt.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                    for (var r in e) {
                        var i = e[r];
                        switch (r) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                n.name = i;
                                break;
                            case "blending":
                                n.blending = Zc[i];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", r, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                n.color = $c.fromArray(i).getHex();
                                break;
                            case "colorSpecular":
                                n.specular = $c.fromArray(i).getHex();
                                break;
                            case "colorEmissive":
                                n.emissive = $c.fromArray(i).getHex();
                                break;
                            case "specularCoef":
                                n.shininess = i;
                                break;
                            case "shading":
                                "basic" === i.toLowerCase() && (n.type = "MeshBasicMaterial"), "phong" === i.toLowerCase() && (n.type = "MeshPhongMaterial"), "standard" === i.toLowerCase() && (n.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                n.map = t(i, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                n.emissiveMap = t(i, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                n.lightMap = t(i, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                n.aoMap = t(i, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                n.bumpMap = t(i, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                n.bumpScale = i;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                n.normalMap = t(i, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                n.normalScale = i;
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                n.specularMap = t(i, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                n.metalnessMap = t(i, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                n.roughnessMap = t(i, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                n.alphaMap = t(i, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                n.side = J;
                                break;
                            case "doubleSided":
                                n.side = Z;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), n.opacity = i;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                n[r] = i;
                                break;
                            case "vertexColors":
                                !0 === i && (n.vertexColors = S), "face" === i && (n.vertexColors = 1);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", r, i)
                        }
                    }
                    return "MeshBasicMaterial" === n.type && delete n.emissive, "MeshPhongMaterial" !== n.type && delete n.specular, n.opacity < 1 && (n.transparent = !0), Kc.setTextures(h), Kc.parse(n)
                })
            });
            var nl = {
                decodeText: function (e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                    return decodeURIComponent(escape(t))
                },
                extractUrlBase: function (e) {
                    var t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.substr(0, t + 1)
                }
            };

            function rl(e) {
                "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : Xs, this.withCredentials = !1
            }

            function il(e) {
                this.manager = void 0 !== e ? e : Xs, this.texturePath = ""
            }
            Object.assign(rl.prototype, {
                load: function (o, a, e, t) {
                    var s = this,
                        c = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : nl.extractUrlBase(o),
                        n = new Js(this.manager);
                    n.setWithCredentials(this.withCredentials), n.load(o, function (e) {
                        var t = JSON.parse(e),
                            n = t.metadata;
                        if (void 0 !== n) {
                            var r = n.type;
                            if (void 0 !== r && "object" === r.toLowerCase()) return void console.error("THREE.JSONLoader: " + o + " should be loaded with THREE.ObjectLoader instead.")
                        }
                        var i = s.parse(t, c);
                        a(i.geometry, i.materials)
                    }, e, t)
                },
                setTexturePath: function (e) {
                    this.texturePath = e
                },
                parse: function (e, t) {
                    void 0 !== e.data && (e = e.data), void 0 !== e.scale ? e.scale = 1 / e.scale : e.scale = 1;
                    var n = new rr;
                    return function (e, t) {
                        function n(e, t) {
                            return e & 1 << t
                        }
                        var r, i, o, a, s, c, l, u, h, d, p, f, m, g, v, y, _, x, b, w, E, T, S, M, A, C = e.faces,
                            L = e.vertices,
                            R = e.normals,
                            P = e.colors,
                            O = e.scale,
                            I = 0;
                        if (void 0 !== e.uvs) {
                            for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && I++;
                            for (r = 0; r < I; r++) t.faceVertexUvs[r] = []
                        }
                        for (a = 0, s = L.length; a < s;)(x = new Ut).x = L[a++] * O, x.y = L[a++] * O, x.z = L[a++] * O, t.vertices.push(x);
                        for (a = 0, s = C.length; a < s;)
                            if (p = n(d = C[a++], 0), f = n(d, 1), m = n(d, 3), g = n(d, 4), v = n(d, 5), y = n(d, 6), _ = n(d, 7), p) {
                                if ((w = new Yn).a = C[a], w.b = C[a + 1], w.c = C[a + 3], (E = new Yn).a = C[a + 1], E.b = C[a + 2], E.c = C[a + 3], a += 4, f && (h = C[a++], w.materialIndex = h, E.materialIndex = h), o = t.faces.length, m)
                                    for (r = 0; r < I; r++)
                                        for (M = e.uvs[r], t.faceVertexUvs[r][o] = [], t.faceVertexUvs[r][o + 1] = [], i = 0; i < 4; i++) A = new jt(M[2 * (u = C[a++])], M[2 * u + 1]), 2 !== i && t.faceVertexUvs[r][o].push(A), 0 !== i && t.faceVertexUvs[r][o + 1].push(A);
                                if (g && (l = 3 * C[a++], w.normal.set(R[l++], R[l++], R[l]), E.normal.copy(w.normal)), v)
                                    for (r = 0; r < 4; r++) l = 3 * C[a++], S = new Ut(R[l++], R[l++], R[l]), 2 !== r && w.vertexNormals.push(S), 0 !== r && E.vertexNormals.push(S);
                                if (y && (T = P[c = C[a++]], w.color.setHex(T), E.color.setHex(T)), _)
                                    for (r = 0; r < 4; r++) T = P[c = C[a++]], 2 !== r && w.vertexColors.push(new yn(T)), 0 !== r && E.vertexColors.push(new yn(T));
                                t.faces.push(w), t.faces.push(E)
                            } else {
                                if ((b = new Yn).a = C[a++], b.b = C[a++], b.c = C[a++], f && (h = C[a++], b.materialIndex = h), o = t.faces.length, m)
                                    for (r = 0; r < I; r++)
                                        for (M = e.uvs[r], t.faceVertexUvs[r][o] = [], i = 0; i < 3; i++) A = new jt(M[2 * (u = C[a++])], M[2 * u + 1]), t.faceVertexUvs[r][o].push(A);
                                if (g && (l = 3 * C[a++], b.normal.set(R[l++], R[l++], R[l])), v)
                                    for (r = 0; r < 3; r++) l = 3 * C[a++], S = new Ut(R[l++], R[l++], R[l]), b.vertexNormals.push(S);
                                if (y && (c = C[a++], b.color.setHex(P[c])), _)
                                    for (r = 0; r < 3; r++) c = C[a++], b.vertexColors.push(new yn(P[c]));
                                t.faces.push(b)
                            }
                    }(e, n),
                        function (e, t) {
                            var n = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                            if (e.skinWeights)
                                for (var r = 0, i = e.skinWeights.length; r < i; r += n) {
                                    var o = e.skinWeights[r],
                                        a = 1 < n ? e.skinWeights[r + 1] : 0,
                                        s = 2 < n ? e.skinWeights[r + 2] : 0,
                                        c = 3 < n ? e.skinWeights[r + 3] : 0;
                                    t.skinWeights.push(new an(o, a, s, c))
                                }
                            if (e.skinIndices)
                                for (r = 0, i = e.skinIndices.length; r < i; r += n) {
                                    var l = e.skinIndices[r],
                                        u = 1 < n ? e.skinIndices[r + 1] : 0,
                                        h = 2 < n ? e.skinIndices[r + 2] : 0,
                                        d = 3 < n ? e.skinIndices[r + 3] : 0;
                                    t.skinIndices.push(new an(l, u, h, d))
                                }
                            t.bones = e.bones, t.bones && 0 < t.bones.length && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match.")
                        }(e, n),
                        function (e, t) {
                            var n = e.scale;
                            if (void 0 !== e.morphTargets)
                                for (var r = 0, i = e.morphTargets.length; r < i; r++) {
                                    t.morphTargets[r] = {}, t.morphTargets[r].name = e.morphTargets[r].name, t.morphTargets[r].vertices = [];
                                    for (var o = t.morphTargets[r].vertices, a = e.morphTargets[r].vertices, s = 0, c = a.length; s < c; s += 3) {
                                        var l = new Ut;
                                        l.x = a[s] * n, l.y = a[s + 1] * n, l.z = a[s + 2] * n, o.push(l)
                                    }
                                }
                            if (void 0 !== e.morphColors && 0 < e.morphColors.length) {
                                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                                var u = t.faces,
                                    h = e.morphColors[0].colors;
                                for (r = 0, i = u.length; r < i; r++) u[r].color.fromArray(h, 3 * r)
                            }
                        }(e, n),
                        function (e, t) {
                            var n = [],
                                r = [];
                            void 0 !== e.animation && r.push(e.animation), void 0 !== e.animations && (e.animations.length ? r = r.concat(e.animations) : r.push(e.animations));
                            for (var i = 0; i < r.length; i++) {
                                var o = Xc.parseAnimation(r[i], t.bones);
                                o && n.push(o)
                            }
                            if (t.morphTargets) {
                                var a = Xc.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
                                n = n.concat(a)
                            }
                            0 < n.length && (t.animations = n)
                        }(e, n), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length ? {
                            geometry: n
                        } : {
                                geometry: n,
                                materials: tl.prototype.initMaterials(e.materials, t, this.crossOrigin)
                            }
                }
            }), Object.assign(il.prototype, {
                load: function (r, i, e, o) {
                    "" === this.texturePath && (this.texturePath = r.substring(0, r.lastIndexOf("/") + 1));
                    var a = this;
                    new Js(a.manager).load(r, function (e) {
                        var t = null;
                        try {
                            t = JSON.parse(e)
                        } catch (e) {
                            return void 0 !== o && o(e), void console.error("THREE:ObjectLoader: Can't parse " + r + ".", e.message)
                        }
                        var n = t.metadata;
                        void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? a.parse(t, i) : console.error("THREE.ObjectLoader: Can't load " + r + ". Use THREE.JSONLoader instead.")
                    }, e, o)
                },
                setTexturePath: function (e) {
                    this.texturePath = e
                },
                setCrossOrigin: function (e) {
                    this.crossOrigin = e
                },
                parse: function (e, t) {
                    var n = this.parseShape(e.shapes),
                        r = this.parseGeometries(e.geometries, n),
                        i = this.parseImages(e.images, function () {
                            void 0 !== t && t(s)
                        }),
                        o = this.parseTextures(e.textures, i),
                        a = this.parseMaterials(e.materials, o),
                        s = this.parseObject(e.object, r, a);
                    return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
                },
                parseShape: function (e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = 0, r = e.length; n < r; n++) {
                            var i = (new Ec).fromJSON(e[n]);
                            t[i.uuid] = i
                        }
                    return t
                },
                parseGeometries: function (e, t) {
                    var n = {};
                    if (void 0 !== e)
                        for (var r = new rl, i = new Jc, o = 0, a = e.length; o < a; o++) {
                            var s, c = e[o];
                            switch (c.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new Ds[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new Ds[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new Ds[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new Ds[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new Ds[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new Ds[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new Ds[c.type](c.radius, c.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new Ds[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new Ds[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new Ds[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new Ds[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new Ds[c.type](c.vertices, c.indices, c.radius, c.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var l = [], u = 0, h = c.shapes.length; u < h; u++) {
                                        var d = t[c.shapes[u]];
                                        l.push(d)
                                    }
                                    s = new Ds[c.type](l, c.curveSegments);
                                    break;
                                case "BufferGeometry":
                                    s = i.parse(c);
                                    break;
                                case "Geometry":
                                    s = r.parse(c, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                                    continue
                            }
                            s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), n[c.uuid] = s
                        }
                    return n
                },
                parseMaterials: function (e, t) {
                    var n = {};
                    if (void 0 !== e) {
                        var r = new Yc;
                        r.setTextures(t);
                        for (var i = 0, o = e.length; i < o; i++) {
                            var a = e[i];
                            if ("MultiMaterial" === a.type) {
                                for (var s = [], c = 0; c < a.materials.length; c++) s.push(r.parse(a.materials[c]));
                                n[a.uuid] = s
                            } else n[a.uuid] = r.parse(a)
                        }
                    }
                    return n
                },
                parseAnimations: function (e) {
                    for (var t = [], n = 0; n < e.length; n++) {
                        var r = Xc.parse(e[n]);
                        t.push(r)
                    }
                    return t
                },
                parseImages: function (e, t) {
                    var n = this,
                        r = {};

                    function i(e) {
                        return n.manager.itemStart(e), o.load(e, function () {
                            n.manager.itemEnd(e)
                        }, void 0, function () {
                            n.manager.itemEnd(e), n.manager.itemError(e)
                        })
                    }
                    if (void 0 !== e && 0 < e.length) {
                        var o = new Qs(new Ws(t));
                        o.setCrossOrigin(this.crossOrigin);
                        for (var a = 0, s = e.length; a < s; a++) {
                            var c = e[a],
                                l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.texturePath + c.url;
                            r[c.uuid] = i(l)
                        }
                    }
                    return r
                },
                parseTextures: function (e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    var r = {};
                    if (void 0 !== e)
                        for (var i = 0, o = e.length; i < o; i++) {
                            var a = e[i];
                            void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                            var s = new on(t[a.image]);
                            s.needsUpdate = !0, s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.mapping && (s.mapping = n(a.mapping, al)), void 0 !== a.offset && s.offset.fromArray(a.offset), void 0 !== a.repeat && s.repeat.fromArray(a.repeat), void 0 !== a.center && s.center.fromArray(a.center), void 0 !== a.rotation && (s.rotation = a.rotation), void 0 !== a.wrap && (s.wrapS = n(a.wrap[0], sl), s.wrapT = n(a.wrap[1], sl)), void 0 !== a.format && (s.format = a.format), void 0 !== a.minFilter && (s.minFilter = n(a.minFilter, cl)), void 0 !== a.magFilter && (s.magFilter = n(a.magFilter, cl)), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), void 0 !== a.flipY && (s.flipY = a.flipY), r[a.uuid] = s
                        }
                    return r
                },
                parseObject: function (e, t, o) {
                    var n;

                    function r(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function i(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                for (var t = [], n = 0, r = e.length; n < r; n++) {
                                    var i = e[n];
                                    void 0 === o[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(o[i])
                                }
                                return t
                            }
                            return void 0 === o[e] && console.warn("THREE.ObjectLoader: Undefined material", e), o[e]
                        }
                    }
                    switch (e.type) {
                        case "Scene":
                            n = new sa, void 0 !== e.background && Number.isInteger(e.background) && (n.background = new yn(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new aa(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new oa(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            n = new ta(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (n.focus = e.focus), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset), void 0 !== e.view && (n.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            n = new Xn(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.view && (n.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            n = new Oc(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            n = new Pc(e.color, e.intensity);
                            break;
                        case "PointLight":
                            n = new Lc(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            n = new Ic(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            n = new Cc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            n = new Sc(e.color, e.groundColor, e.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = r(e.geometry),
                                s = i(e.material);
                            n = a.bones && 0 < a.bones.length ? new pa(a, s) : new li(a, s);
                            break;
                        case "LOD":
                            n = new ua;
                            break;
                        case "Line":
                            n = new ma(r(e.geometry), i(e.material), e.mode);
                            break;
                        case "LineLoop":
                            n = new va(r(e.geometry), i(e.material));
                            break;
                        case "LineSegments":
                            n = new ga(r(e.geometry), i(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            n = new _a(r(e.geometry), i(e.material));
                            break;
                        case "Sprite":
                            n = new la(i(e.material));
                            break;
                        case "Group":
                            n = new xa;
                            break;
                        default:
                            n = new qn
                    }
                    if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.castShadow && (n.castShadow = e.castShadow), void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.children)
                        for (var c = e.children, l = 0; l < c.length; l++) n.add(this.parseObject(c[l], t, o));
                    if ("LOD" === e.type)
                        for (var u = e.levels, h = 0; h < u.length; h++) {
                            var d = u[h],
                                p = n.getObjectByProperty("uuid", d.object);
                            void 0 !== p && n.addLevel(p, d.distance)
                        }
                    return n
                }
            });
            var ol, al = {
                UVMapping: 300,
                CubeReflectionMapping: ve,
                CubeRefractionMapping: ye,
                EquirectangularReflectionMapping: _e,
                EquirectangularRefractionMapping: xe,
                SphericalReflectionMapping: be,
                CubeUVReflectionMapping: we,
                CubeUVRefractionMapping: Ee
            },
                sl = {
                    RepeatWrapping: Te,
                    ClampToEdgeWrapping: Ae,
                    MirroredRepeatWrapping: Ce
                },
                cl = {
                    NearestFilter: Le,
                    NearestMipMapNearestFilter: Re,
                    NearestMipMapLinearFilter: Pe,
                    LinearFilter: Oe,
                    LinearMipMapNearestFilter: Ie,
                    LinearMipMapLinearFilter: De
                };

            function ll(e) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : Xs, this.options = void 0
            }

            function ul() {
                this.type = "ShapePath", this.color = new yn, this.subPaths = [], this.currentPath = null
            }

            function hl(e) {
                this.type = "Font", this.data = e
            }

            function dl(e, t, n, r, i, o) {
                var a = o.glyphs[e] || o.glyphs["?"];
                if (a) {
                    var s, c, l, u, h, d, p, f, m = new ul;
                    if (a.o)
                        for (var g = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, y = g.length; v < y;) {
                            switch (g[v++]) {
                                case "m":
                                    s = g[v++] * n + r, c = g[v++] * n + i, m.moveTo(s, c);
                                    break;
                                case "l":
                                    s = g[v++] * n + r, c = g[v++] * n + i, m.lineTo(s, c);
                                    break;
                                case "q":
                                    l = g[v++] * n + r, u = g[v++] * n + i, h = g[v++] * n + r, d = g[v++] * n + i, m.quadraticCurveTo(h, d, l, u);
                                    break;
                                case "b":
                                    l = g[v++] * n + r, u = g[v++] * n + i, h = g[v++] * n + r, d = g[v++] * n + i, p = g[v++] * n + r, f = g[v++] * n + i, m.bezierCurveTo(h, d, p, f, l, u)
                            }
                        }
                    return {
                        offsetX: a.ha * n,
                        path: m
                    }
                }
            }

            function pl(e) {
                this.manager = void 0 !== e ? e : Xs
            }
            ll.prototype = {
                constructor: ll,
                setOptions: function (e) {
                    return this.options = e, this
                },
                load: function (t, n, e, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
                    var i = this,
                        o = qs.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function () {
                        n && n(o), i.manager.itemEnd(t)
                    }, 0), o;
                    fetch(t).then(function (e) {
                        return e.blob()
                    }).then(function (e) {
                        return createImageBitmap(e, i.options)
                    }).then(function (e) {
                        qs.add(t, e), n && n(e), i.manager.itemEnd(t)
                    }).catch(function (e) {
                        r && r(e), i.manager.itemEnd(t), i.manager.itemError(t)
                    })
                },
                setCrossOrigin: function () {
                    return this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }, Object.assign(ul.prototype, {
                moveTo: function (e, t) {
                    this.currentPath = new wc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
                },
                lineTo: function (e, t) {
                    this.currentPath.lineTo(e, t)
                },
                quadraticCurveTo: function (e, t, n, r) {
                    this.currentPath.quadraticCurveTo(e, t, n, r)
                },
                bezierCurveTo: function (e, t, n, r, i, o) {
                    this.currentPath.bezierCurveTo(e, t, n, r, i, o)
                },
                splineThru: function (e) {
                    this.currentPath.splineThru(e)
                },
                toShapes: function (e, t) {
                    function n(e) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var i = e[n],
                                o = new Ec;
                            o.curves = i.curves, t.push(o)
                        }
                        return t
                    }

                    function r(e, t) {
                        for (var n = t.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                            var a = t[i],
                                s = t[o],
                                c = s.x - a.x,
                                l = s.y - a.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (a = t[o], c = -c, s = t[i], l = -l), e.y < a.y || e.y > s.y) continue;
                                if (e.y === a.y) {
                                    if (e.x === a.x) return !0
                                } else {
                                    var u = l * (e.x - a.x) - c * (e.y - a.y);
                                    if (0 === u) return !0;
                                    if (u < 0) continue;
                                    r = !r
                                }
                            } else {
                                if (e.y !== a.y) continue;
                                if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0
                            }
                        }
                        return r
                    }
                    var i = us.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === t) return n(o);
                    var a, s, c, l = [];
                    if (1 === o.length) return s = o[0], (c = new Ec).curves = s.curves, l.push(c), l;
                    var u = !i(o[0].getPoints());
                    u = e ? !u : u;
                    var h, d, p = [],
                        f = [],
                        m = [],
                        g = 0;
                    f[g] = void 0, m[g] = [];
                    for (var v = 0, y = o.length; v < y; v++) a = i(h = (s = o[v]).getPoints()), (a = e ? !a : a) ? (!u && f[g] && g++ , f[g] = {
                        s: new Ec,
                        p: h
                    }, f[g].s.curves = s.curves, u && g++ , m[g] = []) : m[g].push({
                        h: s,
                        p: h[0]
                    });
                    if (!f[0]) return n(o);
                    if (1 < f.length) {
                        for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) p[b] = [];
                        for (b = 0, w = f.length; b < w; b++)
                            for (var E = m[b], T = 0; T < E.length; T++) {
                                for (var S = E[T], M = !0, A = 0; A < f.length; A++) r(S.p, f[A].p) && (b !== A && x.push({
                                    froms: b,
                                    tos: A,
                                    hole: T
                                }), M ? (M = !1, p[A].push(S)) : _ = !0);
                                M && p[b].push(S)
                            }
                        0 < x.length && (_ || (m = p))
                    }
                    v = 0;
                    for (var C = f.length; v < C; v++) {
                        c = f[v].s, l.push(c);
                        for (var L = 0, R = (d = m[v]).length; L < R; L++) c.holes.push(d[L].h)
                    }
                    return l
                }
            }), Object.assign(hl.prototype, {
                isFont: !0,
                generateShapes: function (e, t, n) {
                    void 0 === t && (t = 100), void 0 === n && (n = 4);
                    for (var r = [], i = function (e, t, n, r) {
                        for (var i = String(e).split(""), o = t / r.resolution, a = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * o, s = [], c = 0, l = 0, u = 0; u < i.length; u++) {
                            var h = i[u];
                            if ("\n" === h) c = 0, l -= a;
                            else {
                                var d = dl(h, n, o, c, l, r);
                                c += d.offsetX, s.push(d.path)
                            }
                        }
                        return s
                    }(e, t, n, this.data), o = 0, a = i.length; o < a; o++) Array.prototype.push.apply(r, i[o].toShapes());
                    return r
                }
            }), Object.assign(pl.prototype, {
                load: function (e, r, t, n) {
                    var i = this,
                        o = new Js(this.manager);
                    o.setPath(this.path), o.load(e, function (t) {
                        var n;
                        try {
                            n = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var e = i.parse(n);
                        r && r(e)
                    }, t, n)
                },
                parse: function (e) {
                    return new hl(e)
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            });
            var fl, ml, gl, vl, yl, _l, xl, bl, wl, El, Tl, Sl, Ml, Al, Cl, Ll = {
                getContext: function () {
                    return void 0 === ol && (ol = new (window.AudioContext || window.webkitAudioContext)), ol
                },
                setContext: function (e) {
                    ol = e
                }
            };

            function Rl(e) {
                this.manager = void 0 !== e ? e : Xs
            }

            function Pl() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ta, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ta, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function Ol(e, t, n) {
                qn.call(this), this.type = "CubeCamera";
                var i = new ta(90, 1, e, t);
                i.up.set(0, -1, 0), i.lookAt(new Ut(1, 0, 0)), this.add(i);
                var o = new ta(90, 1, e, t);
                o.up.set(0, -1, 0), o.lookAt(new Ut(-1, 0, 0)), this.add(o);
                var a = new ta(90, 1, e, t);
                a.up.set(0, 0, 1), a.lookAt(new Ut(0, 1, 0)), this.add(a);
                var s = new ta(90, 1, e, t);
                s.up.set(0, 0, -1), s.lookAt(new Ut(0, -1, 0)), this.add(s);
                var c = new ta(90, 1, e, t);
                c.up.set(0, -1, 0), c.lookAt(new Ut(0, 0, 1)), this.add(c);
                var l = new ta(90, 1, e, t);
                l.up.set(0, -1, 0), l.lookAt(new Ut(0, 0, -1)), this.add(l);
                var r = {
                    format: Ye,
                    magFilter: Oe,
                    minFilter: Oe
                };
                this.renderTarget = new cn(n, n, r), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = this.renderTarget,
                        r = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, i, n), n.activeCubeFace = 1, e.render(t, o, n), n.activeCubeFace = 2, e.render(t, a, n), n.activeCubeFace = 3, e.render(t, s, n), n.activeCubeFace = 4, e.render(t, c, n), n.texture.generateMipmaps = r, n.activeCubeFace = 5, e.render(t, l, n), e.setRenderTarget(null)
                }, this.clear = function (e, t, n, r) {
                    for (var i = this.renderTarget, o = 0; o < 6; o++) i.activeCubeFace = o, e.setRenderTarget(i), e.clear(t, n, r);
                    e.setRenderTarget(null)
                }
            }

            function Il() {
                qn.call(this), this.type = "AudioListener", this.context = Ll.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
            }

            function Dl(e) {
                qn.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function jl(e) {
                Dl.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function Nl(e, t) {
                this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }

            function kl(e, t, n) {
                this.binding = e, this.valueSize = n;
                var r, i = Float64Array;
                switch (t) {
                    case "quaternion":
                        r = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        i = Array, r = this._select;
                        break;
                    default:
                        r = this._lerp
                }
                this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(Rl.prototype, {
                load: function (e, t, n, r) {
                    var i = new Js(this.manager);
                    i.setResponseType("arraybuffer"), i.load(e, function (e) {
                        Ll.getContext().decodeAudioData(e, function (e) {
                            t(e)
                        })
                    }, n, r)
                }
            }), Object.assign(Pl.prototype, {
                update: (wl = new Nt, El = new Nt, function (e) {
                    if (fl !== this || ml !== e.focus || gl !== e.fov || vl !== e.aspect * this.aspect || yl !== e.near || _l !== e.far || xl !== e.zoom || bl !== this.eyeSep) {
                        fl = this, ml = e.focus, gl = e.fov, vl = e.aspect * this.aspect, yl = e.near, _l = e.far, xl = e.zoom;
                        var t, n, r = e.projectionMatrix.clone(),
                            i = (bl = this.eyeSep / 2) * yl / ml,
                            o = yl * Math.tan(Dt.DEG2RAD * gl * .5) / xl;
                        El.elements[12] = -bl, wl.elements[12] = bl, t = -o * vl + i, n = o * vl + i, r.elements[0] = 2 * yl / (n - t), r.elements[8] = (n + t) / (n - t), this.cameraL.projectionMatrix.copy(r), t = -o * vl - i, n = o * vl - i, r.elements[0] = 2 * yl / (n - t), r.elements[8] = (n + t) / (n - t), this.cameraR.projectionMatrix.copy(r)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(El), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(wl)
                })
            }), (Ol.prototype = Object.create(qn.prototype)).constructor = Ol, Il.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: Il,
                getInput: function () {
                    return this.gain
                },
                removeFilter: function () {
                    null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
                },
                getFilter: function () {
                    return this.filter
                },
                setFilter: function (e) {
                    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
                },
                getMasterVolume: function () {
                    return this.gain.gain.value
                },
                setMasterVolume: function (e) {
                    this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01)
                },
                updateMatrixWorld: (Tl = new Ut, Sl = new kt, Ml = new Ut, Al = new Ut, function (e) {
                    qn.prototype.updateMatrixWorld.call(this, e);
                    var t = this.context.listener,
                        n = this.up;
                    this.matrixWorld.decompose(Tl, Sl, Ml), Al.set(0, 0, -1).applyQuaternion(Sl), t.positionX ? (t.positionX.setValueAtTime(Tl.x, this.context.currentTime), t.positionY.setValueAtTime(Tl.y, this.context.currentTime), t.positionZ.setValueAtTime(Tl.z, this.context.currentTime), t.forwardX.setValueAtTime(Al.x, this.context.currentTime), t.forwardY.setValueAtTime(Al.y, this.context.currentTime), t.forwardZ.setValueAtTime(Al.z, this.context.currentTime), t.upX.setValueAtTime(n.x, this.context.currentTime), t.upY.setValueAtTime(n.y, this.context.currentTime), t.upZ.setValueAtTime(n.z, this.context.currentTime)) : (t.setPosition(Tl.x, Tl.y, Tl.z), t.setOrientation(Al.x, Al.y, Al.z, n.x, n.y, n.z))
                })
            }), Dl.prototype = Object.assign(Object.create(qn.prototype), {
                constructor: Dl,
                getOutput: function () {
                    return this.gain
                },
                setNodeSource: function (e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                },
                setBuffer: function (e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function () {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            var e = this.context.createBufferSource();
                            return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function () {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function () {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function () {
                    if (0 < this.filters.length) {
                        this.source.connect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function () {
                    if (0 < this.filters.length) {
                        this.source.disconnect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function () {
                    return this.filters
                },
                setFilters: function (e) {
                    return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
                },
                getFilter: function () {
                    return this.getFilters()[0]
                },
                setFilter: function (e) {
                    return this.setFilters(e ? [e] : [])
                },
                setPlaybackRate: function (e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function () {
                    return this.playbackRate
                },
                onEnded: function () {
                    this.isPlaying = !1
                },
                getLoop: function () {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function (e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function () {
                    return this.gain.gain.value
                },
                setVolume: function (e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }), jl.prototype = Object.assign(Object.create(Dl.prototype), {
                constructor: jl,
                getOutput: function () {
                    return this.panner
                },
                getRefDistance: function () {
                    return this.panner.refDistance
                },
                setRefDistance: function (e) {
                    this.panner.refDistance = e
                },
                getRolloffFactor: function () {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function (e) {
                    this.panner.rolloffFactor = e
                },
                getDistanceModel: function () {
                    return this.panner.distanceModel
                },
                setDistanceModel: function (e) {
                    this.panner.distanceModel = e
                },
                getMaxDistance: function () {
                    return this.panner.maxDistance
                },
                setMaxDistance: function (e) {
                    this.panner.maxDistance = e
                },
                updateMatrixWorld: (Cl = new Ut, function (e) {
                    qn.prototype.updateMatrixWorld.call(this, e), Cl.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(Cl.x, Cl.y, Cl.z)
                })
            }), Object.assign(Nl.prototype, {
                getFrequencyData: function () {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function () {
                    for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }), Object.assign(kl.prototype, {
                accumulate: function (e, t) {
                    var n = this.buffer,
                        r = this.valueSize,
                        i = e * r + r,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                        o = t
                    } else {
                        var s = t / (o += t);
                        this._mixBufferRegion(n, i, 0, s, r)
                    }
                    this.cumulativeWeight = o
                },
                apply: function (e) {
                    var t = this.valueSize,
                        n = this.buffer,
                        r = e * t + t,
                        i = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, i < 1) {
                        var a = 3 * t;
                        this._mixBufferRegion(n, r, a, 1 - i, t)
                    }
                    for (var s = t, c = t + t; s !== c; ++s)
                        if (n[s] !== n[s + t]) {
                            o.setValue(n, r);
                            break
                        }
                },
                saveOriginalState: function () {
                    var e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        r = 3 * n;
                    e.getValue(t, r);
                    for (var i = n, o = r; i !== o; ++i) t[i] = t[r + i % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function () {
                    var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                },
                _select: function (e, t, n, r, i) {
                    if (.5 <= r)
                        for (var o = 0; o !== i; ++o) e[t + o] = e[n + o]
                },
                _slerp: function (e, t, n, r) {
                    kt.slerpFlat(e, t, e, t, e, n, r)
                },
                _lerp: function (e, t, n, r, i) {
                    for (var o = 1 - r, a = 0; a !== i; ++a) {
                        var s = t + a;
                        e[s] = e[s] * o + e[n + a] * r
                    }
                }
            });
            var Ul, Hl, Bl, Fl, zl, Gl, Vl, ql, Wl, Xl, Yl, Jl, Zl, $l, Ql, Kl, eu, tu, nu, ru, iu, ou, au, su, cu, lu, uu, hu, du, pu, fu, mu, gu, vu, yu = "\\[\\]\\.:\\/";

            function _u(e, t, n) {
                var r = n || xu.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, r)
            }

            function xu(e, t, n) {
                this.path = t, this.parsedPath = n || xu.parseTrackName(t), this.node = xu.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
            }

            function bu() {
                this.uuid = Dt.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var e = {};
                this._indicesByUUID = e;
                for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var r = this;
                this.stats = {
                    objects: {
                        get total() {
                            return r._objects.length
                        },
                        get inUse() {
                            return this.total - r.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return r._bindings.length
                    }
                }
            }

            function wu(e, t, n) {
                this._mixer = e, this._clip = t, this._localRoot = n || null;
                for (var r = t.tracks, i = r.length, o = new Array(i), a = {
                    endingStart: 2400,
                    endingEnd: 2400
                }, s = 0; s !== i; ++s) {
                    var c = r[s].createInterpolant(null);
                    (o[s] = c).settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function Eu(e) {
                this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function Tu(e) {
                "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
            }

            function Su() {
                Ar.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function Mu(e, t, n, r) {
                this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
            }

            function Au(e, t) {
                this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function Cu(e, t, n) {
                Au.call(this, e, t), this.meshPerAttribute = n || 1
            }

            function Lu(e, t, n) {
                ir.call(this, e, t), this.meshPerAttribute = n || 1
            }

            function Ru(e, t, n, r) {
                this.ray = new ai(e, t), this.near = n || 0, this.far = r || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function () {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function Pu(e, t) {
                return e.distance - t.distance
            }

            function Ou(e, t, n, r) {
                if (!1 !== e.visible && (e.raycast(t, n), !0 === r))
                    for (var i = e.children, o = 0, a = i.length; o < a; o++) Ou(i[o], t, n, !0)
            }

            function Iu(e) {
                this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function Du(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
            }

            function ju(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
            }

            function Nu(e, t) {
                this.min = void 0 !== e ? e : new jt(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new jt(-1 / 0, -1 / 0)
            }

            function ku(e) {
                qn.call(this), this.material = e, this.render = function () { }
            }

            function Uu(e, t, n, r) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var i = void 0 !== n ? n : 16711680,
                    o = void 0 !== r ? r : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var c = new Ar,
                    l = new dr(2 * a * 3, 3);
                c.addAttribute("position", l), ga.call(this, c, new fa({
                    color: i,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Hu(e, t) {
                qn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                for (var n = new Ar, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++ , o++) {
                    var a = i / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.addAttribute("position", new dr(r, 3));
                var c = new fa({
                    fog: !1
                });
                this.cone = new ga(n, c), this.add(this.cone), this.update()
            }

            function Bu(e) {
                for (var t = function e(t) {
                    var n = [];
                    t && t.isBone && n.push(t);
                    for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                    return n
                }(e), n = new Ar, r = [], i = [], o = new yn(0, 0, 1), a = new yn(0, 1, 0), s = 0; s < t.length; s++) {
                    var c = t[s];
                    c.parent && c.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
                }
                n.addAttribute("position", new dr(r, 3)), n.addAttribute("color", new dr(i, 3));
                var l = new fa({
                    vertexColors: S,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                ga.call(this, n, l), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }

            function Fu(e, t, n) {
                this.light = e, this.light.updateMatrixWorld(), this.color = n;
                var r = new _s(t, 4, 2),
                    i = new ii({
                        wireframe: !0,
                        fog: !1
                    });
                li.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function zu(e, t) {
                qn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                var n = new fa({
                    fog: !1
                }),
                    r = new Ar;
                r.addAttribute("position", new ir(new Float32Array(15), 3)), this.line = new ma(r, n), this.add(this.line), this.update()
            }

            function Gu(e, t, n) {
                qn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var r = new Oa(t);
                r.rotateY(.5 * Math.PI), this.material = new ii({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = S);
                var i = r.getAttribute("position"),
                    o = new Float32Array(3 * i.count);
                r.addAttribute("color", new ir(o, 3)), this.add(new li(r, this.material)), this.update()
            }

            function Vu(e, t, n, r) {
                e = e || 10, t = t || 10, n = new yn(void 0 !== n ? n : 4473924), r = new yn(void 0 !== r ? r : 8947848);
                for (var i = t / 2, o = e / t, a = e / 2, s = [], c = [], l = 0, u = 0, h = -a; l <= t; l++ , h += o) {
                    s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                    var d = l === i ? n : r;
                    d.toArray(c, u), u += 3, d.toArray(c, u), u += 3, d.toArray(c, u), u += 3, d.toArray(c, u), u += 3
                }
                var p = new Ar;
                p.addAttribute("position", new dr(s, 3)), p.addAttribute("color", new dr(c, 3));
                var f = new fa({
                    vertexColors: S
                });
                ga.call(this, p, f)
            }

            function qu(e, t, n, r, i, o) {
                e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new yn(void 0 !== i ? i : 4473924), o = new yn(void 0 !== o ? o : 8947848);
                var a, s, c, l, u, h, d, p = [],
                    f = [];
                for (l = 0; l <= t; l++) c = l / t * (2 * Math.PI), a = Math.sin(c) * e, s = Math.cos(c) * e, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & l ? i : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (l = 0; l <= n; l++)
                    for (d = 1 & l ? i : o, h = e - e / n * l, u = 0; u < r; u++) c = u / r * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b), c = (u + 1) / r * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b);
                var m = new Ar;
                m.addAttribute("position", new dr(p, 3)), m.addAttribute("color", new dr(f, 3));
                var g = new fa({
                    vertexColors: S
                });
                ga.call(this, m, g)
            }

            function Wu(e, t, n, r) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var i = void 0 !== n ? n : 16776960,
                    o = void 0 !== r ? r : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new Ar,
                    l = new dr(2 * a * 3, 3);
                c.addAttribute("position", l), ga.call(this, c, new fa({
                    color: i,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Xu(e, t, n) {
                qn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                var r = new Ar;
                r.addAttribute("position", new dr([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                var i = new fa({
                    fog: !1
                });
                this.lightPlane = new ma(r, i), this.add(this.lightPlane), (r = new Ar).addAttribute("position", new dr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ma(r, i), this.add(this.targetLine), this.update()
            }

            function Yu(e) {
                var t = new Ar,
                    n = new fa({
                        color: 16777215,
                        vertexColors: 1
                    }),
                    r = [],
                    i = [],
                    o = {},
                    a = new yn(16755200),
                    s = new yn(16711680),
                    c = new yn(43775),
                    l = new yn(16777215),
                    u = new yn(3355443);

                function h(e, t, n) {
                    d(e, n), d(t, n)
                }

                function d(e, t) {
                    r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === o[e] && (o[e] = []), o[e].push(r.length / 3 - 1)
                }
                h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", l), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), t.addAttribute("position", new dr(r, 3)), t.addAttribute("color", new dr(i, 3)), ga.call(this, t, n), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function Ju(e, t) {
                this.object = e, void 0 === t && (t = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new Ar;
                i.setIndex(new ir(n, 1)), i.addAttribute("position", new ir(r, 3)), ga.call(this, i, new fa({
                    color: t
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Zu(e, t) {
                this.type = "Box3Helper", this.box = e;
                var n = void 0 !== t ? t : 16776960,
                    r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Ar;
                i.setIndex(new ir(r, 1)), i.addAttribute("position", new dr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), ga.call(this, i, new fa({
                    color: n
                })), this.geometry.computeBoundingSphere()
            }

            function $u(e, t, n) {
                this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
                var r = void 0 !== n ? n : 16776960,
                    i = new Ar;
                i.addAttribute("position", new dr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), ma.call(this, i, new fa({
                    color: r
                }));
                var o = new Ar;
                o.addAttribute("position", new dr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new li(o, new ii({
                    color: r,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function Qu(e, t, n, r, i, o) {
                qn.call(this), void 0 === r && (r = 16776960), void 0 === n && (n = 1), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === pu && ((pu = new Ar).addAttribute("position", new dr([0, 0, 0, 0, 1, 0], 3)), (fu = new Ls(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new ma(pu, new fa({
                    color: r
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new li(fu, new ii({
                    color: r
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, o)
            }

            function Ku(e) {
                var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    n = new Ar;
                n.addAttribute("position", new dr(t, 3)), n.addAttribute("color", new dr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var r = new fa({
                    vertexColors: S
                });
                ga.call(this, n, r)
            }

            function eh(e, t) {
                this.mesh = e, void 0 === t && (t = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new Ar;
                i.setIndex(new ir(n, 1)), i.addAttribute("position", new ir(r, 3)), ga.call(this, i, new fa({
                    color: t
                })), this.matrixAutoUpdate = !1, this.update()
            }
            Object.assign(_u.prototype, {
                getValue: function (e, t) {
                    this.bind();
                    var n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(e, t)
                },
                setValue: function (e, t) {
                    for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
                },
                bind: function () {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                },
                unbind: function () {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }), Object.assign(xu, {
                Composite: _u,
                create: function (e, t, n) {
                    return e && e.isAnimationObjectGroup ? new xu.Composite(e, t, n) : new xu(e, t, n)
                },
                sanitizeNodeName: (Wl = new RegExp("[" + yu + "]", "g"), function (e) {
                    return e.replace(/\s/g, "_").replace(Wl, "")
                }),
                parseTrackName: (Ul = "[^" + yu + "]", Hl = "[^" + yu.replace("\\.", "") + "]", Bl = /((?:WC+[\/:])*)/.source.replace("WC", Ul), Fl = /(WCOD+)?/.source.replace("WCOD", Hl), zl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ul), Gl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ul), Vl = new RegExp("^" + Bl + Fl + zl + Gl + "$"), ql = ["material", "materials", "bones"], function (e) {
                    var t = Vl.exec(e);
                    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    var n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        var i = n.nodeName.substring(r + 1); - 1 !== ql.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }),
                findNode: function (e, o) {
                    if (!o || "" === o || "root" === o || "." === o || -1 === o || o === e.name || o === e.uuid) return e;
                    if (e.skeleton) {
                        var t = e.skeleton.getBoneByName(o);
                        if (void 0 !== t) return t
                    }
                    if (e.children) {
                        var n = function e(t) {
                            for (var n = 0; n < t.length; n++) {
                                var r = t[n];
                                if (r.name === o || r.uuid === o) return r;
                                var i = e(r.children);
                                if (i) return i
                            }
                            return null
                        }(e.children);
                        if (n) return n
                    }
                    return null
                }
            }), Object.assign(xu.prototype, {
                _getValue_unavailable: function () { },
                _setValue_unavailable: function () { },
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function (e, t) {
                    e[t] = this.node[this.propertyName]
                }, function (e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
                }, function (e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }, function (e, t) {
                    this.resolvedProperty.toArray(e, t)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function (e, t) {
                        this.targetObject[this.propertyName] = e[t]
                    }, function (e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                    }, function (e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t]
                    }, function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        this.resolvedProperty.fromArray(e, t)
                    }, function (e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function (e, t) {
                    this.bind(), this.getValue(e, t)
                },
                setValue: function (e, t) {
                    this.bind(), this.setValue(e, t)
                },
                bind: function () {
                    var e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        r = t.propertyName,
                        i = t.propertyIndex;
                    if (e || (e = xu.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                        if (n) {
                            var o = t.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    e = e.material.materials;
                                    break;
                                case "bones":
                                    if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    e = e.skeleton.bones;
                                    for (var a = 0; a < e.length; a++)
                                        if (e[a].name === o) {
                                            o = a;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    e = e[n]
                            }
                            if (void 0 !== o) {
                                if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                e = e[o]
                            }
                        }
                        var s = e[r];
                        if (void 0 !== s) {
                            var c = this.Versioning.None;
                            void 0 !== e.needsUpdate ? (c = this.Versioning.NeedsUpdate, this.targetObject = e) : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e);
                            var l = this.BindingType.Direct;
                            if (void 0 !== i) {
                                if ("morphTargetInfluences" === r) {
                                    if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (e.geometry.isBufferGeometry) {
                                        if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                        for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                            if (e.geometry.morphAttributes.position[a].name === i) {
                                                i = a;
                                                break
                                            }
                                    } else {
                                        if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                        for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                            if (e.geometry.morphTargets[a].name === i) {
                                                i = a;
                                                break
                                            }
                                    }
                                }
                                l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                            this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                        } else {
                            var u = t.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", e)
                        }
                    } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                },
                unbind: function () {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(xu.prototype, {
                _getValue_unbound: xu.prototype.getValue,
                _setValue_unbound: xu.prototype.setValue
            }), Object.assign(bu.prototype, {
                isAnimationObjectGroup: !0,
                add: function () {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, u = arguments.length; l !== u; ++l) {
                        var h = arguments[l],
                            d = h.uuid,
                            p = r[d];
                        if (void 0 === p) {
                            p = t++ , r[d] = p, e.push(h);
                            for (var f = 0, m = s; f !== m; ++f) a[f].push(new xu(h, i[f], o[f]))
                        } else if (p < n) {
                            c = e[p];
                            var g = --n,
                                v = e[g];
                            e[r[v.uuid] = p] = v, e[r[d] = g] = h;
                            for (f = 0, m = s; f !== m; ++f) {
                                var y = a[f],
                                    _ = y[g],
                                    x = y[p];
                                y[p] = _, void 0 === x && (x = new xu(h, i[f], o[f])), y[g] = x
                            }
                        } else e[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function () {
                    for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                        var s = arguments[o],
                            c = s.uuid,
                            l = n[c];
                        if (void 0 !== l && t <= l) {
                            var u = t++,
                                h = e[u];
                            e[n[h.uuid] = l] = h, e[n[c] = u] = s;
                            for (var d = 0, p = i; d !== p; ++d) {
                                var f = r[d],
                                    m = f[u],
                                    g = f[l];
                                f[l] = m, f[u] = g
                            }
                        }
                    }
                    this.nCachedObjects_ = t
                },
                uncache: function () {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                        var c = arguments[a].uuid,
                            l = r[c];
                        if (void 0 !== l)
                            if (delete r[c], l < n) {
                                var u = --n,
                                    h = e[u],
                                    d = e[v = --t];
                                e[r[h.uuid] = l] = h, e[r[d.uuid] = u] = d, e.pop();
                                for (var p = 0, f = o; p !== f; ++p) {
                                    var m = (y = i[p])[u],
                                        g = y[v];
                                    y[l] = m, y[u] = g, y.pop()
                                }
                            } else {
                                var v;
                                e[r[(d = e[v = --t]).uuid] = l] = d, e.pop();
                                for (p = 0, f = o; p !== f; ++p) {
                                    var y;
                                    (y = i[p])[l] = y[v], y.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = n
                },
                subscribe_: function (e, t) {
                    var n = this._bindingsIndicesByPath,
                        r = n[e],
                        i = this._bindings;
                    if (void 0 !== r) return i[r];
                    var o = this._paths,
                        a = this._parsedPaths,
                        s = this._objects,
                        c = s.length,
                        l = this.nCachedObjects_,
                        u = new Array(c);
                    r = i.length, n[e] = r, o.push(e), a.push(t), i.push(u);
                    for (var h = l, d = s.length; h !== d; ++h) {
                        var p = s[h];
                        u[h] = new xu(p, e, t)
                    }
                    return u
                },
                unsubscribe_: function (e) {
                    var t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        var r = this._paths,
                            i = this._parsedPaths,
                            o = this._bindings,
                            a = o.length - 1,
                            s = o[a];
                        o[t[e[a]] = n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                    }
                }
            }), Object.assign(wu.prototype, {
                play: function () {
                    return this._mixer._activateAction(this), this
                },
                stop: function () {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function () {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function () {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function () {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function (e) {
                    return this._startTime = e, this
                },
                setLoop: function (e, t) {
                    return this.loop = e, this.repetitions = t, this
                },
                setEffectiveWeight: function (e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                },
                getEffectiveWeight: function () {
                    return this._effectiveWeight
                },
                fadeIn: function (e) {
                    return this._scheduleFading(e, 0, 1)
                },
                fadeOut: function (e) {
                    return this._scheduleFading(e, 1, 0)
                },
                crossFadeFrom: function (e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        var r = this._clip.duration,
                            i = e._clip.duration,
                            o = i / r,
                            a = r / i;
                        e.warp(1, o, t), this.warp(a, 1, t)
                    }
                    return this
                },
                crossFadeTo: function (e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                },
                stopFading: function () {
                    var e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                setEffectiveTimeScale: function (e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                },
                getEffectiveTimeScale: function () {
                    return this._effectiveTimeScale
                },
                setDuration: function (e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                },
                syncWith: function (e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                },
                halt: function (e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                },
                warp: function (e, t, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._timeScaleInterpolant,
                        a = this.timeScale;
                    null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    var s = o.parameterPositions,
                        c = o.sampleValues;
                    return s[0] = i, s[1] = i + n, c[0] = e / a, c[1] = t / a, this
                },
                stopWarping: function () {
                    var e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                getMixer: function () {
                    return this._mixer
                },
                getClip: function () {
                    return this._clip
                },
                getRoot: function () {
                    return this._localRoot || this._mixer._root
                },
                _update: function (e, t, n, r) {
                    if (this.enabled) {
                        var i = this._startTime;
                        if (null !== i) {
                            var o = (e - i) * n;
                            if (o < 0 || 0 === n) return;
                            this._startTime = null, t = n * o
                        }
                        t *= this._updateTimeScale(e);
                        var a = this._updateTime(t),
                            s = this._updateWeight(e);
                        if (0 < s)
                            for (var c = this._interpolants, l = this._propertyBindings, u = 0, h = c.length; u !== h; ++u) c[u].evaluate(a), l[u].accumulate(r, s)
                    } else this._updateWeight(e)
                },
                _updateWeight: function (e) {
                    var t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var r = n.evaluate(e)[0];
                            t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t
                },
                _updateTimeScale: function (e) {
                    var t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        var n = this._timeScaleInterpolant;
                        if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                    return this._effectiveTimeScale = t
                },
                _updateTime: function (e) {
                    var t = this.time + e;
                    if (0 === e) return t;
                    var n = this._clip.duration,
                        r = this.loop,
                        i = this._loopCount;
                    if (2200 === r) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (n <= t) t = n;
                            else {
                                if (!(t < 0)) break e;
                                t = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: e < 0 ? -1 : 1
                                })
                        }
                    } else {
                        var o = 2202 === r;
                        if (-1 === i && (0 <= e ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), n <= t || t < 0) {
                            var a = Math.floor(t / n);
                            t -= n * a, i += Math.abs(a);
                            var s = this.repetitions - i;
                            if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = 0 < e ? n : 0, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: 0 < e ? 1 : -1
                            });
                            else {
                                if (1 === s) {
                                    var c = e < 0;
                                    this._setEndings(c, !c, o)
                                } else this._setEndings(!1, !1, o);
                                this._loopCount = i, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: a
                                })
                            }
                        }
                        if (o && 1 == (1 & i)) return n - (this.time = t)
                    }
                    return this.time = t
                },
                _setEndings: function (e, t, n) {
                    var r = this._interpolantSettings;
                    n ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, r.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
                },
                _scheduleFading: function (e, t, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._weightInterpolant;
                    null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                    var a = o.parameterPositions,
                        s = o.sampleValues;
                    return a[0] = i, s[0] = t, a[1] = i + e, s[1] = n, this
                }
            }), Eu.prototype = Object.assign(Object.create(i.prototype), {
                constructor: Eu,
                _bindAction: function (e, t) {
                    var n = e._localRoot || this._root,
                        r = e._clip.tracks,
                        i = r.length,
                        o = e._propertyBindings,
                        a = e._interpolants,
                        s = n.uuid,
                        c = this._bindingsByRootAndName,
                        l = c[s];
                    void 0 === l && (l = {}, c[s] = l);
                    for (var u = 0; u !== i; ++u) {
                        var h = r[u],
                            d = h.name,
                            p = l[d];
                        if (void 0 !== p) o[u] = p;
                        else {
                            if (void 0 !== (p = o[u])) {
                                null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                continue
                            }
                            var f = t && t._propertyBindings[u].binding.parsedPath;
                            ++(p = new kl(xu.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), o[u] = p
                        }
                        a[u].resultBuffer = p.buffer
                    }
                },
                _activateAction: function (e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            var t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        for (var i = e._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                            var s = i[o];
                            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                },
                _deactivateAction: function (e) {
                    if (this._isActiveAction(e)) {
                        for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                            var i = t[n];
                            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                        }
                        this._takeBackAction(e)
                    }
                },
                _initMemoryManager: function () {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function (e) {
                    var t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                },
                _addInactiveAction: function (e, t, n) {
                    var r = this._actions,
                        i = this._actionsByClip,
                        o = i[t];
                    if (void 0 === o) o = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, i[t] = o;
                    else {
                        var a = o.knownActions;
                        e._byClipCacheIndex = a.length, a.push(e)
                    }
                    e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e
                },
                _removeInactiveAction: function (e) {
                    var t = this._actions,
                        n = t[t.length - 1],
                        r = e._cacheIndex;
                    t[n._cacheIndex = r] = n, t.pop(), e._cacheIndex = null;
                    var i = e._clip.uuid,
                        o = this._actionsByClip,
                        a = o[i],
                        s = a.knownActions,
                        c = s[s.length - 1],
                        l = e._byClipCacheIndex;
                    s[c._byClipCacheIndex = l] = c, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(e)
                },
                _removeInactiveBindingsForAction: function (e) {
                    for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                        var i = t[n];
                        0 == --i.referenceCount && this._removeInactiveBinding(i)
                    }
                },
                _lendAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        r = this._nActiveActions++,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _takeBackAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        r = --this._nActiveActions,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _addInactiveBinding: function (e, t, n) {
                    var r = this._bindingsByRootAndName,
                        i = r[t],
                        o = this._bindings;
                    void 0 === i && (i = {}, r[t] = i), (i[n] = e)._cacheIndex = o.length, o.push(e)
                },
                _removeInactiveBinding: function (e) {
                    var t = this._bindings,
                        n = e.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        o = this._bindingsByRootAndName,
                        a = o[r],
                        s = t[t.length - 1],
                        c = e._cacheIndex;
                    t[s._cacheIndex = c] = s, t.pop(), delete a[i];
                    e: {
                        for (var l in a) break e; delete o[r]
                    }
                },
                _lendBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        r = this._nActiveBindings++,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _takeBackBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        r = --this._nActiveBindings,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _lendControlInterpolant: function () {
                    var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && (e[(n = new zc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t] = n), n
                },
                _takeBackControlInterpolant: function (e) {
                    var t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = t[r];
                    t[e.__cacheIndex = r] = e, t[i.__cacheIndex = n] = i
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function (e, t) {
                    var n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? Xc.findByName(n, e) : e,
                        o = null !== i ? i.uuid : e,
                        a = this._actionsByClip[o],
                        s = null;
                    if (void 0 !== a) {
                        var c = a.actionByRoot[r];
                        if (void 0 !== c) return c;
                        s = a.knownActions[0], null === i && (i = s._clip)
                    }
                    if (null === i) return null;
                    var l = new wu(this, i, t);
                    return this._bindAction(l, s), this._addInactiveAction(l, o, r), l
                },
                existingAction: function (e, t) {
                    var n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? Xc.findByName(n, e) : e,
                        o = i ? i.uuid : e,
                        a = this._actionsByClip[o];
                    return void 0 !== a && a.actionByRoot[r] || null
                },
                stopAllAction: function () {
                    var e = this._actions,
                        t = this._nActiveActions,
                        n = this._bindings,
                        r = this._nActiveBindings;
                    this._nActiveActions = 0;
                    for (var i = this._nActiveBindings = 0; i !== t; ++i) e[i].reset();
                    for (i = 0; i !== r; ++i) n[i].useCount = 0;
                    return this
                },
                update: function (e) {
                    e *= this.timeScale;
                    for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                        t[a]._update(r, e, i, o)
                    }
                    var s = this._bindings,
                        c = this._nActiveBindings;
                    for (a = 0; a !== c; ++a) s[a].apply(o);
                    return this
                },
                getRoot: function () {
                    return this._root
                },
                uncacheClip: function (e) {
                    var t = this._actions,
                        n = e.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                            var c = o[a];
                            this._deactivateAction(c);
                            var l = c._cacheIndex,
                                u = t[t.length - 1];
                            c._cacheIndex = null, c._byClipCacheIndex = null, t[u._cacheIndex = l] = u, t.pop(), this._removeInactiveBindingsForAction(c)
                        }
                        delete r[n]
                    }
                },
                uncacheRoot: function (e) {
                    var t = e.uuid,
                        n = this._actionsByClip;
                    for (var r in n) {
                        var i = n[r].actionByRoot[t];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                    var o = this._bindingsByRootAndName[t];
                    if (void 0 !== o)
                        for (var a in o) {
                            var s = o[a];
                            s.restoreOriginalState(), this._removeInactiveBinding(s)
                        }
                },
                uncacheAction: function (e, t) {
                    var n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }), Tu.prototype.clone = function () {
                return new Tu(void 0 === this.value.clone ? this.value : this.value.clone())
            }, Su.prototype = Object.assign(Object.create(Ar.prototype), {
                constructor: Su,
                isInstancedBufferGeometry: !0,
                copy: function (e) {
                    return Ar.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), Object.defineProperties(Mu.prototype, {
                count: {
                    get: function () {
                        return this.data.count
                    }
                },
                array: {
                    get: function () {
                        return this.data.array
                    }
                }
            }), Object.assign(Mu.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                },
                setY: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                },
                setZ: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                },
                setW: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                },
                getX: function (e) {
                    return this.data.array[e * this.data.stride + this.offset]
                },
                getY: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                },
                getZ: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                },
                getW: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                },
                setXY: function (e, t, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                },
                setXYZ: function (e, t, n, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
                },
                setXYZW: function (e, t, n, r, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
                }
            }), Object.defineProperty(Au.prototype, "needsUpdate", {
                set: function (e) {
                    !0 === e && this.version++
                }
            }), Object.assign(Au.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function () { },
                setArray: function (e) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
                },
                setDynamic: function (e) {
                    return this.dynamic = e, this
                },
                copy: function (e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
                },
                copyAt: function (e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                onUpload: function (e) {
                    return this.onUploadCallback = e, this
                }
            }), Cu.prototype = Object.assign(Object.create(Au.prototype), {
                constructor: Cu,
                isInstancedInterleavedBuffer: !0,
                copy: function (e) {
                    return Au.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                }
            }), Lu.prototype = Object.assign(Object.create(ir.prototype), {
                constructor: Lu,
                isInstancedBufferAttribute: !0,
                copy: function (e) {
                    return ir.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                }
            }), Object.assign(Ru.prototype, {
                linePrecision: 1,
                set: function (e, t) {
                    this.ray.set(e, t)
                },
                setFromCamera: function (e, t) {
                    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function (e, t, n) {
                    var r = n || [];
                    return Ou(e, this, r, t), r.sort(Pu), r
                },
                intersectObjects: function (e, t, n) {
                    var r = n || [];
                    if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
                    for (var i = 0, o = e.length; i < o; i++) Ou(e[i], this, r, t);
                    return r.sort(Pu), r
                }
            }), Object.assign(Iu.prototype, {
                start: function () {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function () {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function () {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function () {
                    var e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var t = ("undefined" == typeof performance ? Date : performance).now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }), Object.assign(Du.prototype, {
                set: function (e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                },
                makeSafe: function () {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                },
                setFromVector3: function (e) {
                    return this.radius = e.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(Dt.clamp(e.y / this.radius, -1, 1))), this
                }
            }), Object.assign(ju.prototype, {
                set: function (e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                },
                setFromVector3: function (e) {
                    return this.radius = Math.sqrt(e.x * e.x + e.z * e.z), this.theta = Math.atan2(e.x, e.z), this.y = e.y, this
                }
            }), Object.assign(Nu.prototype, {
                set: function (e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromPoints: function (e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: (Yl = new jt, function (e, t) {
                    var n = Yl.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function () {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                },
                isEmpty: function () {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new jt), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function (e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new jt), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function (e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function (e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function (e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function (e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                },
                containsBox: function (e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                },
                getParameter: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new jt), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function (e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                },
                clampPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new jt), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: (Xl = new jt, function (e) {
                    return Xl.copy(e).clamp(this.min, this.max).sub(e).length()
                }),
                intersect: function (e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function (e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                translate: function (e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function (e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }), ((ku.prototype = Object.create(qn.prototype)).constructor = ku).prototype.isImmediateRenderObject = !0, ((Uu.prototype = Object.create(ga.prototype)).constructor = Uu).prototype.update = (Jl = new Ut, Zl = new Ut, $l = new Ht, function () {
                var e = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), $l.getNormalMatrix(this.object.matrixWorld);
                var t = this.object.matrixWorld,
                    n = this.geometry.attributes.position,
                    r = this.object.geometry;
                if (r && r.isGeometry)
                    for (var i = r.vertices, o = r.faces, a = 0, s = 0, c = o.length; s < c; s++)
                        for (var l = o[s], u = 0, h = l.vertexNormals.length; u < h; u++) {
                            var d = i[l[e[u]]],
                                p = l.vertexNormals[u];
                            Jl.copy(d).applyMatrix4(t), Zl.copy(p).applyMatrix3($l).normalize().multiplyScalar(this.size).add(Jl), n.setXYZ(a, Jl.x, Jl.y, Jl.z), a += 1, n.setXYZ(a, Zl.x, Zl.y, Zl.z), a += 1
                        } else if (r && r.isBufferGeometry) {
                            var f = r.attributes.position,
                                m = r.attributes.normal;
                            for (u = a = 0, h = f.count; u < h; u++) Jl.set(f.getX(u), f.getY(u), f.getZ(u)).applyMatrix4(t), Zl.set(m.getX(u), m.getY(u), m.getZ(u)), Zl.applyMatrix3($l).normalize().multiplyScalar(this.size).add(Jl), n.setXYZ(a, Jl.x, Jl.y, Jl.z), a += 1, n.setXYZ(a, Zl.x, Zl.y, Zl.z), a += 1
                        }
                n.needsUpdate = !0
            }), ((Hu.prototype = Object.create(qn.prototype)).constructor = Hu).prototype.dispose = function () {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, Hu.prototype.update = (Ql = new Ut, Kl = new Ut, function () {
                this.light.updateMatrixWorld();
                var e = this.light.distance ? this.light.distance : 1e3,
                    t = e * Math.tan(this.light.angle);
                this.cone.scale.set(t, t, e), Ql.setFromMatrixPosition(this.light.matrixWorld), Kl.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Kl.sub(Ql)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }), ((Bu.prototype = Object.create(ga.prototype)).constructor = Bu).prototype.updateMatrixWorld = (eu = new Ut, tu = new Nt, nu = new Nt, function (e) {
                var t = this.bones,
                    n = this.geometry,
                    r = n.getAttribute("position");
                nu.getInverse(this.root.matrixWorld);
                for (var i = 0, o = 0; i < t.length; i++) {
                    var a = t[i];
                    a.parent && a.parent.isBone && (tu.multiplyMatrices(nu, a.matrixWorld), eu.setFromMatrixPosition(tu), r.setXYZ(o, eu.x, eu.y, eu.z), tu.multiplyMatrices(nu, a.parent.matrixWorld), eu.setFromMatrixPosition(tu), r.setXYZ(o + 1, eu.x, eu.y, eu.z), o += 2)
                }
                n.getAttribute("position").needsUpdate = !0, qn.prototype.updateMatrixWorld.call(this, e)
            }), ((Fu.prototype = Object.create(li.prototype)).constructor = Fu).prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose()
            }, Fu.prototype.update = function () {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }, ((zu.prototype = Object.create(qn.prototype)).constructor = zu).prototype.dispose = function () {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, zu.prototype.update = function () {
                var e = .5 * this.light.width,
                    t = .5 * this.light.height,
                    n = this.line.geometry.attributes.position,
                    r = n.array;
                r[0] = e, r[1] = -t, r[2] = 0, r[3] = e, r[4] = t, r[5] = 0, r[6] = -e, r[7] = t, r[8] = 0, r[9] = -e, r[10] = -t, r[11] = 0, r[12] = e, r[13] = -t, r[14] = 0, n.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
            }, ((Gu.prototype = Object.create(qn.prototype)).constructor = Gu).prototype.dispose = function () {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, Gu.prototype.update = (ru = new Ut, iu = new yn, ou = new yn, function () {
                var e = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var t = e.geometry.getAttribute("color");
                    iu.copy(this.light.color), ou.copy(this.light.groundColor);
                    for (var n = 0, r = t.count; n < r; n++) {
                        var i = n < r / 2 ? iu : ou;
                        t.setXYZ(n, i.r, i.g, i.b)
                    }
                    t.needsUpdate = !0
                }
                e.lookAt(ru.setFromMatrixPosition(this.light.matrixWorld).negate())
            }), (Vu.prototype = Object.create(ga.prototype)).constructor = Vu, (qu.prototype = Object.create(ga.prototype)).constructor = qu, ((Wu.prototype = Object.create(ga.prototype)).constructor = Wu).prototype.update = (au = new Ut, su = new Ut, cu = new Ht, function () {
                this.object.updateMatrixWorld(!0), cu.getNormalMatrix(this.object.matrixWorld);
                for (var e = this.object.matrixWorld, t = this.geometry.attributes.position, n = this.object.geometry, r = n.vertices, i = n.faces, o = 0, a = 0, s = i.length; a < s; a++) {
                    var c = i[a],
                        l = c.normal;
                    au.copy(r[c.a]).add(r[c.b]).add(r[c.c]).divideScalar(3).applyMatrix4(e), su.copy(l).applyMatrix3(cu).normalize().multiplyScalar(this.size).add(au), t.setXYZ(o, au.x, au.y, au.z), o += 1, t.setXYZ(o, su.x, su.y, su.z), o += 1
                }
                t.needsUpdate = !0
            }), ((Xu.prototype = Object.create(qn.prototype)).constructor = Xu).prototype.dispose = function () {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, Xu.prototype.update = (lu = new Ut, uu = new Ut, hu = new Ut, function () {
                lu.setFromMatrixPosition(this.light.matrixWorld), uu.setFromMatrixPosition(this.light.target.matrixWorld), hu.subVectors(uu, lu), this.lightPlane.lookAt(hu), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(hu), this.targetLine.scale.z = hu.length()
            }), ((Yu.prototype = Object.create(ga.prototype)).constructor = Yu).prototype.update = function () {
                var c, l, u = new Ut,
                    h = new Wn;

                function e(e, t, n, r) {
                    u.set(t, n, r).unproject(h);
                    var i = l[e];
                    if (void 0 !== i)
                        for (var o = c.getAttribute("position"), a = 0, s = i.length; a < s; a++) o.setXYZ(i[a], u.x, u.y, u.z)
                }
                return function () {
                    c = this.geometry, l = this.pointMap;
                    h.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), c.getAttribute("position").needsUpdate = !0
                }
            }(), ((Ju.prototype = Object.create(ga.prototype)).constructor = Ju).prototype.update = (du = new un, function (e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && du.setFromObject(this.object), !du.isEmpty()) {
                    var t = du.min,
                        n = du.max,
                        r = this.geometry.attributes.position,
                        i = r.array;
                    i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }), Ju.prototype.setFromObject = function (e) {
                return this.object = e, this.update(), this
            }, ((Zu.prototype = Object.create(ga.prototype)).constructor = Zu).prototype.updateMatrixWorld = function (e) {
                var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), qn.prototype.updateMatrixWorld.call(this, e))
            }, (($u.prototype = Object.create(ma.prototype)).constructor = $u).prototype.updateMatrixWorld = function (e) {
                var t = -this.plane.constant;
                Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.lookAt(this.plane.normal), qn.prototype.updateMatrixWorld.call(this, e)
            }, ((Qu.prototype = Object.create(qn.prototype)).constructor = Qu).prototype.setDirection = (gu = new Ut, function (e) {
                .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (gu.set(e.z, 0, -e.x).normalize(), mu = Math.acos(e.y), this.quaternion.setFromAxisAngle(gu, mu))
            }), Qu.prototype.setLength = function (e, t, n) {
                void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
            }, Qu.prototype.setColor = function (e) {
                this.line.material.color.copy(e), this.cone.material.color.copy(e)
            }, (Ku.prototype = Object.create(ga.prototype)).constructor = Ku, ((eh.prototype = Object.create(ga.prototype)).constructor = eh).prototype.update = (vu = new un, function (e) {
                if (void 0 !== e && console.warn("THREE.SkinnedMeshBoxHelper: .update() has no longer arguments."), void 0 !== this.mesh) {
                    this.mesh.geometry.boundingBox || this.mesh.geometry.computeBoundingBox(), vu.copy(this.mesh.geometry.boundingBox);
                    var t = this.mesh.skeleton;
                    if (t && t.rootMotionBone) {
                        var n = t.rootMotionBone.matrixWorld.clone();
                        n.multiply(t.rootMotionBoneInitialMatrixInverse), vu.applyMatrix4(n)
                    } else vu.applyMatrix4(this.mesh.matrixWorld)
                }
                if (!vu.isEmpty()) {
                    var r = vu.min,
                        i = vu.max,
                        o = this.geometry.attributes.position,
                        a = o.array;
                    a[0] = i.x, a[1] = i.y, a[2] = i.z, a[3] = r.x, a[4] = i.y, a[5] = i.z, a[6] = r.x, a[7] = r.y, a[8] = i.z, a[9] = i.x, a[10] = r.y, a[11] = i.z, a[12] = i.x, a[13] = i.y, a[14] = r.z, a[15] = r.x, a[16] = i.y, a[17] = r.z, a[18] = r.x, a[19] = r.y, a[20] = r.z, a[21] = i.x, a[22] = r.y, a[23] = r.z, o.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }), eh.prototype.setFromMesh = function (e) {
                return this.mesh = e, this.update(), this
            };
            var th;

            function nh(e) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), lc.call(this, e), this.type = "catmullrom", this.closed = !0
            }

            function rh(e) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), lc.call(this, e), this.type = "catmullrom"
            }

            function ih(e) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), lc.call(this, e), this.type = "catmullrom"
            }
            tc.create = function (e, t) {
                return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(tc.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e
            }, Object.assign(bc.prototype, {
                createPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getPoints(e);
                    return this.createGeometry(t)
                },
                createSpacedPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getSpacedPoints(e);
                    return this.createGeometry(t)
                },
                createGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var t = new rr, n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.vertices.push(new Ut(i.x, i.y, i.z || 0))
                    }
                    return t
                }
            }), Object.assign(wc.prototype, {
                fromPoints: function (e) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
                }
            }), nh.prototype = Object.create(lc.prototype), rh.prototype = Object.create(lc.prototype), ih.prototype = Object.create(lc.prototype), Object.assign(ih.prototype, {
                initFromArray: function () {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function () {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function () {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), Vu.prototype.setColors = function () {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, Bu.prototype.update = function () {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(tl.prototype, {
                extractUrlBase: function (e) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), nl.extractUrlBase(e)
                }
            }), Object.assign(Nu.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function () {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                size: function (e) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), Object.assign(un.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function () {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                },
                size: function (e) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), si.prototype.center = function (e) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, Object.assign(Dt, {
                random16: function () {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Dt.floorPowerOfTwo(e)
                },
                nextPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Dt.ceilPowerOfTwo(e)
                }
            }), Object.assign(Ht.prototype, {
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(Nt.prototype, {
                extractPosition: function (e) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
                },
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                getPosition: function () {
                    return void 0 === th && (th = new Ut), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), th.setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function (e) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
                },
                multiplyToArray: function () {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector4: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function (e) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
                },
                crossVector: function (e) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                translate: function () {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function () {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function () {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function () {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function () {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function (e, t, n, r, i, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, o)
                }
            }), dn.prototype.isIntersectionLine = function (e) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
            }, kt.prototype.multiplyVector3 = function (e) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
            }, Object.assign(ai.prototype, {
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionPlane: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                }
            }), Object.assign(ci.prototype, {
                area: function () {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function (e, t) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
                },
                midpoint: function (e) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
                },
                normal: function (e) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
                },
                plane: function (e) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
                }
            }), Object.assign(ci, {
                barycoordFromPoint: function (e, t, n, r, i) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ci.getBarycoord(e, t, n, r, i)
                },
                normal: function (e, t, n, r) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ci.getNormal(e, t, n, r)
                }
            }), Object.assign(Ec.prototype, {
                extractAllPoints: function (e) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
                },
                extrude: function (e) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ps(this, e)
                },
                makeGeometry: function (e) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ts(this, e)
                }
            }), Object.assign(jt.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ut.prototype, {
                setEulerFromRotationMatrix: function () {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function () {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
                },
                getScaleFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
                },
                getColumnFromMatrix: function (e, t) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
                },
                applyProjection: function (e) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
                },
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(an.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(rr.prototype, {
                computeTangents: function () {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function () {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(qn.prototype, {
                getChildByName: function (e) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
                },
                renderDepth: function () {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function (e, t) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
                },
                getWorldRotation: function () {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(qn.prototype, {
                eulerOrder: {
                    get: function () {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function (e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                    }
                },
                useQuaternion: {
                    get: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(ua.prototype, {
                objects: {
                    get: function () {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(ha.prototype, "useVertexTexture", {
                get: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Object.defineProperty(tc.prototype, "__arcLengthDivisions", {
                get: function () {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function (e) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
                }
            }), ta.prototype.setLens = function (e, t) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
            }, Object.defineProperties(Tc.prototype, {
                onlyShadow: {
                    set: function () {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function () {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function () {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(ir.prototype, {
                length: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                copyIndicesArray: function () {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            }), Object.assign(Ar.prototype, {
                addIndex: function (e) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
                },
                addDrawCall: function (e, t, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
                },
                clearDrawCalls: function () {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function () {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function () {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(Ar.prototype, {
                drawcalls: {
                    get: function () {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function () {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(fs.prototype, {
                getArrays: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(Tu.prototype, {
                dynamic: {
                    set: function () {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function () {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(ri.prototype, {
                wrapAround: {
                    get: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                wrapRGB: {
                    get: function () {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new yn
                    }
                },
                shading: {
                    get: function () {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function (e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
                    }
                }
            }), Object.defineProperties(Hs.prototype, {
                metal: {
                    get: function () {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function () {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(oi.prototype, {
                derivatives: {
                    get: function () {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function (e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                    }
                }
            }), Object.assign(ia.prototype, {
                getCurrentRenderTarget: function () {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function () {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function () {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function () {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function (e) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
                },
                initMaterial: function () {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function () {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function () {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }
            }), Object.defineProperties(ia.prototype, {
                shadowMapEnabled: {
                    get: function () {
                        return this.shadowMap.enabled
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function () {
                        return this.shadowMap.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Jo.prototype, {
                cullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(sn.prototype, {
                wrapS: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                    }
                },
                repeat: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                    }
                },
                format: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                    }
                },
                type: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                    }
                }
            }), Object.defineProperties(ra.prototype, {
                standing: {
                    set: function () {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                }
            }), Dl.prototype.load = function (e) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var t = this;
                return (new Rl).load(e, function (e) {
                    t.setBuffer(e)
                }), this
            }, Nl.prototype.getData = function () {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Ol.prototype.updateCubeMap = function (e, t) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
            };
            var oh = {
                merge: function (e, t, n) {
                    var r;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
                },
                center: function (e) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
                }
            },
                ah = {
                    crossOrigin: void 0,
                    loadTexture: function (e, t, n, r) {
                        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                        var i = new ec;
                        i.setCrossOrigin(this.crossOrigin);
                        var o = i.load(e, n, void 0, r);
                        return t && (o.mapping = t), o
                    },
                    loadTextureCube: function (e, t, n, r) {
                        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                        var i = new Ks;
                        i.setCrossOrigin(this.crossOrigin);
                        var o = i.load(e, n, void 0, r);
                        return t && (o.mapping = t), o
                    },
                    loadCompressedTexture: function () {
                        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                    },
                    loadCompressedTextureCube: function () {
                        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                    }
                };
            var sh = {
                createMultiMaterialObject: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };
            n.WebGLRenderTargetCube = cn, n.WebGLRenderTarget = sn, n.WebGLRenderer = ia, n.ShaderLib = wn, n.UniformsLib = bn, n.UniformsUtils = gn, n.ShaderChunk = mn, n.FogExp2 = oa, n.Fog = aa, n.Scene = sa, n.Sprite = la, n.LOD = ua, n.SkinnedMesh = pa, n.Skeleton = ha, n.Bone = da, n.Mesh = li, n.LineSegments = ga, n.LineLoop = va, n.Line = ma, n.Points = _a, n.Group = xa, n.VideoTexture = ba, n.DataTexture = ln, n.CompressedTexture = wa, n.CubeTexture = bi, n.CanvasTexture = Zo, n.DepthTexture = Ea, n.Texture = on, n.CompressedTextureLoader = Zs, n.DataTextureLoader = $s, n.CubeTextureLoader = Ks, n.TextureLoader = ec, n.ObjectLoader = il, n.MaterialLoader = Yc, n.BufferGeometryLoader = Jc, n.DefaultLoadingManager = Xs, n.LoadingManager = Ws, n.JSONLoader = rl, n.ImageLoader = Qs, n.ImageBitmapLoader = ll, n.FontLoader = pl, n.FileLoader = Js, n.Loader = tl, n.LoaderUtils = nl, n.Cache = qs, n.AudioLoader = Rl, n.SpotLightShadow = Ac, n.SpotLight = Cc, n.PointLight = Lc, n.RectAreaLight = Ic, n.HemisphereLight = Sc, n.DirectionalLightShadow = Rc, n.DirectionalLight = Pc, n.AmbientLight = Oc, n.LightShadow = Mc, n.Light = Tc, n.StereoCamera = Pl, n.PerspectiveCamera = ta, n.OrthographicCamera = Xn, n.CubeCamera = Ol, n.ArrayCamera = na, n.Camera = Wn, n.AudioListener = Il, n.PositionalAudio = jl, n.AudioContext = Ll, n.AudioAnalyser = Nl, n.Audio = Dl, n.VectorKeyframeTrack = Wc, n.StringKeyframeTrack = Dc, n.QuaternionKeyframeTrack = Uc, n.NumberKeyframeTrack = Bc, n.ColorKeyframeTrack = Hc, n.BooleanKeyframeTrack = jc, n.PropertyMixer = kl, n.PropertyBinding = xu, n.KeyframeTrack = qc, n.AnimationUtils = Vc, n.AnimationObjectGroup = bu, n.AnimationMixer = Eu, n.AnimationClip = Xc, n.Uniform = Tu, n.InstancedBufferGeometry = Su, n.BufferGeometry = Ar, n.Geometry = rr, n.InterleavedBufferAttribute = Mu, n.InstancedInterleavedBuffer = Cu, n.InterleavedBuffer = Au, n.InstancedBufferAttribute = Lu, n.Face3 = Yn, n.Object3D = qn, n.Raycaster = Ru, n.Layers = Sn, n.EventDispatcher = i, n.Clock = Iu, n.QuaternionLinearInterpolant = kc, n.LinearInterpolant = zc, n.DiscreteInterpolant = Gc, n.CubicInterpolant = Fc, n.Interpolant = Nc, n.Triangle = ci, n.Math = Dt, n.Spherical = Du, n.Cylindrical = ju, n.Plane = dn, n.Frustum = pn, n.Sphere = hn, n.Ray = ai, n.Matrix4 = Nt, n.Matrix3 = Ht, n.Box3 = un, n.Box2 = Nu, n.Line3 = si, n.Euler = Tn, n.Vector4 = an, n.Vector3 = Ut, n.Vector2 = jt, n.Quaternion = kt, n.Color = yn, n.ImmediateRenderObject = ku, n.VertexNormalsHelper = Uu, n.SpotLightHelper = Hu, n.SkeletonHelper = Bu, n.PointLightHelper = Fu, n.RectAreaLightHelper = zu, n.HemisphereLightHelper = Gu, n.GridHelper = Vu, n.PolarGridHelper = qu, n.FaceNormalsHelper = Wu, n.DirectionalLightHelper = Xu, n.CameraHelper = Yu, n.BoxHelper = Ju, n.Box3Helper = Zu, n.PlaneHelper = $u, n.ArrowHelper = Qu, n.AxesHelper = Ku, n.SkinnedMeshBoxHelper = eh, n.Shape = Ec, n.Path = wc, n.ShapePath = ul, n.Font = hl, n.CurvePath = bc, n.Curve = tc, n.ShapeUtils = us, n.WebGLUtils = ea, n.WireframeGeometry = Ta, n.ParametricGeometry = Sa, n.ParametricBufferGeometry = Ma, n.TetrahedronGeometry = La, n.TetrahedronBufferGeometry = Ra, n.OctahedronGeometry = Pa, n.OctahedronBufferGeometry = Oa, n.IcosahedronGeometry = Ia, n.IcosahedronBufferGeometry = Da, n.DodecahedronGeometry = ja, n.DodecahedronBufferGeometry = Na, n.PolyhedronGeometry = Aa, n.PolyhedronBufferGeometry = Ca, n.TubeGeometry = ka, n.TubeBufferGeometry = Ua, n.TorusKnotGeometry = Ha, n.TorusKnotBufferGeometry = Ba, n.TorusGeometry = Fa, n.TorusBufferGeometry = za, n.TextGeometry = gs, n.TextBufferGeometry = vs, n.SphereGeometry = ys, n.SphereBufferGeometry = _s, n.RingGeometry = xs, n.RingBufferGeometry = bs, n.PlaneGeometry = Rr, n.PlaneBufferGeometry = Pr, n.LatheGeometry = ws, n.LatheBufferGeometry = Es, n.ShapeGeometry = Ts, n.ShapeBufferGeometry = Ss, n.ExtrudeGeometry = ps, n.ExtrudeBufferGeometry = fs, n.EdgesGeometry = As, n.ConeGeometry = Rs, n.ConeBufferGeometry = Ps, n.CylinderGeometry = Cs, n.CylinderBufferGeometry = Ls, n.CircleGeometry = Os, n.CircleBufferGeometry = Is, n.BoxGeometry = Cr, n.BoxBufferGeometry = Lr, n.ShadowMaterial = js, n.SpriteMaterial = ca, n.RawShaderMaterial = Ns, n.ShaderMaterial = oi, n.PointsMaterial = ya, n.MeshPhysicalMaterial = Us, n.MeshStandardMaterial = ks, n.MeshPhongMaterial = Hs, n.MeshToonMaterial = Bs, n.MeshNormalMaterial = Fs, n.MeshLambertMaterial = zs, n.MeshDepthMaterial = Xo, n.MeshDistanceMaterial = Yo, n.MeshBasicMaterial = ii, n.LineDashedMaterial = Gs, n.LineBasicMaterial = fa, n.Material = ri, n.Float64BufferAttribute = pr, n.Float32BufferAttribute = dr, n.Uint32BufferAttribute = hr, n.Int32BufferAttribute = ur, n.Uint16BufferAttribute = lr, n.Int16BufferAttribute = cr, n.Uint8ClampedBufferAttribute = sr, n.Uint8BufferAttribute = ar, n.Int8BufferAttribute = or, n.BufferAttribute = ir, n.ArcCurve = rc, n.CatmullRomCurve3 = lc, n.CubicBezierCurve = pc, n.CubicBezierCurve3 = fc, n.EllipseCurve = nc, n.LineCurve = mc, n.LineCurve3 = gc, n.QuadraticBezierCurve = vc, n.QuadraticBezierCurve3 = yc, n.SplineCurve = _c, n.REVISION = "92", n.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            }, n.CullFaceNone = G, n.CullFaceBack = V, n.CullFaceFront = q, n.CullFaceFrontBack = 3, n.FrontFaceDirectionCW = 0, n.FrontFaceDirectionCCW = 1, n.BasicShadowMap = 0, n.PCFShadowMap = k, n.PCFSoftShadowMap = U, n.FrontSide = j, n.BackSide = J, n.DoubleSide = Z, n.FlatShading = 1, n.SmoothShading = 2, n.NoColors = Se, n.FaceColors = 1, n.VertexColors = S, n.NoBlending = W, n.NormalBlending = X, n.AdditiveBlending = Y, n.SubtractiveBlending = $, n.MultiplyBlending = Q, n.CustomBlending = K, n.AddEquation = M, n.SubtractEquation = A, n.ReverseSubtractEquation = C, n.MinEquation = L, n.MaxEquation = R, n.ZeroFactor = P, n.OneFactor = O, n.SrcColorFactor = I, n.OneMinusSrcColorFactor = D, n.SrcAlphaFactor = N, n.OneMinusSrcAlphaFactor = H, n.DstAlphaFactor = B, n.OneMinusDstAlphaFactor = F, n.DstColorFactor = z, n.OneMinusDstColorFactor = ee, n.SrcAlphaSaturateFactor = te, n.NeverDepth = ne, n.AlwaysDepth = re, n.LessDepth = ie, n.LessEqualDepth = oe, n.EqualDepth = ae, n.GreaterEqualDepth = se, n.GreaterDepth = ce, n.NotEqualDepth = le, n.MultiplyOperation = ue, n.MixOperation = he, n.AddOperation = de, n.NoToneMapping = pe, n.LinearToneMapping = Me, n.ReinhardToneMapping = fe, n.Uncharted2ToneMapping = me, n.CineonToneMapping = ge, n.UVMapping = 300, n.CubeReflectionMapping = ve, n.CubeRefractionMapping = ye, n.EquirectangularReflectionMapping = _e, n.EquirectangularRefractionMapping = xe, n.SphericalReflectionMapping = be, n.CubeUVReflectionMapping = we, n.CubeUVRefractionMapping = Ee, n.RepeatWrapping = Te, n.ClampToEdgeWrapping = Ae, n.MirroredRepeatWrapping = Ce, n.NearestFilter = Le, n.NearestMipMapNearestFilter = Re, n.NearestMipMapLinearFilter = Pe, n.LinearFilter = Oe, n.LinearMipMapNearestFilter = Ie, n.LinearMipMapLinearFilter = De, n.UnsignedByteType = je, n.ByteType = Ne, n.ShortType = ke, n.UnsignedShortType = Ue, n.IntType = He, n.UnsignedIntType = Be, n.FloatType = Fe, n.HalfFloatType = ze, n.UnsignedShort4444Type = Ge, n.UnsignedShort5551Type = Ve, n.UnsignedShort565Type = qe, n.UnsignedInt248Type = We, n.AlphaFormat = Xe, n.RGBFormat = Ye, n.RGBAFormat = Je, n.LuminanceFormat = Ze, n.LuminanceAlphaFormat = $e, n.RGBEFormat = Qe, n.DepthFormat = Ke, n.DepthStencilFormat = et, n.RGB_S3TC_DXT1_Format = tt, n.RGBA_S3TC_DXT1_Format = nt, n.RGBA_S3TC_DXT3_Format = rt, n.RGBA_S3TC_DXT5_Format = it, n.RGB_PVRTC_4BPPV1_Format = ot, n.RGB_PVRTC_2BPPV1_Format = at, n.RGBA_PVRTC_4BPPV1_Format = st, n.RGBA_PVRTC_2BPPV1_Format = ct, n.RGB_ETC1_Format = lt, n.RGBA_ASTC_4x4_Format = ut, n.RGBA_ASTC_5x4_Format = ht, n.RGBA_ASTC_5x5_Format = dt, n.RGBA_ASTC_6x5_Format = pt, n.RGBA_ASTC_6x6_Format = ft, n.RGBA_ASTC_8x5_Format = mt, n.RGBA_ASTC_8x6_Format = gt, n.RGBA_ASTC_8x8_Format = vt, n.RGBA_ASTC_10x5_Format = yt, n.RGBA_ASTC_10x6_Format = _t, n.RGBA_ASTC_10x8_Format = xt, n.RGBA_ASTC_10x10_Format = bt, n.RGBA_ASTC_12x10_Format = wt, n.RGBA_ASTC_12x12_Format = Et, n.LoopOnce = 2200, n.LoopRepeat = 2201, n.LoopPingPong = 2202, n.InterpolateDiscrete = 2300, n.InterpolateLinear = 2301, n.InterpolateSmooth = 2302, n.ZeroCurvatureEnding = 2400, n.ZeroSlopeEnding = 2401, n.WrapAroundEnding = 2402, n.TrianglesDrawMode = Tt, n.TriangleStripDrawMode = 1, n.TriangleFanDrawMode = 2, n.LinearEncoding = St, n.sRGBEncoding = Mt, n.GammaEncoding = At, n.RGBEEncoding = Ct, n.LogLuvEncoding = 3003, n.RGBM7Encoding = Lt, n.RGBM16Encoding = Rt, n.RGBDEncoding = Pt, n.BasicDepthPacking = Ot, n.RGBADepthPacking = It, n.CubeGeometry = Cr, n.Face4 = function (e, t, n, r, i, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Yn(e, t, n, i, o, a)
            }, n.LineStrip = 0, n.LinePieces = 1, n.MeshFaceMaterial = function (e) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
            }, n.MultiMaterial = function (e) {
                return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, (e.materials = e).clone = function () {
                    return e.slice()
                }, e
            }, n.PointCloud = function (e, t) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new _a(e, t)
            }, n.Particle = function (e) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new la(e)
            }, n.ParticleSystem = function (e, t) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new _a(e, t)
            }, n.PointCloudMaterial = function (e) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new ya(e)
            }, n.ParticleBasicMaterial = function (e) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new ya(e)
            }, n.ParticleSystemMaterial = function (e) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new ya(e)
            }, n.Vertex = function (e, t, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Ut(e, t, n)
            }, n.DynamicBufferAttribute = function (e, t) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ir(e, t).setDynamic(!0)
            }, n.Int8Attribute = function (e, t) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new or(e, t)
            }, n.Uint8Attribute = function (e, t) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ar(e, t)
            }, n.Uint8ClampedAttribute = function (e, t) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new sr(e, t)
            }, n.Int16Attribute = function (e, t) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new cr(e, t)
            }, n.Uint16Attribute = function (e, t) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new lr(e, t)
            }, n.Int32Attribute = function (e, t) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new ur(e, t)
            }, n.Uint32Attribute = function (e, t) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new hr(e, t)
            }, n.Float32Attribute = function (e, t) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new dr(e, t)
            }, n.Float64Attribute = function (e, t) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new pr(e, t)
            }, n.ClosedSplineCurve3 = nh, n.SplineCurve3 = rh, n.Spline = ih, n.AxisHelper = function (e) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Ku(e)
            }, n.BoundingBoxHelper = function (e, t) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Ju(e, t)
            }, n.EdgesHelper = function (e, t) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new ga(new As(e.geometry), new fa({
                    color: void 0 !== t ? t : 16777215
                }))
            }, n.WireframeHelper = function (e, t) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new ga(new Ta(e.geometry), new fa({
                    color: void 0 !== t ? t : 16777215
                }))
            }, n.XHRLoader = function (e) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Js(e)
            }, n.BinaryTextureLoader = function (e) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new $s(e)
            }, n.GeometryUtils = oh, n.ImageUtils = ah, n.Projector = function () {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (e, t) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
                }, this.unprojectVector = function (e, t) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
                }, this.pickingRay = function () {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }, n.CanvasRenderer = function () {
                console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function () { }, this.render = function () { }, this.setClearColor = function () { }, this.setSize = function () { }
            }, n.SceneUtils = sh, n.LensFlare = function () {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }
        }, {}],
       // initdevicecontrols module
        7: [function (e, t, n) {
            "use strict";
            Object.defineProperty(n, "__esModule", {
                value: !0
            }), n.default = void 0;
            var r = function () {
                function r(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }
                return function (e, t, n) {
                    return t && r(e.prototype, t), n && r(e, n), e
                }
            }(),
                c = function (e) {
                    {
                        if (e && e.__esModule) return e;
                        var t = {};
                        if (null != e)
                            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                        return t.default = e, t
                    }
                }(e("../libs/three.module.js"));

            function i(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }
            // mouseHandler
            var o = function () {
                function n(e, t) {
                    i(this, n), this.camera = e, this.renderer = t, this.rotating = !1, this.startDirection = new c.Vector3, this.movingDirection = new c.Vector3, this.startCamera = new c.Camera, this.deltaQuaternion = new c.Quaternion, this.onMouseDown = this.createOnMouseDownHandler(), this.onMouseMove = this.createOnMouseMoveHandler(), this.onMouseUp = this.createOnMouseUpHandler()
                }
                return r(n, [{
                    key: "calcDirection",
                    value: function (e, t) {
                        var n = this.renderer.domElement.getBoundingClientRect(),
                            r = (e.pageX - n.left) / n.width * 2 - 1,
                            i = -(e.pageY - n.top) / n.height * 2 + 1;
                        return t.set(r, i, .5).unproject(this.startCamera).sub(this.startCamera.position).normalize()
                    }
                }, {
                    key: "createOnMouseDownHandler",
                    value: function () {
                        var t = this;
                        return function (e) {
                            e.ctrlKey || 0 !== e.button || (t.rotating = !0, t.startCamera.copy(t.camera), t.calcDirection(e, t.startDirection), t.deltaQuaternion.set(0, 0, 0, 1), document.addEventListener("mousemove", t.onMouseMove), document.addEventListener("mouseup", t.onMouseUp), e.preventDefault())
                        }
                    }
                }, {
                    key: "createOnMouseMoveHandler",
                    value: function () {
                        var t = this;
                        return function (e) {
                            t.rotating && (t.calcDirection(e, t.movingDirection), t.deltaQuaternion.setFromUnitVectors(t.movingDirection, t.startDirection), e.preventDefault())
                        }
                    }
                }, {
                    key: "createOnMouseUpHandler",
                    value: function () {
                        var t = this;
                        return function (e) {
                            t.rotating = !1, document.removeEventListener("mousemove", t.onMouseMove), document.removeEventListener("mouseup", t.onMouseUp), e.preventDefault()
                        }
                    }
                }, {
                    key: "connect",
                    value: function () {
                        document.addEventListener("mousedown", this.onMouseDown)
                    }
                }, {
                    key: "update",
                    value: function () {
                        var e, t, n, r;
                        this.rotating && (this.camera.quaternion.copy(this.startCamera.quaternion), this.camera.quaternion.premultiply(this.deltaQuaternion), e = this.camera.quaternion, t = new c.Vector3(0, 0, 1).applyQuaternion(e), n = new c.Vector3(0, 1, 0), r = (new c.Vector3).crossVectors(n, t).normalize(), n.crossVectors(t, r).normalize(), e.setFromRotationMatrix((new c.Matrix4).makeBasis(r, n, t)))
                    }
                }, {
                    key: "disconnect",
                    value: function () {
                        document.removeEventListener("mousedown", this.onMouseDown)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this.disconnect()
                    }
                }]), n
            }(),
                // initDeviceControls
                a = function () {
                    function n(e, t) {
                        i(this, n), this.renderers = [t], this.canvas = t.domElement, this.camera = e, this.camera.rotation.reorder("YXZ"), this.enabled = !0, this.deviceOrientation = {}, this.alphaOffsetAngle = 0, this.tagOrientation = 0, this.tanPerHeight = 2 * Math.tan(c.Math.degToRad(.5 * e.fov)) / this.canvas.offsetHeight, this.deviceOrientationCallback = this.onDeviceOrientation.bind(this), this.resizeCallback = this.onResize.bind(this), this.fallbackControl = new o(e, t)
                    }
                    return r(n, [{
                        key: "addRenderer",
                        value: function (e) {
                            this.renderers.push(e), e.setSize(this.canvas.offsetWidth, this.canvas.offsetHeight, !1)
                        }
                    }, {
                        key: "onDeviceOrientation",
                        value: function (e) {
                            this.deviceOrientation = e
                        }
                    }, {
                        key: "onResize",
                        value: function () {
                            var t = this;
                            this.camera.aspect = this.canvas.offsetWidth / this.canvas.offsetHeight, this.camera.fov = 2 * c.Math.radToDeg(Math.atan(.5 * this.canvas.offsetHeight * this.tanPerHeight)), this.camera.updateProjectionMatrix(), this.renderers.forEach(function (e) {
                                e.setSize(t.canvas.offsetWidth, t.canvas.offsetHeight, !1)
                            }), this.onResizeExt && this.onResizeExt(this.canvas.width, this.canvas.height)
                        }
                    }, {
                        key: "updateCamera",
                        value: function (e, t, n, r) {
                            var i = new c.Vector3(0, 0, 1),
                                o = new c.Euler,
                                a = new c.Quaternion,
                                s = new c.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5));
                            o.set(t, e, -n, "YXZ"), this.camera.quaternion.setFromEuler(o), this.camera.quaternion.multiply(s), this.camera.quaternion.multiply(a.setFromAxisAngle(i, -r))
                        }
                    }, {
                        key: "connect",
                        value: function () {
                            window.addEventListener("resize", this.resizeCallback, !1), window.addEventListener("deviceorientation", this.deviceOrientationCallback, !1), this.enabled = !0, this.fallbackControl && this.fallbackControl.connect()
                        }
                    }, {
                        key: "disconnect",
                        value: function () {
                            window.removeEventListener("resize", this.resizeCallback, !1), window.removeEventListener("deviceorientation", this.deviceOrientationCallback, !1), this.enabled = !1, this.fallbackControl && this.fallbackControl.disconnect()
                        }
                    }, {
                        key: "disableOrientation",
                        value: function () {
                            window.removeEventListener("deviceorientation", this.deviceOrientationCallback, !1), this.enabled = !1, this.fallbackControl && this.fallbackControl.disconnect()
                        }
                    }, {
                        key: "update",
                        value: function () {
                            if (!1 !== this.enabled)
                                if (this.deviceOrientation.alpha) {
                                    this.fallbackControl && this.fallbackControl.disconnect();
                                    var e = c.Math.degToRad(this.deviceOrientation.alpha + this.alphaOffsetAngle + this.tagOrientation),
                                        t = this.deviceOrientation.beta ? c.Math.degToRad(this.deviceOrientation.beta) : 1.57,
                                        n = this.deviceOrientation.gamma ? c.Math.degToRad(this.deviceOrientation.gamma) : 0,
                                        r = window.orientation ? c.Math.degToRad(window.orientation) : 0;
                                    this.updateCamera(e, t, n, r)
                                } else this.fallbackControl && this.fallbackControl.update()
                        }
                    }, {
                        key: "setAlphaOffsetAngle",
                        value: function (e) {
                            this.alphaOffsetAngle = e
                        }
                    }, {
                        key: "updateTagOrientation",
                        value: function (e) {
                            this.tagOrientation = e
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.disconnect()
                        }
                    }]), n
                }();
            n.default = a
        }, {
            "../libs/three.module.js": 6
        }]
    }, {}, [2]);